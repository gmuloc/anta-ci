{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#anta-documentation-testing-stuff-v3","title":"ANTA Documentation - TESTING STUFF v3","text":"<p>This website provides generic documentation related to the Arista Network Test Automation framework (ANTA)</p> <p></p>"},{"location":"#arista-network-test-automation-anta-framework","title":"Arista Network Test Automation (ANTA) Framework","text":"<p>This repository is a Python package to automate tests on Arista devices.</p> <ul> <li>The package name is ANTA, which stands for Arista Network Test Automation.</li> <li>This package provides a set of tests to validate the state of your network.</li> <li>This package can be imported in Python scripts:<ul> <li>To automate NRFU (Network Ready For Use) test on a preproduction network</li> <li>To automate tests on a live network (periodically or on demand)</li> </ul> </li> </ul> <p>This repository comes with a cli to run Arista Network Test Automation (ANTA) framework using your preferred shell:</p> <pre><code># Install ANTA\npip install anta\n\n# Run ANTA cli\n$ anta\nUsage: anta [OPTIONS] COMMAND [ARGS]...\n\n  Arista Network Test Automation (ANTA) CLI\n\nOptions:\n  --version                       Show the version and exit.\n  --username TEXT                 Username to connect to EOS  [env var:\n                                  ANTA_USERNAME; required]\n--password TEXT                 Password to connect to EOS  [env var:\n                                  ANTA_PASSWORD; required]\n--timeout INTEGER               Global connection timeout  [env var:\n                                  ANTA_TIMEOUT; default: 5]\n--insecure                      Disable SSH Host Key validation  [env var:\n                                  ANTA_INSECURE]\n--enable-password TEXT          Enable password if required to connect  [env\n                                  var: ANTA_ENABLE_PASSWORD]\n-i, --inventory FILE            Path to the inventory YAML file  [env var:\n                                  ANTA_INVENTORY; required]\n--log-level, --log [CRITICAL|ERROR|WARNING|INFO|DEBUG]\nANTA logging level  [env var:\n                                  ANTA_LOG_LEVEL; default: INFO]\n--ignore-status                 Always exit with success  [env var:\n                                  ANTA_IGNORE_STATUS]\n--ignore-error                  Only report failures and not errors  [env\n                                  var: ANTA_IGNORE_ERROR]\n--help                          Show this message and exit.\n\nCommands:\n  debug  Debug commands for building ANTA\n  exec   Execute commands to inventory devices\n  get    Get data from/to ANTA\n  nrfu   Run NRFU against inventory devices\n</code></pre>"},{"location":"contribution/","title":"Contributions","text":""},{"location":"contribution/#how-to-contribute-to-anta","title":"How to contribute to ANTA","text":"<p>Contribution model is based on a fork-model. Don\u2019t push to arista-netdevops-community/anta directly. Always do a branch in your repository and create a PR.</p> <p>To help development, open your PR as soon as possible even in draft mode. It helps other to know on what you are working on and avoid duplicate PRs.</p>"},{"location":"contribution/#install-repository","title":"Install repository","text":"<p>Run these commands to install:</p> <ul> <li>The package ANTA and its dependencies</li> <li>ANTA cli executable.</li> </ul> <pre><code># Clone repository\ngit clone https://github.com/arista-netdevops-community/anta.git\ncd network-test-automation\n\n# Install module in editable mode\npip install -e .\n</code></pre> <p>Run these commands to verify:</p> <pre><code># Check python installation\n$ pip list\n\n# Check version using cli\n$ anta --version\nanta, version 0.6.0\n</code></pre>"},{"location":"contribution/#install-development-requirements","title":"Install development requirements","text":"<p>Run pip to install anta and its developement tools.</p> <pre><code>pip install 'anta[dev]'\n</code></pre> <p>This command has to be done after you install repository with commands provided in previous section.</p> <p>Then, tox is configued with few environment to run CI locally:</p> <pre><code>tox list\ndefault environments:\nclean  -&gt; run the test driver with /home/tom/.pyenv/versions/3.9.9/envs/arista-anta/bin/python3.9\npy38   -&gt; run the test driver with py38\npy39   -&gt; run the test driver with py39\npy310  -&gt; run the test driver with py310\nlint   -&gt; check the code style\ntype   -&gt; check typing\nreport -&gt; run the test driver with /home/tom/.pyenv/versions/3.9.9/envs/arista-anta/bin/python3.9\n\nadditional environments:\n3.8    -&gt; run the test driver with 3.8\n3.9    -&gt; run the test driver with 3.9\n3.10   -&gt; run the test driver with 3.10\n</code></pre>"},{"location":"contribution/#code-linting","title":"Code linting","text":"<pre><code>tox -e lint\n[...]\nlint: commands[0]&gt; flake8 --max-line-length=165 --config=/dev/null anta\nlint: commands[1]&gt; flake8 --max-line-length=165 --config=/dev/null scripts\nlint: commands[2]&gt; flake8 --max-line-length=165 --config=/dev/null tests\nlint: commands[3]&gt; pylint anta\n\n--------------------------------------------------------------------\nYour code has been rated at 10.00/10 (previous run: 10.00/10, +0.00)\n\nlint: commands[4]&gt; pylint scripts\n\n-------------------------------------------------------------------\nYour code has been rated at 10.00/10 (previous run: 7.15/10, +2.85)\n\n.pkg: _exit&gt; python /home/tom/.pyenv/versions/3.9.9/envs/arista-anta/lib/python3.9/site-packages/\\\npyproject_api/_backend.py True setuptools.build_meta\n  lint: OK (28.37=setup[7.03]+cmd[0.38,0.23,0.25,11.07,9.41] seconds)\ncongratulations :) (28.45 seconds)\n</code></pre>"},{"location":"contribution/#code-typing","title":"Code Typing","text":"<pre><code>tox -e type\n\ntype: commands[0]&gt; mypy --config-file=pyproject.toml anta\nSuccess: no issues found in 38 source files\ntype: commands[1]&gt; mypy --config-file=pyproject.toml scripts\nSuccess: no issues found in 6 source files\n.pkg: _exit&gt; python /home/tom/.pyenv/versions/3.9.9/envs/arista-anta/lib/python3.9/site-packages/\\\npyproject_api/_backend.py True setuptools.build_meta\n  type: OK (28.80=setup[24.54]+cmd[3.35,0.90] seconds)\ncongratulations :) (28.89 seconds)\n</code></pre>"},{"location":"contribution/#unit-tests","title":"Unit tests","text":"<p>To keep high quality code, we require to provide a Pytest for every tests implemented in ANTA.</p> <p>All submodule should have its own pytest section under <code>tests/units/anta_tests/&lt;submodule-name&gt;</code>. In this directory, you should have 3 files:</p> <ul> <li><code>__init__.py</code>: Just because it is used as a python module</li> <li><code>data.py</code>: Where all your parametrize go. So all your test information should be located here</li> <li><code>test_exc.py</code>: Pytest file with test definition.</li> </ul> <p>A pytest definition should be similar to this template:</p> <pre><code># -*- coding: utf-8 -*-\n\n\"\"\"\nTests for anta.tests.hardware.py\n\"\"\"\nfrom __future__ import annotations\n\nimport asyncio\nimport logging\nfrom typing import Any\nfrom unittest.mock import MagicMock\n\nimport pytest\n\nfrom anta.tests.hardware import VerifyAdverseDrops\nfrom tests.lib.utils import generate_test_ids_list\n\nfrom .data import INPUT_&lt;TEST_NAME&gt;\n\n@pytest.mark.parametrize(\"test_data\", INPUT_&lt;TEST_NAME&gt;, ids=generate_test_ids_list(INPUT_&lt;TEST_NAME&gt;))\ndef test_&lt;TEST_CASE&gt;(mocked_device: MagicMock, test_data: Any) -&gt; None:\n\"\"\"Check &lt;TEST_CASE&gt;.\"\"\"\n\n    logging.info(f\"Mocked device is: {mocked_device.host}\")\n    logging.info(f\"Mocked HW is: {mocked_device.hw_model}\")\n\n    test = &lt;TEST_CASE&gt;(mocked_device, eos_data=test_data[\"eos_data\"])\n    asyncio.run(test.test())\n\n    logging.debug(f\"test result is: {test.result}\")\n\n    assert str(test.result.name) == mocked_device.name\n    assert test.result.result == test_data[\"expected_result\"]\n</code></pre> <p>The <code>mocked_device</code> object is a fixture defined in Pytest to represent an InventoryDevice and the parametrize <code>test_data</code> is a list of dictionries with structure:</p> <pre><code>INPUT_RUNNING_CONFIG: List[Dict[str, Any]] = [\n  # Test Case #1\n    {\n        \"name\": \"failure\",\n        \"eos_data\": [\"blah blah\"],\n        \"side_effect\": None,\n        \"expected_result\": \"failure\",\n        \"expected_messages\": [\"blah blah\"]\n    },\n    # Test Case #2\n    {\n      ...\n    },\n]\n</code></pre> <p>Where we have:</p> <ul> <li><code>name</code>: Name of the test displayed by Pytest</li> <li><code>eos_data</code>: a list of data coming from EOS.</li> <li><code>side_effect</code>: defined for futur use.</li> <li><code>expected_result</code>: Result we expect for this test</li> <li><code>expected_messages</code>: Optional messages we expect for the test.</li> </ul> <p>Use Anta CLI to get test data</p> <p>To complete this block, you can use <code>anta debug</code> commands to get <code>AntaCommand</code> output to use in your test.</p>"},{"location":"contribution/#git-pre-commit-hook","title":"Git Pre-commit hook","text":"<pre><code>pip install pre-commit\npre-commit install\n</code></pre> <p>When running a commit or a pre-commit check:</p> <pre><code>\u276f echo \"import foobaz\" &gt; test.py &amp;&amp; git add test.py\n\u276f pre-commit\npylint...................................................................Failed\n- hook id: pylint\n- exit code: 22\n\n************* Module test\ntest.py:1:0: C0114: Missing module docstring (missing-module-docstring)\ntest.py:1:0: E0401: Unable to import 'foobaz' (import-error)\ntest.py:1:0: W0611: Unused import foobaz (unused-import)\n</code></pre>"},{"location":"contribution/#test-your-documentation","title":"Test your documentation","text":"<p>Writing documentation is crucial but managing links can be cumbersome. To be sure there is no 404, you can use <code>muffet</code> with this cli:</p> <pre><code>muffet -c 2 --color=always http://127.0.0.1:8000 -e fonts.gstatic.com\n</code></pre>"},{"location":"contribution/#continuous-integration","title":"Continuous Integration","text":"<p>GitHub actions is used to test git pushes and pull requests. The workflows are defined in this directory. We can view the result here</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#getting-started","title":"Getting Started","text":"<p>This section shows how to use ANTA with basic configuration. All examples are based on Arista Test Drive (ATD) topology you can access by reaching out to your prefered SE.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>The easiest way to intall ANTA package is to run Python (<code>&gt;=3.8</code>) and its pip package to install:</p> <pre><code>pip install anta\n</code></pre> <p>For more details about how to install package, please see the requirements and intallation section.</p>"},{"location":"getting-started/#configure-arista-eos-devices","title":"Configure Arista EOS devices","text":"<p>First, you need to configure your management interface</p> <pre><code>vrf instance MGMT\n!\ninterface Management0\n   description oob_management\n   vrf MGMT\n   ip address 192.168.0.10/24\n!\n</code></pre> <p>Then, configure access to eAPI:</p> <pre><code>!\nmanagement api http-commands\n   protocol https port 443\n   no shutdown\n   vrf MGMT\n      no shutdown\n   !\n!\n</code></pre>"},{"location":"getting-started/#create-your-inventory","title":"Create your inventory","text":"<p>First, we need to list devices we want to test. You can create a file manually with this format:</p> <pre><code>anta_inventory:\nhosts:\n- host: 192.168.0.10\nname: spine01\ntags: ['fabric', 'spine']\n- host: 192.168.0.11\nname: spine02\ntags: ['fabric', 'spine']\n- host: 192.168.0.12\nname: leaf01\ntags: ['fabric', 'leaf']\n- host: 192.168.0.13\nname: leaf02\ntags: ['fabric', 'leaf']\n- host: 192.168.0.14\nname: leaf03\ntags: ['fabric', 'leaf']\n- host: 192.168.0.15\nname: leaf04\ntags: ['fabric', 'leaf']\n</code></pre> <p>You can read more details about how to build your inventory here</p>"},{"location":"getting-started/#test-catalog","title":"Test Catalog","text":"<p>To test your network, it is important to define a test catalog to list all the tests to run against your inventory. Test catalog references python functions into a yaml file. This file can be loaded by anta.loader.py</p> <p>The structure to follow is like:</p> <pre><code>&lt;anta_tests_submodule&gt;:\n- &lt;anta_tests_submodule function name&gt;:\n&lt;test function option&gt;:\n&lt;test function option value&gt;\n</code></pre> <p>You can read more details about how to build your catalog here</p> <p>Here is an example for basic things:</p> <pre><code># Load anta.tests.software\nanta.tests.software:\n- VerifyEosVersion: # Verifies the device is running one of the allowed EOS version.\nversions: # List of allowed EOS versions.\n- 4.25.4M\n- 4.26.1F\n- '4.28.3M-28837868.4283M (engineering build)'\n- VerifyTerminAttrVersion:\nversions:\n- v1.22.1\n\nanta.tests.system:\n- VerifyUptime: # Verifies the device uptime is higher than a value.\nminimum: 1\n- VerifyNtp:\n- VerifySyslog:\n\nanta.tests.mlag:\n- VerifyMlagStatus:\n- VerifyMlagInterface:\n- VerifyMlagConfigSanity:\n\nanta.tests.configuration:\n- VerifyZeroTouch: # Verifies ZeroTouch is disabled.\n- VerifyRunningConfigDiffs:\n</code></pre>"},{"location":"getting-started/#test-your-network","title":"Test your network","text":"<p>To test EOS devices, this package comes with a generic CLI entrypoint to run tests in your network. It requires an inventory file as well as a test catalog.</p> <p>This entrypoint has multiple options to manage test coverage and reporting.</p> <pre><code># Generic ANTA options\n$ anta\nUsage: anta [OPTIONS] COMMAND [ARGS]...\n\n  Arista Network Test CLI\n\nOptions:\n  --version               Show the version and exit.\n  --username TEXT         Username to connect to EOS  [env var: ANTA_USERNAME;\nrequired]\n--password TEXT         Password to connect to EOS  [env var: ANTA_PASSWORD;\nrequired]\n--timeout INTEGER       Connection timeout (default 5)  [env var:\n                          ANTA_TIMEOUT]\n--enable-password TEXT  Enable password if required to connect  [env var:\n                          ANTA_ENABLE_PASSWORD]\n-i, --inventory PATH    Path to your inventory file  [env var:\n                          ANTA_INVENTORY; required]\n--help                  Show this message and exit.\n\nCommands:\n  exec  Execute commands to inventory devices\n  get   Get data from/to ANTA\n  nrfu  Run NRFU against inventory devices\n\n\n\n# NRFU part of ANTA\n$ anta nrfu\nUsage: anta nrfu [OPTIONS] COMMAND [ARGS]...\n\n  Run NRFU against inventory devices\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  json   ANTA command to check network state with JSON result\n  table  ANTA command to check network states with table result\n  text   ANTA command to check network states with text result\n</code></pre> <p>Default output is a table format listing all test results, and it can be changed to a report per test case or per host</p>"},{"location":"getting-started/#default-report-using-table","title":"Default report using table","text":"<pre><code>anta \\\n--username tom \\\n--password arista123 \\\n--enable-password t \\\n--inventory .personal/inventory_atd.yml \\\nnrfu table --tags leaf --catalog .personal/tests-bases.yml\n\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Settings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Running check-devices with:                              \u2502\n\u2502               - Inventory: .personal/inventory_atd.yml   \u2502\n\u2502               - Tests catalog: .personal/tests-bases.yml \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n                                                                            All tests results\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Device IP \u2503 Test Name                          \u2503 Test Status \u2503 Message(s)                                                     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 leaf01    \u2502 VerifyEosVersion                   \u2502 success     \u2502                                                                \u2502\n\u2502 leaf01    \u2502 VerifyTerminAttrVersion            \u2502 success     \u2502                                                                \u2502\n\u2502 leaf01    \u2502 VerifyUptime                       \u2502 success     \u2502                                                                \u2502\n\u2502 leaf01    \u2502 VerifyNtp                          \u2502 failure     \u2502 not sync with NTP server (NTP is disabled.)                    \u2502\n\u2502 leaf01    \u2502 VerifySyslog                       \u2502 failure     \u2502 Device has some log messages with a severity WARNING or higher \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"getting-started/#report-in-text-mode","title":"Report in text mode","text":"<pre><code>$ anta \\\n    --username tom \\\n    --password arista123 \\\n    --enable-password t \\\n    --inventory .personal/inventory_atd.yml \\\n    nrfu text --tags leaf --catalog .personal/tests-bases.yml\n\nleaf01 :: VerifyEosVersion :: SUCCESS\nleaf01 :: VerifyTerminAttrVersion :: SUCCESS\nleaf01 :: VerifyUptime :: SUCCESS\nleaf01 :: VerifyNtp :: FAILURE (not sync with NTP server (NTP is disabled.))\nleaf01 :: VerifySyslog :: FAILURE (Device has some log messages with a severity WARNING or higher)\n...\n</code></pre>"},{"location":"getting-started/#report-per-host","title":"Report per host","text":"<pre><code>$ anta \\\n--username tom \\\n--password arista123 \\\n--enable-password t \\\n--inventory .personal/inventory_atd.yml \\\nnrfu json --tags leaf --catalog .personal/tests-bases.yml\n\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 JSON results of all tests                                                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n[\n{\n\"name\": \"leaf01\",\n    \"test\": \"VerifyEosVersion\",\n    \"result\": \"success\",\n    \"messages\": \"[]\"\n},\n  {\n\"name\": \"leaf01\",\n    \"test\": \"VerifyTerminAttrVersion\",\n    \"result\": \"success\",\n    \"messages\": \"[]\"\n},\n...\n]\n</code></pre> <p>You can find more information under the usage section of the website</p>"},{"location":"requirements-and-installation/","title":"Installation","text":""},{"location":"requirements-and-installation/#anta-requirements","title":"ANTA Requirements","text":""},{"location":"requirements-and-installation/#python-version","title":"Python version","text":"<p>Python 3 (<code>&gt;=3.8</code> and <code>=&lt;3.10</code>) is required:</p> <pre><code>python --version\nPython 3.9.9\n</code></pre>"},{"location":"requirements-and-installation/#install-anta-package","title":"Install ANTA package","text":"<p>This installation will deploy tests collection, scripts and all their Python requirements.</p> <p>The ANTA package and the cli require some packages that are not part of the Python standard library. They are indicated in the pyproject.toml file</p>"},{"location":"requirements-and-installation/#install-from-pypi-server","title":"Install from Pypi server","text":"<pre><code>pip install anta\n</code></pre>"},{"location":"requirements-and-installation/#install-anta-from-github","title":"Install ANTA from github","text":"<pre><code>pip install git+https://github.com/arista-netdevops-community/anta.git\n</code></pre> <p>You can even specify the branch, tag or commit:</p> <ul> <li><code>&lt;anta-repository&gt;@&lt;cool-feature-branch&gt;</code></li> <li><code>&lt;anta-repository&gt;@&lt;cool-tag&gt;</code></li> <li><code>&lt;anta-repository&gt;@&lt;cool-hash&gt;</code></li> </ul>"},{"location":"requirements-and-installation/#check-installation","title":"Check installation","text":"<p>Run these commands to verify:</p> <pre><code># Check ANTA has been installed in your python path\npip list | grep anta\n\n# Check scripts are in your $PATH\n# Path may differ but it means CLI is in your path\nwhich anta\n/home/tom/.pyenv/shims/anta\n\n# Chck ANTA version\nanta --version\nanta, version 0.6.0\n</code></pre>"},{"location":"requirements-and-installation/#eos-requirements","title":"EOS Requirements","text":"<p>To get ANTA working, your Arista EOS devices must have the following configuration (assuming you connect to the device using Management interface in MGMT VRF):</p> <pre><code>configure\n!\nvrf instance MGMT\n!\ninterface Management1\n   description oob_management\n   vrf MGMT\n   ip address 10.73.1.105/24\n!\nend\n</code></pre> <p>Enable eAPI on the MGMT vrf:</p> <pre><code>configure\n!\nmanagement api http-commands\n   protocol https port 443\n   no shutdown\n   vrf MGMT\n      no shutdown\n!\nend\n</code></pre> <p>Now the swicth accepts on port 443 in the MGMT VRF HTTPS requests containing a list of CLI commands.</p> <p>Run these EOS commands to verify:</p> <pre><code>show management http-server\nshow management api http-commands\n</code></pre>"},{"location":"usage-inventory-catalog/","title":"Inventory & Tests catalog","text":""},{"location":"usage-inventory-catalog/#inventory-catalog-definition","title":"Inventory &amp; Catalog definition","text":"<p>This page describes how to create an inventory and a tests catalog.</p>"},{"location":"usage-inventory-catalog/#create-an-inventory-file","title":"Create an inventory file","text":"<p><code>anta</code> cli needs an inventory file to list all devices to tests. This inventory is a YAML file with the folowing keys:</p> <pre><code>anta_inventory:\nhosts:\n- host: &lt; ip address value &gt;\nport: &lt; TCP port for eAPI. Default is 443 (Optional)&gt;\nname: &lt; name to display in report. Default is host:port (Optional) &gt;\ntags: &lt; list of tags to use to filter inventory during tests. Default is ['all']. (Optional) &gt;\nnetworks:\n- network: &lt; network using CIDR notation &gt;\ntags: &lt; list of tags to use to filter inventory during tests. Default is ['all']. (Optional) &gt;\nranges:\n- start: &lt; first ip address value of the range &gt;\nend: &lt; last ip address value of the range &gt;\ntags: &lt; list of tags to use to filter inventory during tests. Default is ['all']. (Optional) &gt;\n</code></pre> <p>Your inventory file can be based on any of these 3 keys and shall start with <code>anta_inventory</code> key. A full description of inventory model is available in API documentation</p> <p>The next output is an inventory example:</p> <pre><code>---\nanta_inventory:\nhosts:\n- host: 192.168.0.10\nname: spine01\ntags: ['fabric', 'spine']\n- host: 192.168.0.11\nname: spine02\ntags: ['fabric', 'spine']\nnetworks:\n- network: '192.168.110.0/24'\ntags: ['fabric', 'leaf']\nranges:\n- start: 10.0.0.9\nend: 10.0.0.11\ntags: ['fabric', 'l2leaf']\n</code></pre>"},{"location":"usage-inventory-catalog/#test-catalog","title":"Test Catalog","text":"<p>In addition to your inventory file, you also have to define a catalog of tests to execute against all your devices. This catalogue list all your tests and their parameters.</p> <p>Its format is a YAML file and keys are tests functions inherited from the python path. Let\u2019s take an example below:</p>"},{"location":"usage-inventory-catalog/#default-tests-catalog","title":"Default tests catalog","text":"<p>All tests are located under <code>anta.tests</code> module and are categorised per family (one submodule). So to run test for software version, you can do:</p> <pre><code>anta.tests.software:\n- VerifyEosVersion:\n</code></pre> <p>It will load the test <code>VerifyEosVersion</code> located in <code>anta.tests.software</code>. But since this function has parameters, we will create a catalog with the following structure:</p> <pre><code>anta.tests.software:\n- VerifyEosVersion:\n# List of allowed EOS versions.\nversions:\n- 4.25.4M\n- 4.26.1F\n</code></pre> <p>To get a list of all available tests and their respective parameters, you can read the tests section of this website.</p> <p>The following example gives a very minimal tests catalog you can use in almost any situation</p> <pre><code>---\n# Load anta.tests.software\nanta.tests.software:\n# Verifies the device is running one of the allowed EOS version.\n- VerifyEosVersion:\n# List of allowed EOS versions.\nversions:\n- 4.25.4M\n- 4.26.1F\n\n# Load anta.tests.system\nanta.tests.system:\n# Verifies the device uptime is higher than a value.\n- VerifyUptime:\nminimum: 1\n\n# Load anta.tests.configuration\nanta.tests.configuration:\n# Verifies ZeroTouch is disabled.\n- VerifyZeroTouch:\n- VerifyRunningConfigDiffs:\n</code></pre> <p>If your test is based on <code>AntaTemplate</code>, you have to provide inputs for EOS CLI template by using <code>tpl_options</code> list:</p> <pre><code>anta.tests.routing.bgp:\n- VerifyBGPIPv4UnicastCount:\nnumber: 3\ntemplate_params:\n- vrf: default\n- vrf: customer-01\n</code></pre> <p>Which is required for the following test definition:</p> <pre><code>class VerifyBGPIPv4UnicastCount(AntaTest):\n\"\"\"\n    ...\n    \"\"\"\n\n    name = \"VerifyBGPIPv4UnicastCount\"\n    description = \"...\"\n    categories = [\"routing\", \"bgp\"]\n    template = AntaTemplate(template=\"show bgp ipv4 unicast summary vrf {vrf}\")\n\n    @check_bgp_family_enable(\"ipv4\")\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None) -&gt; None:\n        pass\n</code></pre>"},{"location":"usage-inventory-catalog/#custom-tests-catalog","title":"Custom tests catalog","text":"<p>In case you want to leverage your own tests collection, you can use the following syntax:</p> <pre><code>&lt;your package name&gt;:\n- &lt;your test in your package name&gt;:\n</code></pre> <p>So for instance, it could be:</p> <pre><code>titom73.tests.system:\n- VerifyPlatform:\ntype: ['cEOS-LAB']\n</code></pre> <p>How to create custom tests</p> <p>To create your custom tests, you should refer to this following documentation</p>"},{"location":"advanced_usages/as-python-lib/","title":"ANTA as python lib","text":""},{"location":"advanced_usages/as-python-lib/#how-to-use-anta-as-a-python-library","title":"How to use ANTA as a Python Library","text":"<p>ANTA has been built to allow user to embeded its tools in your own application. This section describes how you can leverage ANTA modules to help you create your own NRFU solution.</p>"},{"location":"advanced_usages/as-python-lib/#inventory-manager","title":"Inventory Manager","text":"<p>AntaInventory class is in charge of creating a list of hosts with their information and an eAPI session ready to be consummed. To do that, it connects to all devices to check reachability and ensure eAPI is running.</p> <pre><code>from anta.inventory import AntaInventory\n\ninventory = AntaInventory.parse(\n    inventory_file=\"inventory.yml\",\n    username=\"username\",\n    password=\"password\",\n    enable_password=\"enable\",\n    timeout=1,\n)\n</code></pre> <p>Then it is easy to get all devices or only active devices with the following method:</p> <pre><code># print the non reachable devices\nfor device in inventory.get_inventory(established_only=False):\n    if device.established is False:\n        print(f\"Could not connect to device {device.host}\")\n\n# run an EOS commands list on the reachable devices from the inventory\nfor device in inventory.get_inventory(established_only=True):\n    device.session.runCmds(\n        1, [\"show version\", \"show ip bgp summary\"]\n    )\n</code></pre> <p>You can find the ANTA Inventory module here.</p> How to create your inventory file <p>Please visit this dedicated section for how to use inventory and catalog files.</p>"},{"location":"advanced_usages/as-python-lib/#use-tests-from-anta","title":"Use tests from ANTA","text":"<p>All the test functions are based on the exact same input and returns a generic structure with different information.</p>"},{"location":"advanced_usages/as-python-lib/#test-input","title":"Test input","text":"<p>Any test input is based on an <code>InventoryDevice</code> object and a list of options. Here is an example to check uptime and check it is higher than <code>minimum</code> option.</p> <pre><code>def verify_uptime(device: InventoryDevice, minimum: int = None) -&gt; TestResult:\n</code></pre> <p>In general, <code>InventoryDevice</code> is an object created by <code>AntaInventory</code>. But it can be manually generated by following required data model.</p> <p>Here is an example of a list of <code>InventoryDevice</code></p> <pre><code>[\n    {\n        \"InventoryDevice(host=IPv4Address('192.168.0.17')\",\n        \"username='ansible'\",\n        \"password='ansible'\",\n        \"session=&lt;ServerProxy for ansible:ansible@192.168.0.17/command-api&gt;\",\n        \"url='https://ansible:ansible@192.168.0.17/command-api'\",\n        \"established=True\",\n        \"is_online=True\",\n        \"hw_model=cEOS-LAB\",\n    },\n\n    {\n        \"InventoryDevice(host=IPv4Address('192.168.0.2')\",\n        \"username='ansible'\",\n        \"password='ansible'\",\n        \"session=None\",\n        \"url='https://ansible:ansible@192.168.0.2/command-api'\",\n        \"established=False\"\n        \"is_online=False\",\n        \"tags\": ['dc1', 'spine', 'pod01'],\n        \"hw_model=unset\",\n    }\n]\n</code></pre>"},{"location":"advanced_usages/as-python-lib/#test-output","title":"Test output","text":"<p>All tests return a TestResult structure with the following elements:</p> <ul> <li><code>result</code>: Can be <code>success</code>, <code>skipped</code>, <code>failure</code>, <code>error</code> and report result of the test</li> <li><code>host</code>: IP address of the tested device</li> <li><code>test</code>: Test name runs on <code>host</code></li> <li><code>message</code>: Optional message returned by the test.</li> </ul>"},{"location":"advanced_usages/as-python-lib/#test-structure","title":"Test structure","text":"<p>All tests are built on a class named <code>AntaTest</code> which provides a complete toolset for a test:</p> <ul> <li>Object creation</li> <li>Test definition</li> <li>TestResult definition</li> <li>Abstracted method to collect data</li> </ul> <p>This approach means each time you create a test it will be based on this <code>AntaTest</code> class. Besides that, you will have to provide some elements:</p> <ul> <li><code>name</code>: Name of the test</li> <li><code>description</code>: A human readable description of your test</li> <li><code>categories</code>: a list of categories to sort test.</li> <li><code>commands</code>: a list of command to run. This list must be a list of <code>AntaCommand</code> which is described in the next part of this document.</li> </ul> <p>Here is an example of a hardware test related to device temperature:</p> <pre><code>from __future__ import annotations\n\nimport logging\nfrom typing import Any, Dict, List, Optional, cast\n\nfrom anta.models import AntaTest, AntaCommand\n\n\nclass VerifyTemperature(AntaTest):\n\"\"\"\n    Verifies device temparture is currently OK.\n    \"\"\"\n\n    name = \"VerifyTemperature\"\n    description = \"Verifies device temparture is currently OK\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show system environment temperature\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyTemperature validation\"\"\"\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n        temperature_status = command_output[\"systemStatus\"] if \"systemStatus\" in command_output.keys() else \"\"\n        if temperature_status == \"temperatureOk\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device temperature is not OK, systemStatus: {temperature_status }\")\n</code></pre> <p>When you run the test, object will automatically call its <code>anta.models.AntaTest.collect()</code> method to get device output. This method does a loop to call <code>anta.inventory.models.InventoryDevice.collect()</code> methods which is in charge of managing device connection and how to get data.</p> run test offline <p>You can also pass eos data directly to your test if you want to validate data collected in a different workflow. An example is provided below just for information:</p> <pre><code>test = VerifyTemperature(mocked_device, eos_data=test_data[\"eos_data\"])\nasyncio.run(test.test())\n</code></pre> <p>test function is always the same and must be defined with the <code>@AntaTest.anta_test</code> decorator. This function takes at least one argument which is a <code>anta.inventory.models.InventoryDevice</code> object and can have multiple additional parameters depending of your test definition. All parameters must come with a default value and the test function should validate the parameters values.</p> <pre><code>class VerifyTemperature(AntaTest):\n    ...\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        pass\n\nclass VerifyTransceiversManufacturers(AntaTest):\n    ...\n    @AntaTest.anta_test\n    def test(self, manufacturers: Optional[List[str]] = None) -&gt; None:\n        pass\n</code></pre> <p>The test itself does not return any value, but the result is directly availble from your object and exposes a <code>anta.result_manager.models.TestResult</code> object with result, name of the test and optional messages.</p> <pre><code>from anta.tests.hardware import VerifyTemperature\n\ntest = VerifyTemperature(mocked_device, eos_data=test_data[\"eos_data\"])\nasyncio.run(test.test())\nassert test.result.result == \"success\"\n</code></pre>"},{"location":"advanced_usages/as-python-lib/#commands-for-test","title":"Commands for test","text":"<p>To make it easier to get data, ANTA defines 2 different classes to manage commands to send to device:</p>"},{"location":"advanced_usages/as-python-lib/#antamodelsantacommand","title":"<code>anta.models.AntaCommand</code>","text":"<p>Abstract a command with following information:</p> <ul> <li>Command to run,</li> <li>Ouput format expected</li> <li>eAPI version</li> <li>Output of the command</li> </ul> <p>Usage example:</p> <pre><code>from anta.models import AntaCommand\n\ncmd1 = AntaCommand(command=\"show zerotouch\")\ncmd2 = AntaCommand(command=\"show running-config diffs\", ofmt=\"text\")\n</code></pre>"},{"location":"advanced_usages/as-python-lib/#antamodelsantatemplate","title":"<code>anta.models.AntaTemplate</code>","text":"<p>Because some command can require more dynamic than just a command with no parameter provided by user, ANTA supports command template: you define a template in your test class and user provide parameters when creating test object.</p> <pre><code>class RunArbitraryTemplateCommand(AntaTest):\n\"\"\"\n    Run an EOS command and return result\n    Based on AntaTest to build relevant output for pytest\n    \"\"\"\n\n    name = \"Run aributrary EOS command\"\n    description = \"To be used only with anta debug commands\"\n    template = AntaTemplate(template=\"show interfaces {ifd}\")\n    categories = [\"debug\"]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        errdisabled_interfaces = [interface for interface, value in response[\"interfaceStatuses\"].items() if value[\"linkStatus\"] == \"errdisabled\"]\n        ...\n\n\nparams = [{\"ifd\": \"Ethernet2\"}, {\"ifd\": \"Ethernet49/1\"}]\nrun_command1 = RunArbitraryTemplateCommand(device_anta, params)\n</code></pre> <p>In this example, test waits for interfaces to check from user setup and will only check for interfaces in <code>params</code></p>"},{"location":"advanced_usages/custom-tests/","title":"Create your own Library","text":""},{"location":"advanced_usages/custom-tests/#create-your-own-custom-tests","title":"Create your own custom tests","text":"<p>This documentation applies for both create tests in ANTA package or your custom package.</p> <p>ANTA is not only a CLI with a collection of built-in tests, it is also a framework you can extend by building your own tests library.</p> <p>For that, you need to create your own Python package as described in this hitchhiker\u2019s guide to package Python code. We assume it is well known and we won\u2019t focus on this aspect. Thus, your package must be impartable by ANTA hence available in <code>$PYTHONPATH</code> by any method.</p>"},{"location":"advanced_usages/custom-tests/#generic-approach","title":"Generic approach","text":"<p>ANTA comes with a class to use to build test. This class provides all the toolset required to define, collect and test data. The next code is an example of how to use ANTA to build a test</p> <pre><code>from __future__ import annotations\n\nimport logging\nfrom typing import Any, Dict, List, Optional, cast\n\nfrom anta.models import AntaTest, AntaCommand\n\n\nclass VerifyTemperature(AntaTest):\n\"\"\"\n    Verifies device temparture is currently OK.\n    \"\"\"\n\n    name = \"VerifyTemperature\"\n    description = \"Verifies device temparture is currently OK\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show system environment temperature\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyTemperature validation\"\"\"\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n        temperature_status = command_output[\"systemStatus\"] if \"systemStatus\" in command_output.keys() else \"\"\n        if temperature_status == \"temperatureOk\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device temperature is not OK, systemStatus: {temperature_status }\")\n</code></pre>"},{"location":"advanced_usages/custom-tests/#python-imports","title":"Python imports","text":""},{"location":"advanced_usages/custom-tests/#mandatory-imports","title":"Mandatory imports","text":"<p>The following elements have to be imported:</p> <ul> <li><code>InventoryDevice</code>: Where the eAPI session lives. It is used to send commands over HTTP/HTTPS define in your test.</li> <li><code>anta.models.AntaTest</code>: class that gives you all the tooling for your test</li> <li><code>anta.models.AntaCommand</code>: A class to abstract an Arista EOS command</li> </ul> <pre><code>from anta.models import AntaTest, AntaCommand\n\n\nclass VerifyTemperature(AntaTest):\n\"\"\"\n    Verifies device temparture is currently OK.\n    \"\"\"\n    ...\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        pass\n</code></pre>"},{"location":"advanced_usages/custom-tests/#optional-anta-imports","title":"Optional ANTA imports","text":"<p>Besides these 3 main imports, anta provides some additional and optional decorators:</p> <ul> <li><code>anta.test.skip_on_platforms</code>: To skip a test for a function not available for some platform</li> <li><code>anta.tests.check_bgp_family_enable</code>: To run tests only if specific BGP family is active.</li> </ul> <pre><code>from anta.decorators import skip_on_platforms\n\n\nclass VerifyTransceiversManufacturers(AntaTest):\n    ...\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self, manufacturers: Optional[List[str]] = None) -&gt; None:\n        pass\n</code></pre>"},{"location":"advanced_usages/custom-tests/#optional-python-imports","title":"Optional python imports","text":"<p>And finally, you are free to import any other python library you may want to use in your package.</p> <p>logging function</p> <p>It is strongly recommended to import <code>logging</code> to help development process and being able to log some outputs usefull for test development.</p> <p>If your test development is part of a pull request for ANTA, it is stringly advised to also import <code>typing</code> since our code testing requires to be compatible with Mypy.</p>"},{"location":"advanced_usages/custom-tests/#code-for-a-test","title":"Code for a test","text":"<p>A test is a python class where a test function is defined and will be run by the framework. So first you need to declare your class and then define your test function.</p>"},{"location":"advanced_usages/custom-tests/#create-test-class","title":"Create Test Class","text":"<p>To create class, you have to provide 4 elements:</p> <p>Metadata information</p> <ul> <li><code>name</code>: Name of the test</li> <li><code>description</code>: A human readable description of your test</li> <li><code>categories</code>: a list of categories to sort test.</li> </ul> <p>Commands to run</p> <ul> <li><code>commands</code>: a list of command to run. This list must be a list of <code>AntaCommand</code> which is described in the next part of this document.</li> <li><code>template</code>: a command template (<code>AntaTemplate</code>) to run where variables are provided during test execution.</li> </ul> <p>It is either <code>commands</code> or <code>template</code>. But not both.</p> <pre><code>from __future__ import annotations\n\nimport logging\nfrom typing import Any, Dict, List, Optional, cast\n\nfrom anta.models import AntaTest, AntaCommand\n\n\nclass &lt;YourTestName&gt;(AntaTest):\n\"\"\"\n    &lt;a docstring description of your test&gt;\n    \"\"\"\n\n    name = \"YourTestName\"                                           # should be your class name\n    description = \"&lt;test description in human reading format&gt;\"\n    categories = [\"&lt;a list of arbitrary categories&gt;\"]\n    commands = [\n        AntaCommand(\n            command=\"&lt;eos command to run&gt;\",\n            ofmt=\"&lt;command format output&gt;\",\n            version=\"&lt;eapi version to use&gt;\"\n        )\n    ]\n</code></pre> <p>This class will inherit methods from AntaTest and specfically the <code>__init__(self,...)</code> method to build your object. This function takes following arguments when you instantiate an object:</p> <ul> <li><code>device (InventoryDevice)</code>: Device object where to test happens.</li> <li><code>template_params</code>: If template is used in the test definition, then we provide data to build list of commands.</li> <li><code>eos_data</code>: Potential EOS data to pass if we don\u2019t want to connect to device to grab data.</li> <li><code>labels</code>: a list of labels. It is not used yet and it is for futur use.</li> </ul>"},{"location":"advanced_usages/custom-tests/#function-definition","title":"Function definition","text":"<p>The code here can be very simple as well as very complex and will depend of what you expect to do. But in all situation, the same baseline can be leverage:</p> <pre><code>class &lt;YourTestName&gt;(AntaTest):\n    ...\n    def test(self) -&gt; None:\n        pass\n</code></pre> <p>If you want to support option in your test, just declare your options in your test method:</p> <pre><code>class &lt;YourTestName&gt;(AntaTest):\n    ...\n    def test(self, my_param1: str) -&gt; None:\n        pass\n</code></pre>"},{"location":"advanced_usages/custom-tests/#check-inputs","title":"Check inputs","text":"<p>If your test has some user inputs, you first have to validate the supplied values are valid. If it is not valid, we expect <code>TestResult</code> to return <code>skipped</code> with a custom message.</p> <pre><code># Check if test option is correct\nif not minimum:\n    self.result.is_skipped(\"verify_dynamic_vlan was run without minimum value set\")\nelse:\n    ...\n</code></pre>"},{"location":"advanced_usages/custom-tests/#implement-your-logic","title":"Implement your logic","text":"<p>Here you implement your own logic. In general, the first action is to send command to devices and capture its response.</p> <p>In the example below, we request the list of vlans configured on device and then count all the vlans marked as dynamic</p> <pre><code># Grab data for your command\ncommand_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n# Do your test: In this example we count number of vlans with field dynamic set to true\nnum_dyn_vlan = len([ vlan for vlan,data in command_output['vlans'].items() if command_output['dynamic'] is True])\nif num_dyn_vlan &gt;= minimum:\n    self.result.is_success()\nelse:\n    self.result.is_failure(f\"Device has {num_dyn_vlan} configured, we expect at least {minimum}\")\n</code></pre> <p>As you can see there is no error management to do in your code. Everything is packaged in <code>anta_tests</code> and below is a simple example of error captured with an incorrect JSON key in the code above:</p> <pre><code>ERROR    Exception raised for test verify_dynamic_vlan (on device 192.168.0.10) - KeyError ('vlans')\n</code></pre> <p>Get stack trace for debugging</p> <p>If you want to access to the full exception stack, you can run your test with logging level set to <code>DEBUG</code>. With ANTA cli, it is available with following option: <pre><code>$ anta nrfu text --catalog test_custom.yml --log-level debug\n</code></pre></p>"},{"location":"advanced_usages/custom-tests/#create-your-catalog","title":"Create your catalog","text":"<p>This section is required only if you are not merging your development into ANTA. Otherwise, just follow contribution guide.</p> <p>It is very similar to what is documented in catalog section but you have to use your own package name.</p> <p>Let say the custom catalog is <code>anta_titom73</code> and the test is configured in <code>anta_titom73.dc_project</code>, the test catalog would look like:</p> <p><pre><code>anta_titom73.dc_project:\n- VerifyFeatureX:\nminimum: 1\n</code></pre> And now you can run your NRFU tests with the CLI:</p> <pre><code>anta nrfu text --catalog test_custom.yml\nspine01 :: verify_dynamic_vlan :: FAILURE (Device has 0 configured, we expect at least 1)\nspine02 :: verify_dynamic_vlan :: FAILURE (Device has 0 configured, we expect at least 1)\nleaf01 :: verify_dynamic_vlan :: SUCCESS\nleaf02 :: verify_dynamic_vlan :: SUCCESS\nleaf03 :: verify_dynamic_vlan :: SUCCESS\nleaf04 :: verify_dynamic_vlan :: SUCCESS\n</code></pre> <p>Install your python package</p> <p>Anta uses Python path to access to your test. So it is critical to have your tests library installed correctly as explained at the begining of this page.</p>"},{"location":"api/device/","title":"AntaDevice Abstracted class","text":""},{"location":"api/device/#antadevice-abstracted-class","title":"AntaDevice Abstracted class","text":"<p>         Bases: <code>ABC</code></p> <p>Abstract class representing a device in ANTA. An implementation of this class needs must override the abstract coroutines <code>collect()</code> and <code>refresh()</code>.</p> Instance attributes <p>name: Device name is_online: True if the device IP is reachable and a port can be open established: True if remote command execution succeeds hw_model: Hardware model of the device tags: List of tags for this device</p> Source code in <code>anta/device.py</code> <pre><code>class AntaDevice(ABC):\n\"\"\"\n    Abstract class representing a device in ANTA.\n    An implementation of this class needs must override the abstract coroutines `collect()` and\n    `refresh()`.\n\n    Instance attributes:\n        name: Device name\n        is_online: True if the device IP is reachable and a port can be open\n        established: True if remote command execution succeeds\n        hw_model: Hardware model of the device\n        tags: List of tags for this device\n    \"\"\"\n\n    def __init__(self, name: str, tags: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Constructor of AntaDevice\n\n        Args:\n            name: Device name\n            tags: List of tags for this device\n        \"\"\"\n        self.name: str = name\n        self.hw_model: Optional[str] = None\n        self.tags: List[str] = tags if tags is not None else []\n        self.is_online: bool = False\n        self.established: bool = False\n\n        # Ensure tag 'all' is always set\n        if DEFAULT_TAG not in self.tags:\n            self.tags.append(DEFAULT_TAG)\n\n    def __rich_repr__(self) -&gt; Iterator[Tuple[str, Any]]:\n\"\"\"\n        Implements Rich Repr Protocol\n        https://rich.readthedocs.io/en/stable/pretty.html#rich-repr-protocol\n        \"\"\"\n        yield \"name\", self.name\n        yield \"tags\", self.tags\n        yield \"hw_model\", self.hw_model\n        yield \"is_online\", self.is_online\n        yield \"established\", self.established\n\n    @abstractmethod\n    def __eq__(self, other: object) -&gt; bool:\n\"\"\"\n        AntaDevice equality depends on the class implementation.\n        \"\"\"\n\n    @abstractmethod\n    async def collect(self, command: AntaCommand) -&gt; None:\n\"\"\"\n        Collect device command output.\n        This abstract coroutine can be used to implement any command collection method\n        for a device in ANTA.\n\n        The `collect()` implementation needs to populate the `output` attribute\n        of the `AntaCommand` object passed as argument.\n\n        If a failure occurs, the `collect()` implementation is expected to catch the\n        exception and implement proper logging, the `output` attribute of the\n        `AntaCommand` object passed as argument would be `None` in this case.\n\n        Args:\n            command: the command to collect\n        \"\"\"\n\n    async def collect_commands(self, commands: List[AntaCommand]) -&gt; None:\n\"\"\"\n        Collect multiple commands.\n\n        Args:\n            commands: the commands to collect\n        \"\"\"\n        await asyncio.gather(*(self.collect(command=command) for command in commands))\n\n    @abstractmethod\n    async def refresh(self) -&gt; None:\n\"\"\"\n        Update attributes of an AntaDevice instance.\n\n        This coroutine must update the following attributes of AntaDevice:\n        - is_online: When the device IP is reachable and a port can be open\n        - established: When a command execution succeeds\n        - hw_model: The hardware model of the device\n        \"\"\"\n\n    async def copy(self, sources: List[Path], destination: Path, direction: Literal[\"to\", \"from\"] = \"from\") -&gt; None:\n\"\"\"\n        Copy files to and from the device, usually through SCP.\n        It is not mandatory to implement this for a valid AntaDevice subclass.\n\n        Args:\n            sources: List of files to copy to or from the device.\n            destination: Local or remote destination when copying the files. Can be a folder.\n            direction: Defines if this coroutine copies files to or from the device.\n        \"\"\"\n        raise NotImplementedError(f\"copy() method has not been implemented in {self.__class__.__name__} definition\")\n</code></pre>"},{"location":"api/device/#anta.device.AntaDevice.__eq__","title":"<code>__eq__(other)</code>  <code>abstractmethod</code>","text":"<p>AntaDevice equality depends on the class implementation.</p> Source code in <code>anta/device.py</code> <pre><code>@abstractmethod\ndef __eq__(self, other: object) -&gt; bool:\n\"\"\"\n    AntaDevice equality depends on the class implementation.\n    \"\"\"\n</code></pre>"},{"location":"api/device/#anta.device.AntaDevice.__init__","title":"<code>__init__(name, tags=None)</code>","text":"<p>Constructor of AntaDevice</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Device name</p> required <code>tags</code> <code>Optional[List[str]]</code> <p>List of tags for this device</p> <code>None</code> Source code in <code>anta/device.py</code> <pre><code>def __init__(self, name: str, tags: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Constructor of AntaDevice\n\n    Args:\n        name: Device name\n        tags: List of tags for this device\n    \"\"\"\n    self.name: str = name\n    self.hw_model: Optional[str] = None\n    self.tags: List[str] = tags if tags is not None else []\n    self.is_online: bool = False\n    self.established: bool = False\n\n    # Ensure tag 'all' is always set\n    if DEFAULT_TAG not in self.tags:\n        self.tags.append(DEFAULT_TAG)\n</code></pre>"},{"location":"api/device/#anta.device.AntaDevice.__rich_repr__","title":"<code>__rich_repr__()</code>","text":"<p>Implements Rich Repr Protocol https://rich.readthedocs.io/en/stable/pretty.html#rich-repr-protocol</p> Source code in <code>anta/device.py</code> <pre><code>def __rich_repr__(self) -&gt; Iterator[Tuple[str, Any]]:\n\"\"\"\n    Implements Rich Repr Protocol\n    https://rich.readthedocs.io/en/stable/pretty.html#rich-repr-protocol\n    \"\"\"\n    yield \"name\", self.name\n    yield \"tags\", self.tags\n    yield \"hw_model\", self.hw_model\n    yield \"is_online\", self.is_online\n    yield \"established\", self.established\n</code></pre>"},{"location":"api/device/#anta.device.AntaDevice.collect","title":"<code>collect(command)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Collect device command output. This abstract coroutine can be used to implement any command collection method for a device in ANTA.</p> <p>The <code>collect()</code> implementation needs to populate the <code>output</code> attribute of the <code>AntaCommand</code> object passed as argument.</p> <p>If a failure occurs, the <code>collect()</code> implementation is expected to catch the exception and implement proper logging, the <code>output</code> attribute of the <code>AntaCommand</code> object passed as argument would be <code>None</code> in this case.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>AntaCommand</code> <p>the command to collect</p> required Source code in <code>anta/device.py</code> <pre><code>@abstractmethod\nasync def collect(self, command: AntaCommand) -&gt; None:\n\"\"\"\n    Collect device command output.\n    This abstract coroutine can be used to implement any command collection method\n    for a device in ANTA.\n\n    The `collect()` implementation needs to populate the `output` attribute\n    of the `AntaCommand` object passed as argument.\n\n    If a failure occurs, the `collect()` implementation is expected to catch the\n    exception and implement proper logging, the `output` attribute of the\n    `AntaCommand` object passed as argument would be `None` in this case.\n\n    Args:\n        command: the command to collect\n    \"\"\"\n</code></pre>"},{"location":"api/device/#anta.device.AntaDevice.collect_commands","title":"<code>collect_commands(commands)</code>  <code>async</code>","text":"<p>Collect multiple commands.</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>List[AntaCommand]</code> <p>the commands to collect</p> required Source code in <code>anta/device.py</code> <pre><code>async def collect_commands(self, commands: List[AntaCommand]) -&gt; None:\n\"\"\"\n    Collect multiple commands.\n\n    Args:\n        commands: the commands to collect\n    \"\"\"\n    await asyncio.gather(*(self.collect(command=command) for command in commands))\n</code></pre>"},{"location":"api/device/#anta.device.AntaDevice.copy","title":"<code>copy(sources, destination, direction='from')</code>  <code>async</code>","text":"<p>Copy files to and from the device, usually through SCP. It is not mandatory to implement this for a valid AntaDevice subclass.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>List[Path]</code> <p>List of files to copy to or from the device.</p> required <code>destination</code> <code>Path</code> <p>Local or remote destination when copying the files. Can be a folder.</p> required <code>direction</code> <code>Literal['to', 'from']</code> <p>Defines if this coroutine copies files to or from the device.</p> <code>'from'</code> Source code in <code>anta/device.py</code> <pre><code>async def copy(self, sources: List[Path], destination: Path, direction: Literal[\"to\", \"from\"] = \"from\") -&gt; None:\n\"\"\"\n    Copy files to and from the device, usually through SCP.\n    It is not mandatory to implement this for a valid AntaDevice subclass.\n\n    Args:\n        sources: List of files to copy to or from the device.\n        destination: Local or remote destination when copying the files. Can be a folder.\n        direction: Defines if this coroutine copies files to or from the device.\n    \"\"\"\n    raise NotImplementedError(f\"copy() method has not been implemented in {self.__class__.__name__} definition\")\n</code></pre>"},{"location":"api/device/#anta.device.AntaDevice.refresh","title":"<code>refresh()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Update attributes of an AntaDevice instance.</p> <p>This coroutine must update the following attributes of AntaDevice: - is_online: When the device IP is reachable and a port can be open - established: When a command execution succeeds - hw_model: The hardware model of the device</p> Source code in <code>anta/device.py</code> <pre><code>@abstractmethod\nasync def refresh(self) -&gt; None:\n\"\"\"\n    Update attributes of an AntaDevice instance.\n\n    This coroutine must update the following attributes of AntaDevice:\n    - is_online: When the device IP is reachable and a port can be open\n    - established: When a command execution succeeds\n    - hw_model: The hardware model of the device\n    \"\"\"\n</code></pre>"},{"location":"api/device/#asynceosdevice-class","title":"AsyncEOSDevice class","text":"<p>         Bases: <code>AntaDevice</code></p> <p>Implementation of AntaDevice for EOS using aio-eapi.</p> Instance attributes <p>name: Device name is_online: True if the device IP is reachable and a port can be open established: True if remote command execution succeeds hw_model: Hardware model of the device tags: List of tags for this device</p> Source code in <code>anta/device.py</code> <pre><code>class AsyncEOSDevice(AntaDevice):\n\"\"\"\n    Implementation of AntaDevice for EOS using aio-eapi.\n\n    Instance attributes:\n        name: Device name\n        is_online: True if the device IP is reachable and a port can be open\n        established: True if remote command execution succeeds\n        hw_model: Hardware model of the device\n        tags: List of tags for this device\n    \"\"\"\n\n    def __init__(  # pylint: disable=R0913\n        self,\n        host: str,\n        username: str,\n        password: str,\n        name: Optional[str] = None,\n        enable_password: Optional[str] = None,\n        port: Optional[int] = None,\n        ssh_port: Optional[int] = 22,\n        tags: Optional[List[str]] = None,\n        timeout: Optional[float] = None,\n        insecure: bool = False,\n        proto: Literal[\"http\", \"https\"] = \"https\",\n    ) -&gt; None:\n\"\"\"\n        Constructor of AsyncEOSDevice\n\n        Args:\n            host: Device FQDN or IP\n            username: Username to connect to eAPI and SSH\n            password: Password to connect to eAPI and SSH\n            name: Device name\n            enable_password: Password used to gain privileged access on EOS\n            proto: eAPI protocol. Value can be 'http' or 'https'\n            port: eAPI port. Defaults to 80 is proto is 'http' or 443 if proto is 'https'.\n            ssh_port: SSH port\n            insecure: Disable SSH Host Key validation\n            tags: List of tags for this device\n            timeout: Timeout value in seconds for outgoing connections. Default to 10 secs.\n        \"\"\"\n        if name is None:\n            name = f\"{host}:{port}\"\n        super().__init__(name, tags)\n        self._enable_password = enable_password\n        self._session: Device = Device(host=host, port=port, username=username, password=password, proto=proto, timeout=timeout)\n        ssh_params: Dict[str, Any] = {}\n        if insecure:\n            ssh_params.update({\"known_hosts\": None})\n        self._ssh_opts: SSHClientConnectionOptions = SSHClientConnectionOptions(host=host, port=ssh_port, username=username, password=password, **ssh_params)\n\n    def __rich_repr__(self) -&gt; Iterator[Tuple[str, Any]]:\n\"\"\"\n        Implements Rich Repr Protocol\n        https://rich.readthedocs.io/en/stable/pretty.html#rich-repr-protocol\n        \"\"\"\n        yield from super().__rich_repr__()\n        yield \"host\", self._session.host\n        yield \"eapi_port\", self._session.port\n        yield \"username\", self._ssh_opts.username\n        yield \"password\", self._ssh_opts.password\n        yield \"enable_password\", self._enable_password\n        yield \"insecure\", self._ssh_opts.known_hosts is None\n        if __DEBUG__:\n            yield \"_session\", vars(self._session)\n            yield \"_ssh_opts\", vars(self._ssh_opts)\n\n    def __eq__(self, other: object) -&gt; bool:\n\"\"\"\n        Two AsyncEOSDevice objects are equal if the hostname and the port are the same.\n        This covers the use case of port forwarding when the host is localhost and the devices have different ports.\n        \"\"\"\n        if not isinstance(other, AsyncEOSDevice):\n            return False\n        return self._session.host == other._session.host and self._session.port == other._session.port\n\n    async def collect(self, command: AntaCommand) -&gt; None:\n\"\"\"\n        Collect device command output from EOS using aio-eapi.\n\n        Supports outformat `json` and `text` as output structure.\n        Gain privileged access using the `enable_password` attribute\n        of the `AntaDevice` instance if populated.\n\n        Args:\n            command: the command to collect\n        \"\"\"\n        try:\n            commands = []\n            if self._enable_password is not None:\n                commands.append(\n                    {\n                        \"cmd\": \"enable\",\n                        \"input\": str(self._enable_password),\n                    }\n                )\n            else:\n                commands.append({\"cmd\": \"enable\"})\n            if command.revision:\n                commands.append({\"cmd\": command.command, \"revision\": command.revision})\n            else:\n                commands.append({\"cmd\": command.command})\n            response = await self._session.cli(\n                commands=commands,\n                ofmt=command.ofmt,\n                version=command.version,\n            )\n            # remove first dict related to enable command\n            # only applicable to json output\n            if command.ofmt in [\"json\", \"text\"]:\n                # selecting only our command output\n                response = response[1]\n            command.output = response\n            logger.debug(f\"{self.name}: {command}\")\n\n        except EapiCommandError as e:\n            message = f\"Command '{command.command}' failed on {self.name}\"\n            anta_log_exception(e, message, logger)\n            command.failed = e\n        except (HTTPError, ConnectError) as e:\n            message = f\"Cannot connect to device {self.name}\"\n            anta_log_exception(e, message, logger)\n            command.failed = e\n        except Exception as e:  # pylint: disable=broad-exception-caught\n            message = f\"Exception raised while collecting command '{command.command}' on device {self.name}\"\n            anta_log_exception(e, message, logger)\n            command.failed = e\n            logger.debug(command)\n\n    async def refresh(self) -&gt; None:\n\"\"\"\n        Update attributes of an AsyncEOSDevice instance.\n\n        This coroutine must update the following attributes of AsyncEOSDevice:\n        - is_online: When a device IP is reachable and a port can be open\n        - established: When a command execution succeeds\n        - hw_model: The hardware model of the device\n        \"\"\"\n        # Refresh command\n        COMMAND: str = \"show version\"\n        # Hardware model definition in show version\n        HW_MODEL_KEY: str = \"modelName\"\n        logger.debug(f\"Refreshing device {self.name}\")\n        self.is_online = await self._session.check_connection()\n        if self.is_online:\n            try:\n                response = await self._session.cli(command=COMMAND)\n            except EapiCommandError as e:\n                logger.warning(f\"Cannot get hardware information from device {self.name}: {e.errmsg}\")\n            except (HTTPError, ConnectError) as e:\n                logger.warning(f\"Cannot get hardware information from device {self.name}: {exc_to_str(e)}\")\n            else:\n                if HW_MODEL_KEY in response:\n                    self.hw_model = response[HW_MODEL_KEY]\n                else:\n                    logger.warning(f\"Cannot get hardware information from device {self.name}: cannot parse '{COMMAND}'\")\n        else:\n            logger.warning(f\"Could not connect to device {self.name}: cannot open eAPI port\")\n        self.established = bool(self.is_online and self.hw_model)\n\n    async def copy(self, sources: List[Path], destination: Path, direction: Literal[\"to\", \"from\"] = \"from\") -&gt; None:\n\"\"\"\n        Copy files to and from the device using asyncssh.scp().\n\n        Args:\n            sources: List of files to copy to or from the device.\n            destination: Local or remote destination when copying the files. Can be a folder.\n            direction: Defines if this coroutine copies files to or from the device.\n        \"\"\"\n        async with asyncssh.connect(\n            host=self._ssh_opts.host,\n            port=self._ssh_opts.port,\n            tunnel=self._ssh_opts.tunnel,\n            family=self._ssh_opts.family,\n            local_addr=self._ssh_opts.local_addr,\n            options=self._ssh_opts,\n        ) as conn:\n            src: Union[List[Tuple[SSHClientConnection, Path]], List[Path]]\n            dst: Union[Tuple[SSHClientConnection, Path], Path]\n            if direction == \"from\":\n                src = [(conn, file) for file in sources]\n                dst = destination\n                for file in sources:\n                    logger.info(f\"Copying '{file}' from device {self.name} to '{destination}' locally\")\n            elif direction == \"to\":\n                src = sources\n                dst = (conn, destination)\n                for file in sources:\n                    logger.info(f\"Copying '{file}' to device {self.name} to '{destination}' remotely\")\n            else:\n                logger.critical(f\"'direction' argument to copy() fonction is invalid: {direction}\")\n                return\n            await asyncssh.scp(src, dst)\n</code></pre>"},{"location":"api/device/#anta.device.AsyncEOSDevice.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Two AsyncEOSDevice objects are equal if the hostname and the port are the same. This covers the use case of port forwarding when the host is localhost and the devices have different ports.</p> Source code in <code>anta/device.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n\"\"\"\n    Two AsyncEOSDevice objects are equal if the hostname and the port are the same.\n    This covers the use case of port forwarding when the host is localhost and the devices have different ports.\n    \"\"\"\n    if not isinstance(other, AsyncEOSDevice):\n        return False\n    return self._session.host == other._session.host and self._session.port == other._session.port\n</code></pre>"},{"location":"api/device/#anta.device.AsyncEOSDevice.__init__","title":"<code>__init__(host, username, password, name=None, enable_password=None, port=None, ssh_port=22, tags=None, timeout=None, insecure=False, proto='https')</code>","text":"<p>Constructor of AsyncEOSDevice</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Device FQDN or IP</p> required <code>username</code> <code>str</code> <p>Username to connect to eAPI and SSH</p> required <code>password</code> <code>str</code> <p>Password to connect to eAPI and SSH</p> required <code>name</code> <code>Optional[str]</code> <p>Device name</p> <code>None</code> <code>enable_password</code> <code>Optional[str]</code> <p>Password used to gain privileged access on EOS</p> <code>None</code> <code>proto</code> <code>Literal['http', 'https']</code> <p>eAPI protocol. Value can be \u2018http\u2019 or \u2018https\u2019</p> <code>'https'</code> <code>port</code> <code>Optional[int]</code> <p>eAPI port. Defaults to 80 is proto is \u2018http\u2019 or 443 if proto is \u2018https\u2019.</p> <code>None</code> <code>ssh_port</code> <code>Optional[int]</code> <p>SSH port</p> <code>22</code> <code>insecure</code> <code>bool</code> <p>Disable SSH Host Key validation</p> <code>False</code> <code>tags</code> <code>Optional[List[str]]</code> <p>List of tags for this device</p> <code>None</code> <code>timeout</code> <code>Optional[float]</code> <p>Timeout value in seconds for outgoing connections. Default to 10 secs.</p> <code>None</code> Source code in <code>anta/device.py</code> <pre><code>def __init__(  # pylint: disable=R0913\n    self,\n    host: str,\n    username: str,\n    password: str,\n    name: Optional[str] = None,\n    enable_password: Optional[str] = None,\n    port: Optional[int] = None,\n    ssh_port: Optional[int] = 22,\n    tags: Optional[List[str]] = None,\n    timeout: Optional[float] = None,\n    insecure: bool = False,\n    proto: Literal[\"http\", \"https\"] = \"https\",\n) -&gt; None:\n\"\"\"\n    Constructor of AsyncEOSDevice\n\n    Args:\n        host: Device FQDN or IP\n        username: Username to connect to eAPI and SSH\n        password: Password to connect to eAPI and SSH\n        name: Device name\n        enable_password: Password used to gain privileged access on EOS\n        proto: eAPI protocol. Value can be 'http' or 'https'\n        port: eAPI port. Defaults to 80 is proto is 'http' or 443 if proto is 'https'.\n        ssh_port: SSH port\n        insecure: Disable SSH Host Key validation\n        tags: List of tags for this device\n        timeout: Timeout value in seconds for outgoing connections. Default to 10 secs.\n    \"\"\"\n    if name is None:\n        name = f\"{host}:{port}\"\n    super().__init__(name, tags)\n    self._enable_password = enable_password\n    self._session: Device = Device(host=host, port=port, username=username, password=password, proto=proto, timeout=timeout)\n    ssh_params: Dict[str, Any] = {}\n    if insecure:\n        ssh_params.update({\"known_hosts\": None})\n    self._ssh_opts: SSHClientConnectionOptions = SSHClientConnectionOptions(host=host, port=ssh_port, username=username, password=password, **ssh_params)\n</code></pre>"},{"location":"api/device/#anta.device.AsyncEOSDevice.__rich_repr__","title":"<code>__rich_repr__()</code>","text":"<p>Implements Rich Repr Protocol https://rich.readthedocs.io/en/stable/pretty.html#rich-repr-protocol</p> Source code in <code>anta/device.py</code> <pre><code>def __rich_repr__(self) -&gt; Iterator[Tuple[str, Any]]:\n\"\"\"\n    Implements Rich Repr Protocol\n    https://rich.readthedocs.io/en/stable/pretty.html#rich-repr-protocol\n    \"\"\"\n    yield from super().__rich_repr__()\n    yield \"host\", self._session.host\n    yield \"eapi_port\", self._session.port\n    yield \"username\", self._ssh_opts.username\n    yield \"password\", self._ssh_opts.password\n    yield \"enable_password\", self._enable_password\n    yield \"insecure\", self._ssh_opts.known_hosts is None\n    if __DEBUG__:\n        yield \"_session\", vars(self._session)\n        yield \"_ssh_opts\", vars(self._ssh_opts)\n</code></pre>"},{"location":"api/device/#anta.device.AsyncEOSDevice.collect","title":"<code>collect(command)</code>  <code>async</code>","text":"<p>Collect device command output from EOS using aio-eapi.</p> <p>Supports outformat <code>json</code> and <code>text</code> as output structure. Gain privileged access using the <code>enable_password</code> attribute of the <code>AntaDevice</code> instance if populated.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>AntaCommand</code> <p>the command to collect</p> required Source code in <code>anta/device.py</code> <pre><code>async def collect(self, command: AntaCommand) -&gt; None:\n\"\"\"\n    Collect device command output from EOS using aio-eapi.\n\n    Supports outformat `json` and `text` as output structure.\n    Gain privileged access using the `enable_password` attribute\n    of the `AntaDevice` instance if populated.\n\n    Args:\n        command: the command to collect\n    \"\"\"\n    try:\n        commands = []\n        if self._enable_password is not None:\n            commands.append(\n                {\n                    \"cmd\": \"enable\",\n                    \"input\": str(self._enable_password),\n                }\n            )\n        else:\n            commands.append({\"cmd\": \"enable\"})\n        if command.revision:\n            commands.append({\"cmd\": command.command, \"revision\": command.revision})\n        else:\n            commands.append({\"cmd\": command.command})\n        response = await self._session.cli(\n            commands=commands,\n            ofmt=command.ofmt,\n            version=command.version,\n        )\n        # remove first dict related to enable command\n        # only applicable to json output\n        if command.ofmt in [\"json\", \"text\"]:\n            # selecting only our command output\n            response = response[1]\n        command.output = response\n        logger.debug(f\"{self.name}: {command}\")\n\n    except EapiCommandError as e:\n        message = f\"Command '{command.command}' failed on {self.name}\"\n        anta_log_exception(e, message, logger)\n        command.failed = e\n    except (HTTPError, ConnectError) as e:\n        message = f\"Cannot connect to device {self.name}\"\n        anta_log_exception(e, message, logger)\n        command.failed = e\n    except Exception as e:  # pylint: disable=broad-exception-caught\n        message = f\"Exception raised while collecting command '{command.command}' on device {self.name}\"\n        anta_log_exception(e, message, logger)\n        command.failed = e\n        logger.debug(command)\n</code></pre>"},{"location":"api/device/#anta.device.AsyncEOSDevice.copy","title":"<code>copy(sources, destination, direction='from')</code>  <code>async</code>","text":"<p>Copy files to and from the device using asyncssh.scp().</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>List[Path]</code> <p>List of files to copy to or from the device.</p> required <code>destination</code> <code>Path</code> <p>Local or remote destination when copying the files. Can be a folder.</p> required <code>direction</code> <code>Literal['to', 'from']</code> <p>Defines if this coroutine copies files to or from the device.</p> <code>'from'</code> Source code in <code>anta/device.py</code> <pre><code>async def copy(self, sources: List[Path], destination: Path, direction: Literal[\"to\", \"from\"] = \"from\") -&gt; None:\n\"\"\"\n    Copy files to and from the device using asyncssh.scp().\n\n    Args:\n        sources: List of files to copy to or from the device.\n        destination: Local or remote destination when copying the files. Can be a folder.\n        direction: Defines if this coroutine copies files to or from the device.\n    \"\"\"\n    async with asyncssh.connect(\n        host=self._ssh_opts.host,\n        port=self._ssh_opts.port,\n        tunnel=self._ssh_opts.tunnel,\n        family=self._ssh_opts.family,\n        local_addr=self._ssh_opts.local_addr,\n        options=self._ssh_opts,\n    ) as conn:\n        src: Union[List[Tuple[SSHClientConnection, Path]], List[Path]]\n        dst: Union[Tuple[SSHClientConnection, Path], Path]\n        if direction == \"from\":\n            src = [(conn, file) for file in sources]\n            dst = destination\n            for file in sources:\n                logger.info(f\"Copying '{file}' from device {self.name} to '{destination}' locally\")\n        elif direction == \"to\":\n            src = sources\n            dst = (conn, destination)\n            for file in sources:\n                logger.info(f\"Copying '{file}' to device {self.name} to '{destination}' remotely\")\n        else:\n            logger.critical(f\"'direction' argument to copy() fonction is invalid: {direction}\")\n            return\n        await asyncssh.scp(src, dst)\n</code></pre>"},{"location":"api/device/#anta.device.AsyncEOSDevice.refresh","title":"<code>refresh()</code>  <code>async</code>","text":"<p>Update attributes of an AsyncEOSDevice instance.</p> <p>This coroutine must update the following attributes of AsyncEOSDevice: - is_online: When a device IP is reachable and a port can be open - established: When a command execution succeeds - hw_model: The hardware model of the device</p> Source code in <code>anta/device.py</code> <pre><code>async def refresh(self) -&gt; None:\n\"\"\"\n    Update attributes of an AsyncEOSDevice instance.\n\n    This coroutine must update the following attributes of AsyncEOSDevice:\n    - is_online: When a device IP is reachable and a port can be open\n    - established: When a command execution succeeds\n    - hw_model: The hardware model of the device\n    \"\"\"\n    # Refresh command\n    COMMAND: str = \"show version\"\n    # Hardware model definition in show version\n    HW_MODEL_KEY: str = \"modelName\"\n    logger.debug(f\"Refreshing device {self.name}\")\n    self.is_online = await self._session.check_connection()\n    if self.is_online:\n        try:\n            response = await self._session.cli(command=COMMAND)\n        except EapiCommandError as e:\n            logger.warning(f\"Cannot get hardware information from device {self.name}: {e.errmsg}\")\n        except (HTTPError, ConnectError) as e:\n            logger.warning(f\"Cannot get hardware information from device {self.name}: {exc_to_str(e)}\")\n        else:\n            if HW_MODEL_KEY in response:\n                self.hw_model = response[HW_MODEL_KEY]\n            else:\n                logger.warning(f\"Cannot get hardware information from device {self.name}: cannot parse '{COMMAND}'\")\n    else:\n        logger.warning(f\"Could not connect to device {self.name}: cannot open eAPI port\")\n    self.established = bool(self.is_online and self.hw_model)\n</code></pre>"},{"location":"api/inventory/","title":"Inventory module","text":""},{"location":"api/inventory/#anta-inventory-module","title":"ANTA Inventory module","text":"<p>         Bases: <code>dict</code></p> <p>Inventory abstraction for ANTA framework.</p> Source code in <code>anta/inventory/__init__.py</code> <pre><code>class AntaInventory(dict):  # type: ignore\n    # dict[str, AntaDevice] - not working in python 3.8 hence the ignore\n\"\"\"\n    Inventory abstraction for ANTA framework.\n    \"\"\"\n\n    # Root key of inventory part of the inventory file\n    INVENTORY_ROOT_KEY = \"anta_inventory\"\n    # Supported Output format\n    INVENTORY_OUTPUT_FORMAT = [\"native\", \"json\"]\n\n    def __str__(self) -&gt; str:\n\"\"\"Human readable string representing the inventory\"\"\"\n        devs = {}\n        for dev in self.values():\n            if (dev_type := dev.__class__.__name__) not in devs:\n                devs[dev_type] = 1\n            else:\n                devs[dev_type] += 1\n        return f\"ANTA Inventory contains {' '.join([f'{n} devices ({t})' for t, n in devs.items()])}\"\n\n    @staticmethod\n    def _parse_hosts(inventory_input: AntaInventoryInput, inventory: AntaInventory, **kwargs: Any) -&gt; None:\n\"\"\"\n        Parses the host section of an AntaInventoryInput and add the devices to the inventory\n\n        Args:\n            inventory_input (AntaInventoryInput): AntaInventoryInput used to parse the devices\n            inventory (AntaInventory): AntaInventory to add the parsed devices to\n        \"\"\"\n        if inventory_input.hosts is None:\n            return\n\n        for host in inventory_input.hosts:\n            device = AsyncEOSDevice(name=host.name, host=str(host.host), port=host.port, tags=host.tags, **kwargs)\n            inventory.add_device(device)\n\n    @staticmethod\n    def _parse_networks(inventory_input: AntaInventoryInput, inventory: AntaInventory, **kwargs: Any) -&gt; None:\n\"\"\"\n        Parses the network section of an AntaInventoryInput and add the devices to the inventory.\n\n        Args:\n            inventory_input (AntaInventoryInput): AntaInventoryInput used to parse the devices\n            inventory (AntaInventory): AntaInventory to add the parsed devices to\n\n        Raises:\n            InventoryIncorrectSchema: Inventory file is not following AntaInventory Schema.\n        \"\"\"\n        if inventory_input.networks is None:\n            return\n\n        for network in inventory_input.networks:\n            try:\n                for host_ip in ip_network(str(network.network)):\n                    device = AsyncEOSDevice(host=str(host_ip), tags=network.tags, **kwargs)\n                    inventory.add_device(device)\n            except ValueError as e:\n                message = \"Could not parse network {network.network} in the inventory\"\n                anta_log_exception(e, message, logger)\n                raise InventoryIncorrectSchema(message) from e\n\n    @staticmethod\n    def _parse_ranges(inventory_input: AntaInventoryInput, inventory: AntaInventory, **kwargs: Any) -&gt; None:\n\"\"\"\n        Parses the range section of an AntaInventoryInput and add the devices to the inventory.\n\n        Args:\n            inventory_input (AntaInventoryInput): AntaInventoryInput used to parse the devices\n            inventory (AntaInventory): AntaInventory to add the parsed devices to\n\n        Raises:\n            InventoryIncorrectSchema: Inventory file is not following AntaInventory Schema.\n        \"\"\"\n        if inventory_input.ranges is None:\n            return\n\n        for range_def in inventory_input.ranges:\n            try:\n                range_increment = ip_address(str(range_def.start))\n                range_stop = ip_address(str(range_def.end))\n                while range_increment &lt;= range_stop:  # type: ignore[operator]\n                    # mypy raise an issue about comparing IPv4Address and IPv6Address\n                    # but this is handled by the ipaddress module natively by raising a TypeError\n                    device = AsyncEOSDevice(host=str(range_increment), tags=range_def.tags, **kwargs)\n                    inventory.add_device(device)\n                    range_increment += 1\n            except ValueError as e:\n                message = f\"Could not parse the following range in the inventory: {range_def.start} - {range_def.end}\"\n                anta_log_exception(e, message, logger)\n                raise InventoryIncorrectSchema(message) from e\n            except TypeError as e:\n                message = f\"A range in the inventory has different address families for start and end: {range_def.start} - {range_def.end}\"\n                anta_log_exception(e, message, logger)\n                raise InventoryIncorrectSchema(message) from e\n\n    @staticmethod\n    def parse(\n        inventory_file: str, username: str, password: str, enable_password: Optional[str] = None, timeout: Optional[float] = None, insecure: bool = False\n    ) -&gt; AntaInventory:\n        # pylint: disable=too-many-arguments\n\"\"\"\n        Create an AntaInventory object from an inventory file.\n        Instantiate AntaDevice objects using the AsyncEOSDevice subclass.\n\n        Args:\n            inventory_file (str): Path to inventory YAML file where user has described his inputs\n            username (str): Username to use to connect to devices\n            password (str): Password to use to connect to devices\n            timeout (float, optional): timeout in seconds for every API call.\n\n        Raises:\n            InventoryRootKeyError: Root key of inventory is missing.\n            InventoryIncorrectSchema: Inventory file is not following AntaInventory Schema.\n            InventoryUnknownFormat: Output format is not supported.\n        \"\"\"\n\n        inventory = AntaInventory()\n        kwargs: Dict[str, Any] = {\"username\": username, \"password\": password, \"enable_password\": enable_password, \"timeout\": timeout, \"insecure\": insecure}\n        kwargs = {k: v for k, v in kwargs.items() if v is not None}\n\n        with open(inventory_file, \"r\", encoding=\"UTF-8\") as file:\n            data = safe_load(file)\n\n        # Load data using Pydantic\n        try:\n            inventory_input = AntaInventoryInput(**data[AntaInventory.INVENTORY_ROOT_KEY])\n        except KeyError as exc:\n            logger.error(f\"Inventory root key is missing: {AntaInventory.INVENTORY_ROOT_KEY}\")\n            raise InventoryRootKeyError(f\"Inventory root key ({AntaInventory.INVENTORY_ROOT_KEY}) is not defined in your inventory\") from exc\n        except ValidationError as exc:\n            logger.error(\"Inventory data are not compliant with inventory models\")\n            raise InventoryIncorrectSchema(f\"Inventory is not following the schema: {str(exc)}\") from exc\n\n        # Read data from input\n        AntaInventory._parse_hosts(inventory_input, inventory, **kwargs)\n        AntaInventory._parse_networks(inventory_input, inventory, **kwargs)\n        AntaInventory._parse_ranges(inventory_input, inventory, **kwargs)\n\n        return inventory\n\n    ###########################################################################\n    # Public methods\n    ###########################################################################\n\n    ###########################################################################\n    # GET methods\n    ###########################################################################\n\n    def get_inventory(self, established_only: bool = False, tags: Optional[List[str]] = None) -&gt; AntaInventory:\n\"\"\"\n        Returns a filtered inventory.\n\n        Args:\n            established_only: Whether or not to include only established devices. Default False.\n            tags: List of tags to filter devices.\n\n        Returns:\n            AntaInventory: An inventory with filtered AntaDevice objects.\n        \"\"\"\n\n        def _filter_devices(device: AntaDevice) -&gt; bool:\n\"\"\"\n            Helper function to select the devices based on the input tags\n            and the requirement for an established connection.\n            \"\"\"\n            if tags is not None and all(tag not in tags for tag in device.tags):\n                return False\n            return bool(not established_only or device.established)\n\n        devices: List[AntaDevice] = list(filter(_filter_devices, self.values()))\n        result = AntaInventory()\n        for device in devices:\n            result.add_device(device)\n        return result\n\n    ###########################################################################\n    # SET methods\n    ###########################################################################\n\n    def __setitem__(self, key: str, value: AntaDevice) -&gt; None:\n        if key != value.name:\n            raise RuntimeError(f\"The key must be the device name for device '{value.name}'. Use AntaInventory.add_device().\")\n        return super().__setitem__(key, value)\n\n    def add_device(self, device: AntaDevice) -&gt; None:\n\"\"\"Add a device to final inventory.\n\n        Args:\n            device: Device object to be added\n        \"\"\"\n        self[device.name] = device\n\n    ###########################################################################\n    # MISC methods\n    ###########################################################################\n\n    async def connect_inventory(self) -&gt; None:\n\"\"\"Run `refresh()` coroutines for all AntaDevice objects in this inventory.\"\"\"\n        logger.debug(\"Refreshing devices...\")\n        results = await asyncio.gather(\n            *(device.refresh() for device in self.values()),\n            return_exceptions=True,\n        )\n        for r in results:\n            if isinstance(r, Exception):\n                message = \"Error when refreshing inventory\"\n                anta_log_exception(r, message, logger)\n</code></pre>"},{"location":"api/inventory/#anta.inventory.AntaInventory.__str__","title":"<code>__str__()</code>","text":"<p>Human readable string representing the inventory</p> Source code in <code>anta/inventory/__init__.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Human readable string representing the inventory\"\"\"\n    devs = {}\n    for dev in self.values():\n        if (dev_type := dev.__class__.__name__) not in devs:\n            devs[dev_type] = 1\n        else:\n            devs[dev_type] += 1\n    return f\"ANTA Inventory contains {' '.join([f'{n} devices ({t})' for t, n in devs.items()])}\"\n</code></pre>"},{"location":"api/inventory/#anta.inventory.AntaInventory.add_device","title":"<code>add_device(device)</code>","text":"<p>Add a device to final inventory.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>AntaDevice</code> <p>Device object to be added</p> required Source code in <code>anta/inventory/__init__.py</code> <pre><code>def add_device(self, device: AntaDevice) -&gt; None:\n\"\"\"Add a device to final inventory.\n\n    Args:\n        device: Device object to be added\n    \"\"\"\n    self[device.name] = device\n</code></pre>"},{"location":"api/inventory/#anta.inventory.AntaInventory.connect_inventory","title":"<code>connect_inventory()</code>  <code>async</code>","text":"<p>Run <code>refresh()</code> coroutines for all AntaDevice objects in this inventory.</p> Source code in <code>anta/inventory/__init__.py</code> <pre><code>async def connect_inventory(self) -&gt; None:\n\"\"\"Run `refresh()` coroutines for all AntaDevice objects in this inventory.\"\"\"\n    logger.debug(\"Refreshing devices...\")\n    results = await asyncio.gather(\n        *(device.refresh() for device in self.values()),\n        return_exceptions=True,\n    )\n    for r in results:\n        if isinstance(r, Exception):\n            message = \"Error when refreshing inventory\"\n            anta_log_exception(r, message, logger)\n</code></pre>"},{"location":"api/inventory/#anta.inventory.AntaInventory.get_inventory","title":"<code>get_inventory(established_only=False, tags=None)</code>","text":"<p>Returns a filtered inventory.</p> <p>Parameters:</p> Name Type Description Default <code>established_only</code> <code>bool</code> <p>Whether or not to include only established devices. Default False.</p> <code>False</code> <code>tags</code> <code>Optional[List[str]]</code> <p>List of tags to filter devices.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>AntaInventory</code> <code>AntaInventory</code> <p>An inventory with filtered AntaDevice objects.</p> Source code in <code>anta/inventory/__init__.py</code> <pre><code>def get_inventory(self, established_only: bool = False, tags: Optional[List[str]] = None) -&gt; AntaInventory:\n\"\"\"\n    Returns a filtered inventory.\n\n    Args:\n        established_only: Whether or not to include only established devices. Default False.\n        tags: List of tags to filter devices.\n\n    Returns:\n        AntaInventory: An inventory with filtered AntaDevice objects.\n    \"\"\"\n\n    def _filter_devices(device: AntaDevice) -&gt; bool:\n\"\"\"\n        Helper function to select the devices based on the input tags\n        and the requirement for an established connection.\n        \"\"\"\n        if tags is not None and all(tag not in tags for tag in device.tags):\n            return False\n        return bool(not established_only or device.established)\n\n    devices: List[AntaDevice] = list(filter(_filter_devices, self.values()))\n    result = AntaInventory()\n    for device in devices:\n        result.add_device(device)\n    return result\n</code></pre>"},{"location":"api/inventory/#anta.inventory.AntaInventory.parse","title":"<code>parse(inventory_file, username, password, enable_password=None, timeout=None, insecure=False)</code>  <code>staticmethod</code>","text":"<p>Create an AntaInventory object from an inventory file. Instantiate AntaDevice objects using the AsyncEOSDevice subclass.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_file</code> <code>str</code> <p>Path to inventory YAML file where user has described his inputs</p> required <code>username</code> <code>str</code> <p>Username to use to connect to devices</p> required <code>password</code> <code>str</code> <p>Password to use to connect to devices</p> required <code>timeout</code> <code>float</code> <p>timeout in seconds for every API call.</p> <code>None</code> <p>Raises:</p> Type Description <code>InventoryRootKeyError</code> <p>Root key of inventory is missing.</p> <code>InventoryIncorrectSchema</code> <p>Inventory file is not following AntaInventory Schema.</p> <code>InventoryUnknownFormat</code> <p>Output format is not supported.</p> Source code in <code>anta/inventory/__init__.py</code> <pre><code>@staticmethod\ndef parse(\n    inventory_file: str, username: str, password: str, enable_password: Optional[str] = None, timeout: Optional[float] = None, insecure: bool = False\n) -&gt; AntaInventory:\n    # pylint: disable=too-many-arguments\n\"\"\"\n    Create an AntaInventory object from an inventory file.\n    Instantiate AntaDevice objects using the AsyncEOSDevice subclass.\n\n    Args:\n        inventory_file (str): Path to inventory YAML file where user has described his inputs\n        username (str): Username to use to connect to devices\n        password (str): Password to use to connect to devices\n        timeout (float, optional): timeout in seconds for every API call.\n\n    Raises:\n        InventoryRootKeyError: Root key of inventory is missing.\n        InventoryIncorrectSchema: Inventory file is not following AntaInventory Schema.\n        InventoryUnknownFormat: Output format is not supported.\n    \"\"\"\n\n    inventory = AntaInventory()\n    kwargs: Dict[str, Any] = {\"username\": username, \"password\": password, \"enable_password\": enable_password, \"timeout\": timeout, \"insecure\": insecure}\n    kwargs = {k: v for k, v in kwargs.items() if v is not None}\n\n    with open(inventory_file, \"r\", encoding=\"UTF-8\") as file:\n        data = safe_load(file)\n\n    # Load data using Pydantic\n    try:\n        inventory_input = AntaInventoryInput(**data[AntaInventory.INVENTORY_ROOT_KEY])\n    except KeyError as exc:\n        logger.error(f\"Inventory root key is missing: {AntaInventory.INVENTORY_ROOT_KEY}\")\n        raise InventoryRootKeyError(f\"Inventory root key ({AntaInventory.INVENTORY_ROOT_KEY}) is not defined in your inventory\") from exc\n    except ValidationError as exc:\n        logger.error(\"Inventory data are not compliant with inventory models\")\n        raise InventoryIncorrectSchema(f\"Inventory is not following the schema: {str(exc)}\") from exc\n\n    # Read data from input\n    AntaInventory._parse_hosts(inventory_input, inventory, **kwargs)\n    AntaInventory._parse_networks(inventory_input, inventory, **kwargs)\n    AntaInventory._parse_ranges(inventory_input, inventory, **kwargs)\n\n    return inventory\n</code></pre>"},{"location":"api/inventory/#exceptions","title":"Exceptions","text":"<p>Manage Exception in Inventory module.</p>"},{"location":"api/inventory/#anta.inventory.exceptions.InventoryIncorrectSchema","title":"<code>InventoryIncorrectSchema</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Error when user data does not follow ANTA schema.</p> Source code in <code>anta/inventory/exceptions.py</code> <pre><code>class InventoryIncorrectSchema(Exception):\n\"\"\"Error when user data does not follow ANTA schema.\"\"\"\n</code></pre>"},{"location":"api/inventory/#anta.inventory.exceptions.InventoryRootKeyError","title":"<code>InventoryRootKeyError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Error raised when inventory root key is not found.</p> Source code in <code>anta/inventory/exceptions.py</code> <pre><code>class InventoryRootKeyError(Exception):\n\"\"\"Error raised when inventory root key is not found.\"\"\"\n</code></pre>"},{"location":"api/inventory.models.input/","title":"Inventory models","text":""},{"location":"api/inventory.models.input/#data-models-for-antainventory","title":"Data models for anta.inventory","text":"<p>         Bases: <code>BaseModel</code></p> <p>User\u2019s inventory model.</p> <p>Attributes:</p> Name Type Description <code>networks</code> <code>List[AntaInventoryNetwork], Optional</code> <p>List of AntaInventoryNetwork objects for networks.</p> <code>hosts</code> <code>List[AntaInventoryHost], Optional</code> <p>List of AntaInventoryHost objects for hosts.</p> <code>range</code> <code>List[AntaInventoryRange], Optional</code> <p>List of AntaInventoryRange objects for ranges.</p> Source code in <code>anta/inventory/models.py</code> <pre><code>class AntaInventoryInput(BaseModel):\n\"\"\"\n    User's inventory model.\n\n    Attributes:\n        networks (List[AntaInventoryNetwork],Optional): List of AntaInventoryNetwork objects for networks.\n        hosts (List[AntaInventoryHost],Optional): List of AntaInventoryHost objects for hosts.\n        range (List[AntaInventoryRange],Optional): List of AntaInventoryRange objects for ranges.\n    \"\"\"\n\n    networks: Optional[List[AntaInventoryNetwork]] = None\n    hosts: Optional[List[AntaInventoryHost]] = None\n    ranges: Optional[List[AntaInventoryRange]] = None\n</code></pre>"},{"location":"api/inventory.models.input/#user-inventory-components","title":"User inventory components","text":"<p>         Bases: <code>BaseModel</code></p> <p>Host definition for user\u2019s inventory.</p> <p>Attributes:</p> Name Type Description <code>host</code> <code>IPvAnyAddress</code> <p>IPv4 or IPv6 address of the device</p> <code>port</code> <code>int</code> <p>(Optional) eAPI port to use Default is 443.</p> <code>name</code> <code>str</code> <p>(Optional) Name to display during tests report. Default is hostname:port</p> <code>tags</code> <code>List[str]</code> <p>List of attached tags read from inventory file.</p> Source code in <code>anta/inventory/models.py</code> <pre><code>class AntaInventoryHost(BaseModel):\n\"\"\"\n    Host definition for user's inventory.\n\n    Attributes:\n        host (IPvAnyAddress): IPv4 or IPv6 address of the device\n        port (int): (Optional) eAPI port to use Default is 443.\n        name (str): (Optional) Name to display during tests report. Default is hostname:port\n        tags (List[str]): List of attached tags read from inventory file.\n    \"\"\"\n\n    name: Optional[str] = None\n    host: Union[constr(pattern=RFC_1123_REGEX), IPvAnyAddress]  # type: ignore\n    port: Optional[conint(gt=1, lt=65535)] = None  # type: ignore\n    tags: Optional[List[str]] = None\n</code></pre> <p>         Bases: <code>BaseModel</code></p> <p>Network definition for user\u2019s inventory.</p> <p>Attributes:</p> Name Type Description <code>network</code> <code>IPvAnyNetwork</code> <p>Subnet to use for testing.</p> <code>tags</code> <code>List[str]</code> <p>List of attached tags read from inventory file.</p> Source code in <code>anta/inventory/models.py</code> <pre><code>class AntaInventoryNetwork(BaseModel):\n\"\"\"\n    Network definition for user's inventory.\n\n    Attributes:\n        network (IPvAnyNetwork): Subnet to use for testing.\n        tags (List[str]): List of attached tags read from inventory file.\n    \"\"\"\n\n    network: IPvAnyNetwork\n    tags: Optional[List[str]] = None\n</code></pre> <p>         Bases: <code>BaseModel</code></p> <p>IP Range definition for user\u2019s inventory.</p> <p>Attributes:</p> Name Type Description <code>start</code> <code>IPvAnyAddress</code> <p>IPv4 or IPv6 address for the begining of the range.</p> <code>stop</code> <code>IPvAnyAddress</code> <p>IPv4 or IPv6 address for the end of the range.</p> <code>tags</code> <code>List[str]</code> <p>List of attached tags read from inventory file.</p> Source code in <code>anta/inventory/models.py</code> <pre><code>class AntaInventoryRange(BaseModel):\n\"\"\"\n    IP Range definition for user's inventory.\n\n    Attributes:\n        start (IPvAnyAddress): IPv4 or IPv6 address for the begining of the range.\n        stop (IPvAnyAddress): IPv4 or IPv6 address for the end of the range.\n        tags (List[str]): List of attached tags read from inventory file.\n    \"\"\"\n\n    start: IPvAnyAddress\n    end: IPvAnyAddress\n    tags: Optional[List[str]] = None\n</code></pre>"},{"location":"api/models/","title":"Test models","text":""},{"location":"api/models/#antatest-definition","title":"AntaTest definition","text":"<p>         Bases: <code>ABC</code></p> <p>Abstract class defining a test for Anta</p> <p>The goal of this class is to handle the heavy lifting and make writing a test as simple as possible.</p> <p>TODO - complete doctstring with example</p> Source code in <code>anta/models.py</code> <pre><code>class AntaTest(ABC):\n\"\"\"Abstract class defining a test for Anta\n\n    The goal of this class is to handle the heavy lifting and make\n    writing a test as simple as possible.\n\n    TODO - complete doctstring with example\n    \"\"\"\n\n    # Mandatory class attributes\n    # TODO - find a way to tell mypy these are mandatory for child classes - maybe Protocol\n    name: ClassVar[str]\n    description: ClassVar[str]\n    categories: ClassVar[list[str]]\n    # Or any child type\n    commands: ClassVar[list[AntaCommand]]\n    # TODO - today we support only one template per Test\n    template: ClassVar[AntaTemplate]\n    progress: Optional[Progress] = None\n    nrfu_task: Optional[TaskID] = None\n\n    # Optional class attributes\n    test_filters: ClassVar[list[AntaTestFilter]]\n\n    def __init__(\n        self,\n        device: AntaDevice,\n        template_params: list[dict[str, Any]] | None = None,\n        # TODO document very well the order of eos_data\n        eos_data: list[dict[Any, Any] | str] | None = None,\n        labels: list[str] | None = None,\n    ):\n\"\"\"Class constructor\"\"\"\n        # Accept 6 input arguments\n        # pylint: disable=R0913\n        self.logger: logging.Logger = logging.getLogger(f\"{self.__module__}.{self.__class__.__name__}\")\n        self.device: AntaDevice = device\n        self.result: TestResult = TestResult(name=device.name, test=self.name, test_category=self.categories, test_description=self.description)\n        self.labels: List[str] = labels or []\n        self.instance_commands: List[AntaCommand] = []\n\n        # TODO - check optimization for deepcopy\n        # Generating instance_commands from list of commands and template\n        if hasattr(self.__class__, \"commands\") and (cmds := self.__class__.commands) is not None:\n            self.instance_commands.extend(deepcopy(cmds))\n        if hasattr(self.__class__, \"template\") and (tpl := self.__class__.template) is not None:\n            if template_params is None:\n                self.result.is_error(\"Command has template but no params were given\")\n                return\n            self.template_params = template_params\n            for param in template_params:\n                try:\n                    self.instance_commands.append(tpl.render(param))\n                except KeyError:\n                    self.result.is_error(f\"Cannot render template '{tpl.template}': wrong parameters\")\n                    return\n\n        if eos_data is not None:\n            self.logger.debug(\"Test initialized with input data\")\n            self.save_commands_data(eos_data)\n\n    def save_commands_data(self, eos_data: list[dict[Any, Any] | str]) -&gt; None:\n\"\"\"Called at init or at test execution time\"\"\"\n        if len(eos_data) != len(self.instance_commands):\n            self.result.is_error(\"Test initialization error: Trying to save more data than there are commands for the test\")\n            return\n        for index, data in enumerate(eos_data or []):\n            self.instance_commands[index].output = data\n\n    def all_data_collected(self) -&gt; bool:\n\"\"\"returns True if output is populated for every command\"\"\"\n        return all(command.collected for command in self.instance_commands)\n\n    def get_failed_commands(self) -&gt; List[AntaCommand]:\n\"\"\"returns a list of all the commands that have a populated failed field\"\"\"\n        return [command for command in self.instance_commands if command.failed is not None]\n\n    def __init_subclass__(cls) -&gt; None:\n\"\"\"\n        Verify that the mandatory class attributes are defined\n        \"\"\"\n        mandatory_attributes = [\"name\", \"description\", \"categories\"]\n        for attr in mandatory_attributes:\n            if not hasattr(cls, attr):\n                raise NotImplementedError(f\"Class {cls} is missing required class attribute {attr}\")\n        # Check that either commands or template exist\n        if not (hasattr(cls, \"commands\") or hasattr(cls, \"template\")):\n            raise NotImplementedError(f\"Class {cls} is missing required either commands or template attribute\")\n\n    async def collect(self) -&gt; None:\n\"\"\"\n        Method used to collect outputs of all commands of this test class from the device of this test instance.\n        \"\"\"\n        try:\n            await self.device.collect_commands(self.instance_commands)\n        except Exception as e:  # pylint: disable=broad-exception-caught\n            message = f\"Exception raised while collecting commands for test {self.name} (on device {self.device.name})\"\n            anta_log_exception(e, message, self.logger)\n            self.result.is_error(exc_to_str(e))\n\n    @staticmethod\n    def anta_test(function: F) -&gt; Callable[..., Coroutine[Any, Any, TestResult]]:\n\"\"\"\n        Decorator for anta_test that handles injecting test data if given and collecting it using asyncio if missing\n        \"\"\"\n\n        @wraps(function)\n        async def wrapper(\n            self: AntaTest,\n            eos_data: list[dict[Any, Any] | str] | None = None,\n            **kwargs: Any,\n        ) -&gt; TestResult:\n\"\"\"\n            Wraps the test function and implement (in this order):\n            1. Instantiate the command outputs if `eos_data` is provided\n            2. Collect missing command outputs from the device\n            3. Run the test function\n            4. Catches and set the result if the test function raises an exception\n\n            Returns:\n                TestResult: self.result, populated with the correct exit status\n            \"\"\"\n            if self.result.result != \"unset\":\n                return self.result\n\n            # TODO maybe_skip decorators\n\n            # Data\n            if eos_data is not None:\n                self.save_commands_data(eos_data)\n                self.logger.debug(f\"Test {self.name} initialized with input data {eos_data}\")\n\n            # If some data is missing, try to collect\n            if not self.all_data_collected():\n                await self.collect()\n                if self.result.result != \"unset\":\n                    return self.result\n\n            try:\n                if cmds := self.get_failed_commands():\n                    self.result.is_error(\n                        \"\\n\".join([f\"{cmd.command} has failed: {exc_to_str(cmd.failed)}\" if cmd.failed else f\"{cmd.command} has failed\" for cmd in cmds])\n                    )\n                    return self.result\n                function(self, **kwargs)\n            except Exception as e:  # pylint: disable=broad-exception-caught\n                message = f\"Exception raised for test {self.name} (on device {self.device.name})\"\n                anta_log_exception(e, message, self.logger)\n                self.result.is_error(exc_to_str(e))\n\n            AntaTest.update_progress()\n            return self.result\n\n        return wrapper\n\n    @classmethod\n    def update_progress(cls) -&gt; None:\n\"\"\"\n        Update progress bar for all AntaTest objects if it exists\n        \"\"\"\n        if cls.progress and (cls.nrfu_task is not None):\n            cls.progress.update(cls.nrfu_task, advance=1)\n\n    @abstractmethod\n    def test(self) -&gt; Coroutine[Any, Any, TestResult]:\n\"\"\"\n        This abstract method is the core of the test.\n        It MUST set the correct status of self.result with the appropriate error messages\n\n        it must be implemented as follow\n\n        @AntaTest.anta_test\n        def test(self) -&gt; None:\n           '''\n           assert code\n           '''\n        \"\"\"\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.__init__","title":"<code>__init__(device, template_params=None, eos_data=None, labels=None)</code>","text":"<p>Class constructor</p> Source code in <code>anta/models.py</code> <pre><code>def __init__(\n    self,\n    device: AntaDevice,\n    template_params: list[dict[str, Any]] | None = None,\n    # TODO document very well the order of eos_data\n    eos_data: list[dict[Any, Any] | str] | None = None,\n    labels: list[str] | None = None,\n):\n\"\"\"Class constructor\"\"\"\n    # Accept 6 input arguments\n    # pylint: disable=R0913\n    self.logger: logging.Logger = logging.getLogger(f\"{self.__module__}.{self.__class__.__name__}\")\n    self.device: AntaDevice = device\n    self.result: TestResult = TestResult(name=device.name, test=self.name, test_category=self.categories, test_description=self.description)\n    self.labels: List[str] = labels or []\n    self.instance_commands: List[AntaCommand] = []\n\n    # TODO - check optimization for deepcopy\n    # Generating instance_commands from list of commands and template\n    if hasattr(self.__class__, \"commands\") and (cmds := self.__class__.commands) is not None:\n        self.instance_commands.extend(deepcopy(cmds))\n    if hasattr(self.__class__, \"template\") and (tpl := self.__class__.template) is not None:\n        if template_params is None:\n            self.result.is_error(\"Command has template but no params were given\")\n            return\n        self.template_params = template_params\n        for param in template_params:\n            try:\n                self.instance_commands.append(tpl.render(param))\n            except KeyError:\n                self.result.is_error(f\"Cannot render template '{tpl.template}': wrong parameters\")\n                return\n\n    if eos_data is not None:\n        self.logger.debug(\"Test initialized with input data\")\n        self.save_commands_data(eos_data)\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.__init_subclass__","title":"<code>__init_subclass__()</code>","text":"<p>Verify that the mandatory class attributes are defined</p> Source code in <code>anta/models.py</code> <pre><code>def __init_subclass__(cls) -&gt; None:\n\"\"\"\n    Verify that the mandatory class attributes are defined\n    \"\"\"\n    mandatory_attributes = [\"name\", \"description\", \"categories\"]\n    for attr in mandatory_attributes:\n        if not hasattr(cls, attr):\n            raise NotImplementedError(f\"Class {cls} is missing required class attribute {attr}\")\n    # Check that either commands or template exist\n    if not (hasattr(cls, \"commands\") or hasattr(cls, \"template\")):\n        raise NotImplementedError(f\"Class {cls} is missing required either commands or template attribute\")\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.all_data_collected","title":"<code>all_data_collected()</code>","text":"<p>returns True if output is populated for every command</p> Source code in <code>anta/models.py</code> <pre><code>def all_data_collected(self) -&gt; bool:\n\"\"\"returns True if output is populated for every command\"\"\"\n    return all(command.collected for command in self.instance_commands)\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.anta_test","title":"<code>anta_test(function)</code>  <code>staticmethod</code>","text":"<p>Decorator for anta_test that handles injecting test data if given and collecting it using asyncio if missing</p> Source code in <code>anta/models.py</code> <pre><code>@staticmethod\ndef anta_test(function: F) -&gt; Callable[..., Coroutine[Any, Any, TestResult]]:\n\"\"\"\n    Decorator for anta_test that handles injecting test data if given and collecting it using asyncio if missing\n    \"\"\"\n\n    @wraps(function)\n    async def wrapper(\n        self: AntaTest,\n        eos_data: list[dict[Any, Any] | str] | None = None,\n        **kwargs: Any,\n    ) -&gt; TestResult:\n\"\"\"\n        Wraps the test function and implement (in this order):\n        1. Instantiate the command outputs if `eos_data` is provided\n        2. Collect missing command outputs from the device\n        3. Run the test function\n        4. Catches and set the result if the test function raises an exception\n\n        Returns:\n            TestResult: self.result, populated with the correct exit status\n        \"\"\"\n        if self.result.result != \"unset\":\n            return self.result\n\n        # TODO maybe_skip decorators\n\n        # Data\n        if eos_data is not None:\n            self.save_commands_data(eos_data)\n            self.logger.debug(f\"Test {self.name} initialized with input data {eos_data}\")\n\n        # If some data is missing, try to collect\n        if not self.all_data_collected():\n            await self.collect()\n            if self.result.result != \"unset\":\n                return self.result\n\n        try:\n            if cmds := self.get_failed_commands():\n                self.result.is_error(\n                    \"\\n\".join([f\"{cmd.command} has failed: {exc_to_str(cmd.failed)}\" if cmd.failed else f\"{cmd.command} has failed\" for cmd in cmds])\n                )\n                return self.result\n            function(self, **kwargs)\n        except Exception as e:  # pylint: disable=broad-exception-caught\n            message = f\"Exception raised for test {self.name} (on device {self.device.name})\"\n            anta_log_exception(e, message, self.logger)\n            self.result.is_error(exc_to_str(e))\n\n        AntaTest.update_progress()\n        return self.result\n\n    return wrapper\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.collect","title":"<code>collect()</code>  <code>async</code>","text":"<p>Method used to collect outputs of all commands of this test class from the device of this test instance.</p> Source code in <code>anta/models.py</code> <pre><code>async def collect(self) -&gt; None:\n\"\"\"\n    Method used to collect outputs of all commands of this test class from the device of this test instance.\n    \"\"\"\n    try:\n        await self.device.collect_commands(self.instance_commands)\n    except Exception as e:  # pylint: disable=broad-exception-caught\n        message = f\"Exception raised while collecting commands for test {self.name} (on device {self.device.name})\"\n        anta_log_exception(e, message, self.logger)\n        self.result.is_error(exc_to_str(e))\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.get_failed_commands","title":"<code>get_failed_commands()</code>","text":"<p>returns a list of all the commands that have a populated failed field</p> Source code in <code>anta/models.py</code> <pre><code>def get_failed_commands(self) -&gt; List[AntaCommand]:\n\"\"\"returns a list of all the commands that have a populated failed field\"\"\"\n    return [command for command in self.instance_commands if command.failed is not None]\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.save_commands_data","title":"<code>save_commands_data(eos_data)</code>","text":"<p>Called at init or at test execution time</p> Source code in <code>anta/models.py</code> <pre><code>def save_commands_data(self, eos_data: list[dict[Any, Any] | str]) -&gt; None:\n\"\"\"Called at init or at test execution time\"\"\"\n    if len(eos_data) != len(self.instance_commands):\n        self.result.is_error(\"Test initialization error: Trying to save more data than there are commands for the test\")\n        return\n    for index, data in enumerate(eos_data or []):\n        self.instance_commands[index].output = data\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.test","title":"<code>test()</code>  <code>abstractmethod</code>","text":"<p>This abstract method is the core of the test. It MUST set the correct status of self.result with the appropriate error messages</p> <p>it must be implemented as follow</p> <p>@AntaTest.anta_test def test(self) -&gt; None:    \u2018\u2019\u2018    assert code    \u2018\u2019\u2018</p> Source code in <code>anta/models.py</code> <pre><code>@abstractmethod\ndef test(self) -&gt; Coroutine[Any, Any, TestResult]:\n\"\"\"\n    This abstract method is the core of the test.\n    It MUST set the correct status of self.result with the appropriate error messages\n\n    it must be implemented as follow\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n       '''\n       assert code\n       '''\n    \"\"\"\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.update_progress","title":"<code>update_progress()</code>  <code>classmethod</code>","text":"<p>Update progress bar for all AntaTest objects if it exists</p> Source code in <code>anta/models.py</code> <pre><code>@classmethod\ndef update_progress(cls) -&gt; None:\n\"\"\"\n    Update progress bar for all AntaTest objects if it exists\n    \"\"\"\n    if cls.progress and (cls.nrfu_task is not None):\n        cls.progress.update(cls.nrfu_task, advance=1)\n</code></pre>"},{"location":"api/models/#antacommand-definition","title":"AntaCommand definition","text":"<p>         Bases: <code>BaseModel</code></p> <p>Class to define a test command with its API version</p> <p>Attributes:</p> Name Type Description <code>command</code> <code>str</code> <p>Device command</p> <code>version</code> <code>Literal[1, 'latest']</code> <p>eAPI version - valid values are 1 or \u201clatest\u201d - default is \u201clatest\u201d</p> <code>revision</code> <code>Optional[conint(ge=1, le=99)]</code> <p>Revision of the command. Valid values are 1 to 99. Revision has precedence over version.</p> <code>ofmt</code> <code>Literal['json', 'text']</code> <p>eAPI output - json or text - default is json</p> <code>template</code> <code>Optional[AntaTemplate]</code> <p>AntaTemplate object used to render this command</p> <code>params</code> <code>Optional[Dict[str, Any]]</code> <p>dictionary of variables with string values to render the template</p> <code>failed</code> <code>Optional[Exception]</code> <p>If the command execution fails, the Exception object is stored in this field</p> Source code in <code>anta/models.py</code> <pre><code>class AntaCommand(BaseModel):\n\"\"\"Class to define a test command with its API version\n\n    Attributes:\n        command: Device command\n        version: eAPI version - valid values are 1 or \"latest\" - default is \"latest\"\n        revision: Revision of the command. Valid values are 1 to 99. Revision has precedence over version.\n        ofmt: eAPI output - json or text - default is json\n        template: AntaTemplate object used to render this command\n        params: dictionary of variables with string values to render the template\n        failed: If the command execution fails, the Exception object is stored in this field\n    \"\"\"\n\n    # This is required if we want to keep an Exception object in the failed field\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    command: str\n    version: Literal[1, \"latest\"] = \"latest\"\n    revision: Optional[conint(ge=1, le=99)] = None  # type: ignore\n    ofmt: Literal[\"json\", \"text\"] = \"json\"\n    output: Optional[Union[Dict[str, Any], str]] = None\n    template: Optional[AntaTemplate] = None\n    failed: Optional[Exception] = None\n    params: Optional[Dict[str, Any]] = None\n\n    @property\n    def json_output(self) -&gt; Dict[str, Any]:\n\"\"\"Get the command output as JSON\"\"\"\n        if self.output is None:\n            raise RuntimeError(f\"There is no output for command {self.command}\")\n        if self.ofmt != \"json\" or not isinstance(self.output, dict):\n            raise RuntimeError(f\"Output of command {self.command} is invalid\")\n        return dict(self.output)\n\n    @property\n    def text_output(self) -&gt; str:\n\"\"\"Get the command output as a string\"\"\"\n        if self.output is None:\n            raise RuntimeError(f\"There is no output for command {self.command}\")\n        if self.ofmt != \"text\" or not isinstance(self.output, str):\n            raise RuntimeError(f\"Output of command {self.command} is invalid\")\n        return str(self.output)\n\n    @property\n    def collected(self) -&gt; bool:\n\"\"\"Return True if the command has been collected\"\"\"\n        return self.output is not None and self.failed is None\n</code></pre>"},{"location":"api/models/#anta.models.AntaCommand.collected","title":"<code>collected: bool</code>  <code>property</code>","text":"<p>Return True if the command has been collected</p>"},{"location":"api/models/#anta.models.AntaCommand.json_output","title":"<code>json_output: Dict[str, Any]</code>  <code>property</code>","text":"<p>Get the command output as JSON</p>"},{"location":"api/models/#anta.models.AntaCommand.text_output","title":"<code>text_output: str</code>  <code>property</code>","text":"<p>Get the command output as a string</p>"},{"location":"api/models/#antatemplate-definition","title":"AntaTemplate definition","text":"<p>         Bases: <code>BaseModel</code></p> <p>Class to define a test command with its API version</p> <p>Attributes:</p> Name Type Description <code>template</code> <code>str</code> <p>Python f-string. Example: \u2018show vlan {vlan_id}\u2019</p> <code>version</code> <code>Literal[1, 'latest']</code> <p>eAPI version - valid values are 1 or \u201clatest\u201d - default is \u201clatest\u201d</p> <code>revision</code> <code>Optional[conint(ge=1, le=99)]</code> <p>Revision of the command. Valid values are 1 to 99. Revision has precedence over version.</p> <code>ofmt</code> <code>Literal['json', 'text']</code> <p>eAPI output - json or text - default is json</p> Source code in <code>anta/models.py</code> <pre><code>class AntaTemplate(BaseModel):\n\"\"\"Class to define a test command with its API version\n\n    Attributes:\n        template: Python f-string. Example: 'show vlan {vlan_id}'\n        version: eAPI version - valid values are 1 or \"latest\" - default is \"latest\"\n        revision: Revision of the command. Valid values are 1 to 99. Revision has precedence over version.\n        ofmt: eAPI output - json or text - default is json\n    \"\"\"\n\n    template: str\n    version: Literal[1, \"latest\"] = \"latest\"\n    revision: Optional[conint(ge=1, le=99)] = None  # type: ignore\n    ofmt: Literal[\"json\", \"text\"] = \"json\"\n\n    def render(self, params: Dict[str, Any]) -&gt; AntaCommand:\n\"\"\"Render an AntaCommand from an AntaTemplate instance.\n        Keep the parameters used in the AntaTemplate instance.\n\n         Args:\n             params: dictionary of variables with string values to render the Python f-string\n\n         Returns:\n             AntaCommand: The rendered AntaCommand.\n                          This AntaCommand instance have a template attribute that references this\n                          AntaTemplate instance.\n        \"\"\"\n        return AntaCommand(command=self.template.format(**params), ofmt=self.ofmt, version=self.version, revision=self.revision, template=self, params=params)\n</code></pre>"},{"location":"api/models/#anta.models.AntaTemplate.render","title":"<code>render(params)</code>","text":"<p>Render an AntaCommand from an AntaTemplate instance. Keep the parameters used in the AntaTemplate instance.</p> <p>Args:      params: dictionary of variables with string values to render the Python f-string</p> <p>Returns:      AntaCommand: The rendered AntaCommand.                   This AntaCommand instance have a template attribute that references this                   AntaTemplate instance.</p> Source code in <code>anta/models.py</code> <pre><code>def render(self, params: Dict[str, Any]) -&gt; AntaCommand:\n\"\"\"Render an AntaCommand from an AntaTemplate instance.\n    Keep the parameters used in the AntaTemplate instance.\n\n     Args:\n         params: dictionary of variables with string values to render the Python f-string\n\n     Returns:\n         AntaCommand: The rendered AntaCommand.\n                      This AntaCommand instance have a template attribute that references this\n                      AntaTemplate instance.\n    \"\"\"\n    return AntaCommand(command=self.template.format(**params), ofmt=self.ofmt, version=self.version, revision=self.revision, template=self, params=params)\n</code></pre>"},{"location":"api/report_manager/","title":"Report Manager module","text":""},{"location":"api/report_manager/#anta-reportmanager-module","title":"ANTA ReportManager module","text":"<p>TableReport Generate a Table based on TestResult.</p> Source code in <code>anta/reporter/__init__.py</code> <pre><code>class ReportTable:\n\"\"\"TableReport Generate a Table based on TestResult.\"\"\"\n\n    def __init__(self) -&gt; None:\n\"\"\"\n        __init__ Class constructor\n        \"\"\"\n        self.colors = []\n        self.colors.append(ColorManager(level=\"success\", color=RICH_COLOR_PALETTE.SUCCESS))\n        self.colors.append(ColorManager(level=\"failure\", color=RICH_COLOR_PALETTE.FAILURE))\n        self.colors.append(ColorManager(level=\"error\", color=RICH_COLOR_PALETTE.ERROR))\n        self.colors.append(ColorManager(level=\"skipped\", color=RICH_COLOR_PALETTE.SKIPPED))\n\n    def _split_list_to_txt_list(self, usr_list: List[str], delimiter: Optional[str] = None) -&gt; str:\n\"\"\"\n        Split list to multi-lines string\n\n        Args:\n            usr_list (List[str]): List of string to concatenate\n            delimiter (str, optional): A delimiter to use to start string. Defaults to None.\n\n        Returns:\n            str: Multi-lines string\n        \"\"\"\n        if delimiter is not None:\n            return \"\\n\".join(f\"{delimiter} {line}\" for line in usr_list)\n        return \"\\n\".join(f\"{line}\" for line in usr_list)\n\n    def _build_headers(self, headers: List[str], table: Table) -&gt; Table:\n\"\"\"\n        Create headers for a table.\n\n        First key is considered as header and is colored using RICH_COLOR_PALETTE.HEADER\n\n        Args:\n            headers (List[str]): List of headers\n            table (Table): A rich Table instance\n\n        Returns:\n            Table: A rich Table instance with headers\n        \"\"\"\n        for idx, header in enumerate(headers):\n            if idx == 0:\n                table.add_column(header, justify=\"left\", style=RICH_COLOR_PALETTE.HEADER, no_wrap=True)\n            else:\n                table.add_column(header, justify=\"left\")\n        return table\n\n    def _color_result(self, status: str, output_type: str = \"Text\") -&gt; Any:\n\"\"\"\n        Helper to implement color based on test status.\n\n        It gives output for either standard str or Text() colorized with Style()\n\n        Args:\n            status (str): status value to colorized\n            output_type (str, optional): Which format to output code. Defaults to 'Text'.\n\n        Returns:\n            Any: Can be either str or Text with Style\n        \"\"\"\n        if len([result for result in self.colors if str(result.level).upper() == status.upper()]) == 1:\n            code: ColorManager = [result for result in self.colors if str(result.level).upper() == status.upper()][0]\n            return code.style_rich() if output_type == \"Text\" else code.string()\n        return None\n\n    def report_all(\n        self,\n        result_manager: ResultManager,\n        host: Optional[str] = None,\n        testcase: Optional[str] = None,\n        title: str = \"All tests results\",\n    ) -&gt; Table:\n\"\"\"\n        Create a table report with all tests for one or all devices.\n\n        Create table with full output: Host / Test / Status / Message\n\n        Args:\n            result_manager (ResultManager): A manager with a list of tests.\n            host (str, optional): IP Address of a host to search for. Defaults to None.\n            testcase (str, optional): A test name to search for. Defaults to None.\n            title (str, optional): Title for the report. Defaults to 'All tests results'.\n\n        Returns:\n            Table: A fully populated rich Table\n        \"\"\"\n        table = Table(title=title)\n        headers = [\"Device IP\", \"Test Name\", \"Test Status\", \"Message(s)\", \"Test description\", \"Test category\"]\n        table = self._build_headers(headers=headers, table=table)\n\n        for result in result_manager.get_results(output_format=\"list\"):\n            # pylint: disable=R0916\n            if (host is None and testcase is None) or (host is not None and str(result.name) == host) or (testcase is not None and testcase == str(result.test)):\n                state = self._color_result(status=str(result.result), output_type=\"str\")\n                message = self._split_list_to_txt_list(result.messages) if len(result.messages) &gt; 0 else \"\"\n                test_categories = \", \".join(result.test_category)\n                table.add_row(str(result.name), result.test, state, message, result.test_description, test_categories)\n        return table\n\n    def report_summary_tests(\n        self,\n        result_manager: ResultManager,\n        testcase: Optional[str] = None,\n        title: str = \"Summary per test case\",\n    ) -&gt; Table:\n\"\"\"\n        Create a table report with result agregated per test.\n\n        Create table with full output: Test / Number of success / Number of failure / Number of error / List of nodes in error or failure\n\n        Args:\n            result_manager (ResultManager): A manager with a list of tests.\n            testcase (str, optional): A test name to search for. Defaults to None.\n            title (str, optional): Title for the report. Defaults to 'All tests results'.\n\n        Returns:\n            Table: A fully populated rich Table\n        \"\"\"\n        # sourcery skip: class-extract-method\n        table = Table(title=title)\n        headers = [\n            \"Test Case\",\n            \"# of success\",\n            \"# of skipped\",\n            \"# of failure\",\n            \"# of errors\",\n            \"List of failed or error nodes\",\n        ]\n        table = self._build_headers(headers=headers, table=table)\n        for testcase_read in result_manager.get_testcases():\n            if testcase is None or str(testcase_read) == testcase:\n                results = result_manager.get_result_by_test(testcase_read)\n                nb_failure = len([result for result in results if result.result == \"failure\"])\n                nb_error = len([result for result in results if result.result == \"error\"])\n                list_failure = [str(result.name) for result in results if result.result in [\"failure\", \"error\"]]\n                nb_success = len([result for result in results if result.result == \"success\"])\n                nb_skipped = len([result for result in results if result.result == \"skipped\"])\n                table.add_row(\n                    testcase_read,\n                    str(nb_success),\n                    str(nb_skipped),\n                    str(nb_failure),\n                    str(nb_error),\n                    str(list_failure),\n                )\n        return table\n\n    def report_summary_hosts(\n        self,\n        result_manager: ResultManager,\n        host: Optional[str] = None,\n        title: str = \"Summary per host\",\n    ) -&gt; Table:\n\"\"\"\n        Create a table report with result agregated per host.\n\n        Create table with full output: Host / Number of success / Number of failure / Number of error / List of nodes in error or failure\n\n        Args:\n            result_manager (ResultManager): A manager with a list of tests.\n            host (str, optional): IP Address of a host to search for. Defaults to None.\n            title (str, optional): Title for the report. Defaults to 'All tests results'.\n\n        Returns:\n            Table: A fully populated rich Table\n        \"\"\"\n        table = Table(title=title)\n        headers = [\n            \"Host IP\",\n            \"# of success\",\n            \"# of skipped\",\n            \"# of failure\",\n            \"# of errors\",\n            \"List of failed ortest case\",\n        ]\n        table = self._build_headers(headers=headers, table=table)\n        for host_read in result_manager.get_hosts():\n            if host is None or str(host_read) == host:\n                results = result_manager.get_result_by_host(host_read)\n                logger.debug(\"data to use for computation\")\n                logger.debug(f\"{host}: {results}\")\n                nb_failure = len([result for result in results if result.result == \"failure\"])\n                nb_error = len([result for result in results if result.result == \"error\"])\n                list_failure = [str(result.test) for result in results if result.result in [\"failure\", \"error\"]]\n                nb_success = len([result for result in results if result.result == \"success\"])\n                nb_skipped = len([result for result in results if result.result == \"skipped\"])\n                table.add_row(\n                    str(host_read),\n                    str(nb_success),\n                    str(nb_skipped),\n                    str(nb_failure),\n                    str(nb_error),\n                    str(list_failure),\n                )\n        return table\n</code></pre>"},{"location":"api/report_manager/#anta.reporter.ReportTable.__init__","title":"<code>__init__()</code>","text":"<p>init Class constructor</p> Source code in <code>anta/reporter/__init__.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"\n    __init__ Class constructor\n    \"\"\"\n    self.colors = []\n    self.colors.append(ColorManager(level=\"success\", color=RICH_COLOR_PALETTE.SUCCESS))\n    self.colors.append(ColorManager(level=\"failure\", color=RICH_COLOR_PALETTE.FAILURE))\n    self.colors.append(ColorManager(level=\"error\", color=RICH_COLOR_PALETTE.ERROR))\n    self.colors.append(ColorManager(level=\"skipped\", color=RICH_COLOR_PALETTE.SKIPPED))\n</code></pre>"},{"location":"api/report_manager/#anta.reporter.ReportTable.report_all","title":"<code>report_all(result_manager, host=None, testcase=None, title='All tests results')</code>","text":"<p>Create a table report with all tests for one or all devices.</p> <p>Create table with full output: Host / Test / Status / Message</p> <p>Parameters:</p> Name Type Description Default <code>result_manager</code> <code>ResultManager</code> <p>A manager with a list of tests.</p> required <code>host</code> <code>str</code> <p>IP Address of a host to search for. Defaults to None.</p> <code>None</code> <code>testcase</code> <code>str</code> <p>A test name to search for. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the report. Defaults to \u2018All tests results\u2019.</p> <code>'All tests results'</code> <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>A fully populated rich Table</p> Source code in <code>anta/reporter/__init__.py</code> <pre><code>def report_all(\n    self,\n    result_manager: ResultManager,\n    host: Optional[str] = None,\n    testcase: Optional[str] = None,\n    title: str = \"All tests results\",\n) -&gt; Table:\n\"\"\"\n    Create a table report with all tests for one or all devices.\n\n    Create table with full output: Host / Test / Status / Message\n\n    Args:\n        result_manager (ResultManager): A manager with a list of tests.\n        host (str, optional): IP Address of a host to search for. Defaults to None.\n        testcase (str, optional): A test name to search for. Defaults to None.\n        title (str, optional): Title for the report. Defaults to 'All tests results'.\n\n    Returns:\n        Table: A fully populated rich Table\n    \"\"\"\n    table = Table(title=title)\n    headers = [\"Device IP\", \"Test Name\", \"Test Status\", \"Message(s)\", \"Test description\", \"Test category\"]\n    table = self._build_headers(headers=headers, table=table)\n\n    for result in result_manager.get_results(output_format=\"list\"):\n        # pylint: disable=R0916\n        if (host is None and testcase is None) or (host is not None and str(result.name) == host) or (testcase is not None and testcase == str(result.test)):\n            state = self._color_result(status=str(result.result), output_type=\"str\")\n            message = self._split_list_to_txt_list(result.messages) if len(result.messages) &gt; 0 else \"\"\n            test_categories = \", \".join(result.test_category)\n            table.add_row(str(result.name), result.test, state, message, result.test_description, test_categories)\n    return table\n</code></pre>"},{"location":"api/report_manager/#anta.reporter.ReportTable.report_summary_hosts","title":"<code>report_summary_hosts(result_manager, host=None, title='Summary per host')</code>","text":"<p>Create a table report with result agregated per host.</p> <p>Create table with full output: Host / Number of success / Number of failure / Number of error / List of nodes in error or failure</p> <p>Parameters:</p> Name Type Description Default <code>result_manager</code> <code>ResultManager</code> <p>A manager with a list of tests.</p> required <code>host</code> <code>str</code> <p>IP Address of a host to search for. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the report. Defaults to \u2018All tests results\u2019.</p> <code>'Summary per host'</code> <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>A fully populated rich Table</p> Source code in <code>anta/reporter/__init__.py</code> <pre><code>def report_summary_hosts(\n    self,\n    result_manager: ResultManager,\n    host: Optional[str] = None,\n    title: str = \"Summary per host\",\n) -&gt; Table:\n\"\"\"\n    Create a table report with result agregated per host.\n\n    Create table with full output: Host / Number of success / Number of failure / Number of error / List of nodes in error or failure\n\n    Args:\n        result_manager (ResultManager): A manager with a list of tests.\n        host (str, optional): IP Address of a host to search for. Defaults to None.\n        title (str, optional): Title for the report. Defaults to 'All tests results'.\n\n    Returns:\n        Table: A fully populated rich Table\n    \"\"\"\n    table = Table(title=title)\n    headers = [\n        \"Host IP\",\n        \"# of success\",\n        \"# of skipped\",\n        \"# of failure\",\n        \"# of errors\",\n        \"List of failed ortest case\",\n    ]\n    table = self._build_headers(headers=headers, table=table)\n    for host_read in result_manager.get_hosts():\n        if host is None or str(host_read) == host:\n            results = result_manager.get_result_by_host(host_read)\n            logger.debug(\"data to use for computation\")\n            logger.debug(f\"{host}: {results}\")\n            nb_failure = len([result for result in results if result.result == \"failure\"])\n            nb_error = len([result for result in results if result.result == \"error\"])\n            list_failure = [str(result.test) for result in results if result.result in [\"failure\", \"error\"]]\n            nb_success = len([result for result in results if result.result == \"success\"])\n            nb_skipped = len([result for result in results if result.result == \"skipped\"])\n            table.add_row(\n                str(host_read),\n                str(nb_success),\n                str(nb_skipped),\n                str(nb_failure),\n                str(nb_error),\n                str(list_failure),\n            )\n    return table\n</code></pre>"},{"location":"api/report_manager/#anta.reporter.ReportTable.report_summary_tests","title":"<code>report_summary_tests(result_manager, testcase=None, title='Summary per test case')</code>","text":"<p>Create a table report with result agregated per test.</p> <p>Create table with full output: Test / Number of success / Number of failure / Number of error / List of nodes in error or failure</p> <p>Parameters:</p> Name Type Description Default <code>result_manager</code> <code>ResultManager</code> <p>A manager with a list of tests.</p> required <code>testcase</code> <code>str</code> <p>A test name to search for. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the report. Defaults to \u2018All tests results\u2019.</p> <code>'Summary per test case'</code> <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>A fully populated rich Table</p> Source code in <code>anta/reporter/__init__.py</code> <pre><code>def report_summary_tests(\n    self,\n    result_manager: ResultManager,\n    testcase: Optional[str] = None,\n    title: str = \"Summary per test case\",\n) -&gt; Table:\n\"\"\"\n    Create a table report with result agregated per test.\n\n    Create table with full output: Test / Number of success / Number of failure / Number of error / List of nodes in error or failure\n\n    Args:\n        result_manager (ResultManager): A manager with a list of tests.\n        testcase (str, optional): A test name to search for. Defaults to None.\n        title (str, optional): Title for the report. Defaults to 'All tests results'.\n\n    Returns:\n        Table: A fully populated rich Table\n    \"\"\"\n    # sourcery skip: class-extract-method\n    table = Table(title=title)\n    headers = [\n        \"Test Case\",\n        \"# of success\",\n        \"# of skipped\",\n        \"# of failure\",\n        \"# of errors\",\n        \"List of failed or error nodes\",\n    ]\n    table = self._build_headers(headers=headers, table=table)\n    for testcase_read in result_manager.get_testcases():\n        if testcase is None or str(testcase_read) == testcase:\n            results = result_manager.get_result_by_test(testcase_read)\n            nb_failure = len([result for result in results if result.result == \"failure\"])\n            nb_error = len([result for result in results if result.result == \"error\"])\n            list_failure = [str(result.name) for result in results if result.result in [\"failure\", \"error\"]]\n            nb_success = len([result for result in results if result.result == \"success\"])\n            nb_skipped = len([result for result in results if result.result == \"skipped\"])\n            table.add_row(\n                testcase_read,\n                str(nb_success),\n                str(nb_skipped),\n                str(nb_failure),\n                str(nb_error),\n                str(list_failure),\n            )\n    return table\n</code></pre>"},{"location":"api/report_manager_models/","title":"Report Manager models","text":""},{"location":"api/report_manager_models/#colormanager-entry","title":"ColorManager Entry","text":"<p>         Bases: <code>BaseModel</code></p> <p>Color management for status report.</p> <p>Attributes:</p> Name Type Description <code>level</code> <code>str</code> <p>Test result value.</p> <code>color</code> <code>str</code> <p>Associated color.</p> Source code in <code>anta/reporter/models.py</code> <pre><code>class ColorManager(BaseModel):\n\"\"\"Color management for status report.\n\n    Attributes:\n        level (str): Test result value.\n        color (str): Associated color.\n    \"\"\"\n\n    level: str\n    color: str\n\n    @validator(\"level\", allow_reuse=True)\n    def name_must_be_in(cls, v: str) -&gt; str:\n\"\"\"\n        Status validator\n\n        Validate status is a supported one\n\n        Args:\n            v (str): User defined level\n\n        Raises:\n            ValueError: If level is unsupported\n\n        Returns:\n            str: level value\n        \"\"\"\n        if v not in RESULT_OPTIONS:\n            raise ValueError(f\"must be one of {RESULT_OPTIONS}\")\n        return v\n\n    def style_rich(self) -&gt; Text:\n\"\"\"\n        Build a rich Text syntax with color\n\n        Returns:\n            Text: object with level string and its associated color.\n        \"\"\"\n        return Text(self.level, style=self.color)\n\n    def string(self) -&gt; str:\n\"\"\"\n        Build an str with color code\n\n        Returns:\n            str: String with level and its associated color\n        \"\"\"\n        return f\"[{self.color}]{self.level}\"\n</code></pre>"},{"location":"api/report_manager_models/#anta.reporter.models.ColorManager.name_must_be_in","title":"<code>name_must_be_in(v)</code>","text":"<p>Status validator</p> <p>Validate status is a supported one</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>User defined level</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If level is unsupported</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>level value</p> Source code in <code>anta/reporter/models.py</code> <pre><code>@validator(\"level\", allow_reuse=True)\ndef name_must_be_in(cls, v: str) -&gt; str:\n\"\"\"\n    Status validator\n\n    Validate status is a supported one\n\n    Args:\n        v (str): User defined level\n\n    Raises:\n        ValueError: If level is unsupported\n\n    Returns:\n        str: level value\n    \"\"\"\n    if v not in RESULT_OPTIONS:\n        raise ValueError(f\"must be one of {RESULT_OPTIONS}\")\n    return v\n</code></pre>"},{"location":"api/report_manager_models/#anta.reporter.models.ColorManager.string","title":"<code>string()</code>","text":"<p>Build an str with color code</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String with level and its associated color</p> Source code in <code>anta/reporter/models.py</code> <pre><code>def string(self) -&gt; str:\n\"\"\"\n    Build an str with color code\n\n    Returns:\n        str: String with level and its associated color\n    \"\"\"\n    return f\"[{self.color}]{self.level}\"\n</code></pre>"},{"location":"api/report_manager_models/#anta.reporter.models.ColorManager.style_rich","title":"<code>style_rich()</code>","text":"<p>Build a rich Text syntax with color</p> <p>Returns:</p> Name Type Description <code>Text</code> <code>Text</code> <p>object with level string and its associated color.</p> Source code in <code>anta/reporter/models.py</code> <pre><code>def style_rich(self) -&gt; Text:\n\"\"\"\n    Build a rich Text syntax with color\n\n    Returns:\n        Text: object with level string and its associated color.\n    \"\"\"\n    return Text(self.level, style=self.color)\n</code></pre>"},{"location":"api/result_manager/","title":"Result Manager module","text":""},{"location":"api/result_manager/#anta-resultmanager-module","title":"ANTA ResultManager module","text":"<p>Helper to manage Test Results and generate reports.</p> <p>Examples:</p> <p>Create Inventory:</p> <pre><code>inventory_anta = AntaInventory.parse(\n    inventory_file='examples/inventory.yml',\n    username='ansible',\n    password='ansible',\n    timeout=0.5\n)\n</code></pre> <p>Create Result Manager:</p> <pre><code>manager = ResultManager()\n</code></pre> <p>Run tests for all connected devices:</p> <pre><code>for device in inventory_anta.get_inventory():\n    manager.add_test_result(\nVerifyNTP(device=device).test()\n)\nmanager.add_test_result(\nVerifyEOSVersion(device=device).test(version='4.28.3M')\n)\n</code></pre> <p>Print result in native format:</p> <pre><code>manager.get_results()\n[\n    TestResult(\n        host=IPv4Address('192.168.0.10'),\n        test='VerifyNTP',\n        result='failure',\n        message=\"device is not running NTP correctly\"\n    ),\n    TestResult(\n        host=IPv4Address('192.168.0.10'),\n        test='VerifyEOSVersion',\n        result='success',\n        message=None\n    ),\n]\n</code></pre> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>class ResultManager:\n\"\"\"\n    Helper to manage Test Results and generate reports.\n\n    Examples:\n\n        Create Inventory:\n\n            inventory_anta = AntaInventory.parse(\n                inventory_file='examples/inventory.yml',\n                username='ansible',\n                password='ansible',\n                timeout=0.5\n            )\n\n        Create Result Manager:\n\n            manager = ResultManager()\n\n        Run tests for all connected devices:\n\n            for device in inventory_anta.get_inventory():\n                manager.add_test_result(\n                    VerifyNTP(device=device).test()\n                )\n                manager.add_test_result(\n                    VerifyEOSVersion(device=device).test(version='4.28.3M')\n                )\n\n        Print result in native format:\n\n            manager.get_results()\n            [\n                TestResult(\n                    host=IPv4Address('192.168.0.10'),\n                    test='VerifyNTP',\n                    result='failure',\n                    message=\"device is not running NTP correctly\"\n                ),\n                TestResult(\n                    host=IPv4Address('192.168.0.10'),\n                    test='VerifyEOSVersion',\n                    result='success',\n                    message=None\n                ),\n            ]\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n\"\"\"\n        Class constructor.\n\n        The status of the class is initialized to \"unset\"\n\n        Then when adding a test with a status that is NOT 'error' the following\n        table shows the updated status:\n\n        | Current Status |         Added test Status       | Updated Status |\n        | -------------- | ------------------------------- | -------------- |\n        |      unset     |              Any                |       Any      |\n        |     skipped    |         unset, skipped          |     skipped    |\n        |     skipped    |            success              |     success    |\n        |     skipped    |            failure              |     failure    |\n        |     success    |     unset, skipped, success     |     success    |\n        |     success    |            failure              |     failure    |\n        |     failure    | unset, skipped success, failure |     failure    |\n\n        If the status of the added test is error, the status is untouched and the\n        error_status is set to True.\n        \"\"\"\n        logger.debug(\"Instantiate result-manager\")\n        self._result_entries = ListResult()\n        # Initialize status\n        self.status = \"unset\"\n        self.error_status = False\n\n    def __len__(self) -&gt; int:\n\"\"\"\n        Implement __len__ method to count number of results.\n        \"\"\"\n        return len(self._result_entries)\n\n    def __update_status(self, test_status: str) -&gt; None:\n\"\"\"\n        Update ResultManager status based on the table above.\n        \"\"\"\n        if test_status not in RESULT_OPTIONS:\n            raise ValueError(\"{test_status} is not a valid result option\")\n        if test_status == \"error\":\n            self.error_status = True\n            return\n\n        if self.status == \"unset\":\n            self.status = test_status\n        elif self.status == \"skipped\" and test_status in {\"success\", \"failure\"}:\n            self.status = test_status\n        elif self.status == \"success\" and test_status == \"failure\":\n            self.status = \"failure\"\n\n    def add_test_result(self, entry: TestResult) -&gt; None:\n\"\"\"Add a result to the list\n\n        Args:\n            entry (TestResult): TestResult data to add to the report\n        \"\"\"\n        logger.debug(entry)\n        self._result_entries.append(entry)\n        self.__update_status(entry.result)\n\n    def add_test_results(self, entries: List[TestResult]) -&gt; None:\n\"\"\"Add a list of results to the list\n\n        Args:\n            entries (List[TestResult]): list of TestResult data to add to the report\n        \"\"\"\n        for e in entries:\n            self.add_test_result(e)\n\n    def get_status(self, ignore_error: bool = False) -&gt; str:\n\"\"\"\n        Returns the current status including error_status if ignore_error is False\n        \"\"\"\n        return \"error\" if self.error_status and not ignore_error else self.status\n\n    def get_results(self, output_format: str = \"native\") -&gt; Any:\n\"\"\"\n        Expose list of all test results in different format\n\n        Support multiple format:\n          - native: ListResults format\n          - list: a list of TestResult\n          - json: a native JSON format\n\n        Args:\n            output_format (str, optional): format selector. Can be either native/list/json. Defaults to 'native'.\n\n        Returns:\n            any: List of results.\n        \"\"\"\n        if output_format == \"list\":\n            return list(self._result_entries)\n\n        if output_format == \"json\":\n            return json.dumps(pydantic_to_dict(self._result_entries), indent=4)\n\n        # Default return for native format.\n        return self._result_entries\n\n    def get_result_by_test(self, test_name: str, output_format: str = \"native\") -&gt; Any:\n\"\"\"\n        Get list of test result for a given test.\n\n        Args:\n            test_name (str): Test name to use to filter results\n            output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'.\n\n        Returns:\n            list[TestResult]: List of results related to the test.\n        \"\"\"\n        if output_format == \"list\":\n            return [result for result in self._result_entries if str(result.test) == test_name]\n\n        result_manager_filtered = ListResult()\n        for result in self._result_entries:\n            if result.test == test_name:\n                result_manager_filtered.append(result)\n        return result_manager_filtered\n\n    def get_result_by_host(self, host_ip: str, output_format: str = \"native\") -&gt; Any:\n\"\"\"\n        Get list of test result for a given host.\n\n        Args:\n            host_ip (str): IP Address of the host to use to filter results.\n            output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'.\n\n        Returns:\n            Any: List of results related to the host.\n        \"\"\"\n        if output_format == \"list\":\n            return [result for result in self._result_entries if str(result.name) == host_ip]\n\n        result_manager_filtered = ListResult()\n        for result in self._result_entries:\n            if str(result.name) == host_ip:\n                result_manager_filtered.append(result)\n        return result_manager_filtered\n\n    def get_testcases(self) -&gt; List[str]:\n\"\"\"\n        Get list of name of all test cases in current manager.\n\n        Returns:\n            List[str]: List of names for all tests.\n        \"\"\"\n        result_list = []\n        for testcase in self._result_entries:\n            if str(testcase.test) not in result_list:\n                result_list.append(str(testcase.test))\n        return result_list\n\n    def get_hosts(self) -&gt; List[str]:\n\"\"\"\n        Get list of IP addresses in current manager.\n\n        Returns:\n            List[str]: List of IP addresses.\n        \"\"\"\n        result_list = []\n        for testcase in self._result_entries:\n            if str(testcase.name) not in result_list:\n                result_list.append(str(testcase.name))\n        return result_list\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> <p>The status of the class is initialized to \u201cunset\u201d</p> <p>Then when adding a test with a status that is NOT \u2018error\u2019 the following table shows the updated status:</p> Current Status Added test Status Updated Status unset Any Any skipped unset, skipped skipped skipped success success skipped failure failure success unset, skipped, success success success failure failure failure unset, skipped success, failure failure <p>If the status of the added test is error, the status is untouched and the error_status is set to True.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"\n    Class constructor.\n\n    The status of the class is initialized to \"unset\"\n\n    Then when adding a test with a status that is NOT 'error' the following\n    table shows the updated status:\n\n    | Current Status |         Added test Status       | Updated Status |\n    | -------------- | ------------------------------- | -------------- |\n    |      unset     |              Any                |       Any      |\n    |     skipped    |         unset, skipped          |     skipped    |\n    |     skipped    |            success              |     success    |\n    |     skipped    |            failure              |     failure    |\n    |     success    |     unset, skipped, success     |     success    |\n    |     success    |            failure              |     failure    |\n    |     failure    | unset, skipped success, failure |     failure    |\n\n    If the status of the added test is error, the status is untouched and the\n    error_status is set to True.\n    \"\"\"\n    logger.debug(\"Instantiate result-manager\")\n    self._result_entries = ListResult()\n    # Initialize status\n    self.status = \"unset\"\n    self.error_status = False\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.__len__","title":"<code>__len__()</code>","text":"<p>Implement len method to count number of results.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"\n    Implement __len__ method to count number of results.\n    \"\"\"\n    return len(self._result_entries)\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.__update_status","title":"<code>__update_status(test_status)</code>","text":"<p>Update ResultManager status based on the table above.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def __update_status(self, test_status: str) -&gt; None:\n\"\"\"\n    Update ResultManager status based on the table above.\n    \"\"\"\n    if test_status not in RESULT_OPTIONS:\n        raise ValueError(\"{test_status} is not a valid result option\")\n    if test_status == \"error\":\n        self.error_status = True\n        return\n\n    if self.status == \"unset\":\n        self.status = test_status\n    elif self.status == \"skipped\" and test_status in {\"success\", \"failure\"}:\n        self.status = test_status\n    elif self.status == \"success\" and test_status == \"failure\":\n        self.status = \"failure\"\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.add_test_result","title":"<code>add_test_result(entry)</code>","text":"<p>Add a result to the list</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>TestResult</code> <p>TestResult data to add to the report</p> required Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def add_test_result(self, entry: TestResult) -&gt; None:\n\"\"\"Add a result to the list\n\n    Args:\n        entry (TestResult): TestResult data to add to the report\n    \"\"\"\n    logger.debug(entry)\n    self._result_entries.append(entry)\n    self.__update_status(entry.result)\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.add_test_results","title":"<code>add_test_results(entries)</code>","text":"<p>Add a list of results to the list</p> <p>Parameters:</p> Name Type Description Default <code>entries</code> <code>List[TestResult]</code> <p>list of TestResult data to add to the report</p> required Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def add_test_results(self, entries: List[TestResult]) -&gt; None:\n\"\"\"Add a list of results to the list\n\n    Args:\n        entries (List[TestResult]): list of TestResult data to add to the report\n    \"\"\"\n    for e in entries:\n        self.add_test_result(e)\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_hosts","title":"<code>get_hosts()</code>","text":"<p>Get list of IP addresses in current manager.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of IP addresses.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def get_hosts(self) -&gt; List[str]:\n\"\"\"\n    Get list of IP addresses in current manager.\n\n    Returns:\n        List[str]: List of IP addresses.\n    \"\"\"\n    result_list = []\n    for testcase in self._result_entries:\n        if str(testcase.name) not in result_list:\n            result_list.append(str(testcase.name))\n    return result_list\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_result_by_host","title":"<code>get_result_by_host(host_ip, output_format='native')</code>","text":"<p>Get list of test result for a given host.</p> <p>Parameters:</p> Name Type Description Default <code>host_ip</code> <code>str</code> <p>IP Address of the host to use to filter results.</p> required <code>output_format</code> <code>str</code> <p>format selector. Can be either native/list. Defaults to \u2018native\u2019.</p> <code>'native'</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>List of results related to the host.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def get_result_by_host(self, host_ip: str, output_format: str = \"native\") -&gt; Any:\n\"\"\"\n    Get list of test result for a given host.\n\n    Args:\n        host_ip (str): IP Address of the host to use to filter results.\n        output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'.\n\n    Returns:\n        Any: List of results related to the host.\n    \"\"\"\n    if output_format == \"list\":\n        return [result for result in self._result_entries if str(result.name) == host_ip]\n\n    result_manager_filtered = ListResult()\n    for result in self._result_entries:\n        if str(result.name) == host_ip:\n            result_manager_filtered.append(result)\n    return result_manager_filtered\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_result_by_test","title":"<code>get_result_by_test(test_name, output_format='native')</code>","text":"<p>Get list of test result for a given test.</p> <p>Parameters:</p> Name Type Description Default <code>test_name</code> <code>str</code> <p>Test name to use to filter results</p> required <code>output_format</code> <code>str</code> <p>format selector. Can be either native/list. Defaults to \u2018native\u2019.</p> <code>'native'</code> <p>Returns:</p> Type Description <code>Any</code> <p>list[TestResult]: List of results related to the test.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def get_result_by_test(self, test_name: str, output_format: str = \"native\") -&gt; Any:\n\"\"\"\n    Get list of test result for a given test.\n\n    Args:\n        test_name (str): Test name to use to filter results\n        output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'.\n\n    Returns:\n        list[TestResult]: List of results related to the test.\n    \"\"\"\n    if output_format == \"list\":\n        return [result for result in self._result_entries if str(result.test) == test_name]\n\n    result_manager_filtered = ListResult()\n    for result in self._result_entries:\n        if result.test == test_name:\n            result_manager_filtered.append(result)\n    return result_manager_filtered\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_results","title":"<code>get_results(output_format='native')</code>","text":"<p>Expose list of all test results in different format</p> Support multiple format <ul> <li>native: ListResults format</li> <li>list: a list of TestResult</li> <li>json: a native JSON format</li> </ul> <p>Parameters:</p> Name Type Description Default <code>output_format</code> <code>str</code> <p>format selector. Can be either native/list/json. Defaults to \u2018native\u2019.</p> <code>'native'</code> <p>Returns:</p> Name Type Description <code>any</code> <code>Any</code> <p>List of results.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def get_results(self, output_format: str = \"native\") -&gt; Any:\n\"\"\"\n    Expose list of all test results in different format\n\n    Support multiple format:\n      - native: ListResults format\n      - list: a list of TestResult\n      - json: a native JSON format\n\n    Args:\n        output_format (str, optional): format selector. Can be either native/list/json. Defaults to 'native'.\n\n    Returns:\n        any: List of results.\n    \"\"\"\n    if output_format == \"list\":\n        return list(self._result_entries)\n\n    if output_format == \"json\":\n        return json.dumps(pydantic_to_dict(self._result_entries), indent=4)\n\n    # Default return for native format.\n    return self._result_entries\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_status","title":"<code>get_status(ignore_error=False)</code>","text":"<p>Returns the current status including error_status if ignore_error is False</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def get_status(self, ignore_error: bool = False) -&gt; str:\n\"\"\"\n    Returns the current status including error_status if ignore_error is False\n    \"\"\"\n    return \"error\" if self.error_status and not ignore_error else self.status\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_testcases","title":"<code>get_testcases()</code>","text":"<p>Get list of name of all test cases in current manager.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of names for all tests.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def get_testcases(self) -&gt; List[str]:\n\"\"\"\n    Get list of name of all test cases in current manager.\n\n    Returns:\n        List[str]: List of names for all tests.\n    \"\"\"\n    result_list = []\n    for testcase in self._result_entries:\n        if str(testcase.test) not in result_list:\n            result_list.append(str(testcase.test))\n    return result_list\n</code></pre>"},{"location":"api/result_manager_models/","title":"Result Manager models","text":""},{"location":"api/result_manager_models/#testresult-entry","title":"TestResult Entry","text":"<p>         Bases: <code>BaseModel</code></p> <p>Describe the result of a test from a single device.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Device name where the test has run.</p> <code>test</code> <code>str</code> <p>Test name runs on the device.</p> <code>test_category</code> <code>List[str]</code> <p>List of test categories the test belongs to.</p> <code>test_description</code> <code>str</code> <p>Test description.</p> <code>results</code> <code>str</code> <p>Result of the test. Can be one of [\u201cunset\u201d, \u201csuccess\u201d, \u201cfailure\u201d, \u201cerror\u201d, \u201cskipped\u201d].</p> <code>message</code> <code>str</code> <p>Message to report after the test if any.</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>class TestResult(BaseModel):\n\"\"\"\n    Describe the result of a test from a single device.\n\n    Attributes:\n        name (str): Device name where the test has run.\n        test (str): Test name runs on the device.\n        test_category (List[str]): List of test categories the test belongs to.\n        test_description (str): Test description.\n        results (str): Result of the test. Can be one of [\"unset\", \"success\", \"failure\", \"error\", \"skipped\"].\n        message (str, optional): Message to report after the test if any.\n    \"\"\"\n\n    name: str\n    test: str\n    test_category: List[str]\n    test_description: str\n    result: str = \"unset\"\n    messages: List[str] = []\n\n    @classmethod\n    @field_validator(\"result\")\n    def name_must_be_in(cls, v: str) -&gt; str:\n\"\"\"\n        Status validator\n\n        Validate status is a supported one\n\n        Args:\n            v (str): User defined status\n\n        Raises:\n            ValueError: If status is unsupported\n\n        Returns:\n            str: status value\n        \"\"\"\n        if v not in RESULT_OPTIONS:\n            raise ValueError(f\"must be one of {RESULT_OPTIONS}\")\n        return v\n\n    def is_success(self, message: str = \"\") -&gt; bool:\n\"\"\"\n        Helper to set status to success\n\n        Args:\n            message (str): Optional message related to the test\n\n        Returns:\n            bool: Always true\n        \"\"\"\n        return self._set_status(\"success\", message)\n\n    def is_failure(self, message: str = \"\") -&gt; bool:\n\"\"\"\n        Helper to set status to failure\n\n        Args:\n            message (str): Optional message related to the test\n\n        Returns:\n            bool: Always true\n        \"\"\"\n        return self._set_status(\"failure\", message)\n\n    def is_skipped(self, message: str = \"\") -&gt; bool:\n\"\"\"\n        Helper to set status to skipped\n\n        Args:\n            message (str): Optional message related to the test\n\n        Returns:\n            bool: Always true\n        \"\"\"\n        return self._set_status(\"skipped\", message)\n\n    def is_error(self, message: str = \"\") -&gt; bool:\n\"\"\"\n        Helper to set status to error\n\n        Args:\n            message (str): Optional message related to the test\n\n        Returns:\n            bool: Always true\n        \"\"\"\n        return self._set_status(\"error\", message)\n\n    def _set_status(self, status: str, message: str = \"\") -&gt; bool:\n\"\"\"\n        Set status and insert optional message\n\n        Args:\n            status (str): status of the test\n            message (str): optional message\n\n        Returns:\n            bool: Always true\n        \"\"\"\n        self.result = status\n        if message != \"\":\n            self.messages.append(message)\n        return True\n\n    def __str__(self) -&gt; str:\n\"\"\"\n        Returns a human readable string of this TestResult\n        \"\"\"\n        return f\"Test {self.test} on device {self.name} has result {self.result}\"\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.TestResult.__str__","title":"<code>__str__()</code>","text":"<p>Returns a human readable string of this TestResult</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"\n    Returns a human readable string of this TestResult\n    \"\"\"\n    return f\"Test {self.test} on device {self.name} has result {self.result}\"\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.TestResult.is_error","title":"<code>is_error(message='')</code>","text":"<p>Helper to set status to error</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Optional message related to the test</p> <code>''</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Always true</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def is_error(self, message: str = \"\") -&gt; bool:\n\"\"\"\n    Helper to set status to error\n\n    Args:\n        message (str): Optional message related to the test\n\n    Returns:\n        bool: Always true\n    \"\"\"\n    return self._set_status(\"error\", message)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.TestResult.is_failure","title":"<code>is_failure(message='')</code>","text":"<p>Helper to set status to failure</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Optional message related to the test</p> <code>''</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Always true</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def is_failure(self, message: str = \"\") -&gt; bool:\n\"\"\"\n    Helper to set status to failure\n\n    Args:\n        message (str): Optional message related to the test\n\n    Returns:\n        bool: Always true\n    \"\"\"\n    return self._set_status(\"failure\", message)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.TestResult.is_skipped","title":"<code>is_skipped(message='')</code>","text":"<p>Helper to set status to skipped</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Optional message related to the test</p> <code>''</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Always true</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def is_skipped(self, message: str = \"\") -&gt; bool:\n\"\"\"\n    Helper to set status to skipped\n\n    Args:\n        message (str): Optional message related to the test\n\n    Returns:\n        bool: Always true\n    \"\"\"\n    return self._set_status(\"skipped\", message)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.TestResult.is_success","title":"<code>is_success(message='')</code>","text":"<p>Helper to set status to success</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Optional message related to the test</p> <code>''</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Always true</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def is_success(self, message: str = \"\") -&gt; bool:\n\"\"\"\n    Helper to set status to success\n\n    Args:\n        message (str): Optional message related to the test\n\n    Returns:\n        bool: Always true\n    \"\"\"\n    return self._set_status(\"success\", message)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.TestResult.name_must_be_in","title":"<code>name_must_be_in(v)</code>  <code>classmethod</code>","text":"<p>Status validator</p> <p>Validate status is a supported one</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>User defined status</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If status is unsupported</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>status value</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>@classmethod\n@field_validator(\"result\")\ndef name_must_be_in(cls, v: str) -&gt; str:\n\"\"\"\n    Status validator\n\n    Validate status is a supported one\n\n    Args:\n        v (str): User defined status\n\n    Raises:\n        ValueError: If status is unsupported\n\n    Returns:\n        str: status value\n    \"\"\"\n    if v not in RESULT_OPTIONS:\n        raise ValueError(f\"must be one of {RESULT_OPTIONS}\")\n    return v\n</code></pre>"},{"location":"api/result_manager_models/#listresult","title":"ListResult","text":"<p>         Bases: <code>RootModel[List[TestResult]]</code></p> <p>List result for all tests on all devices.</p> <p>Attributes:</p> Name Type Description <code>__root__</code> <code>List[TestResult]</code> <p>A list of TestResult objects.</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>class ListResult(RootModel[List[TestResult]]):\n\"\"\"\n    List result for all tests on all devices.\n\n    Attributes:\n        __root__ (List[TestResult]): A list of TestResult objects.\n    \"\"\"\n\n    root: List[TestResult] = []\n\n    def extend(self, values: List[TestResult]) -&gt; None:\n\"\"\"Add support for extend method.\"\"\"\n        self.root.extend(values)\n\n    def append(self, value: TestResult) -&gt; None:\n\"\"\"Add support for append method.\"\"\"\n        self.root.append(value)\n\n    def __iter__(self) -&gt; Iterator[TestResult]:  # type: ignore\n\"\"\"Use custom iter method.\"\"\"\n        # TODO - mypy is not happy because we overwrite BaseModel.__iter__\n        # return type and are breaking Liskov Substitution Principle.\n        return iter(self.root)\n\n    def __getitem__(self, item: int) -&gt; TestResult:\n\"\"\"Use custom getitem method.\"\"\"\n        return self.root[item]\n\n    def __len__(self) -&gt; int:\n\"\"\"Support for length of __root__\"\"\"\n        return len(self.root)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.ListResult.__getitem__","title":"<code>__getitem__(item)</code>","text":"<p>Use custom getitem method.</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def __getitem__(self, item: int) -&gt; TestResult:\n\"\"\"Use custom getitem method.\"\"\"\n    return self.root[item]\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.ListResult.__iter__","title":"<code>__iter__()</code>","text":"<p>Use custom iter method.</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def __iter__(self) -&gt; Iterator[TestResult]:  # type: ignore\n\"\"\"Use custom iter method.\"\"\"\n    # TODO - mypy is not happy because we overwrite BaseModel.__iter__\n    # return type and are breaking Liskov Substitution Principle.\n    return iter(self.root)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.ListResult.__len__","title":"<code>__len__()</code>","text":"<p>Support for length of root</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Support for length of __root__\"\"\"\n    return len(self.root)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.ListResult.append","title":"<code>append(value)</code>","text":"<p>Add support for append method.</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def append(self, value: TestResult) -&gt; None:\n\"\"\"Add support for append method.\"\"\"\n    self.root.append(value)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.ListResult.extend","title":"<code>extend(values)</code>","text":"<p>Add support for extend method.</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def extend(self, values: List[TestResult]) -&gt; None:\n\"\"\"Add support for extend method.\"\"\"\n    self.root.extend(values)\n</code></pre>"},{"location":"api/tests.aaa/","title":"AAA","text":""},{"location":"api/tests.aaa/#anta-catalog-for-aaa-tests","title":"ANTA catalog for AAA tests","text":"<p>Test functions related to the EOS various AAA settings</p>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAcctConsoleMethods","title":"<code>VerifyAcctConsoleMethods</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the AAA accounting console method lists for different accounting types (system, exec, commands, dot1x).</p> Expected Results <ul> <li>success: The test will pass if the provided AAA accounting console method list is matching in the configured accounting types.</li> <li>failure: The test will fail if the provided AAA accounting console method list is NOT matching in the configured accounting types.</li> <li>skipped: The test will be skipped if the AAA accounting console method list or accounting type list are not provided.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyAcctConsoleMethods(AntaTest):\n\"\"\"\n    Verifies the AAA accounting console method lists for different accounting types (system, exec, commands, dot1x).\n\n    Expected Results:\n        * success: The test will pass if the provided AAA accounting console method list is matching in the configured accounting types.\n        * failure: The test will fail if the provided AAA accounting console method list is NOT matching in the configured accounting types.\n        * skipped: The test will be skipped if the AAA accounting console method list or accounting type list are not provided.\n    \"\"\"\n\n    name = \"VerifyAcctConsoleMethods\"\n    description = \"Verifies the AAA accounting console method lists for different accounting types (system, exec, commands, dot1x).\"\n    categories = [\"aaa\"]\n    commands = [AntaCommand(command=\"show aaa methods accounting\")]\n\n    @AntaTest.anta_test\n    def test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyAcctConsoleMethods validation.\n\n        Args:\n            methods: List of AAA accounting console methods. Methods should be in the right order.\n            auth_types: List of accounting types to verify. List elements must be: commands, exec, system, dot1x.\n        \"\"\"\n        if not methods or not auth_types:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n            return\n\n        methods_with_group = _check_group_methods(methods)\n\n        _check_auth_type(auth_types, [\"system\", \"exec\", \"commands\", \"dot1x\"])\n\n        command_output = self.instance_commands[0].json_output\n\n        not_matching = []\n        not_configured = []\n\n        for auth_type in auth_types:\n            auth_type_key = f\"{auth_type}AcctMethods\"\n\n            method_key = list(command_output[auth_type_key].keys())[0]\n\n            if not command_output[auth_type_key][method_key].get(\"consoleAction\"):\n                not_configured.append(auth_type)\n\n            if command_output[auth_type_key][method_key][\"consoleMethods\"] != methods_with_group:\n                not_matching.append(auth_type)\n\n        if not_configured:\n            self.result.is_failure(f\"AAA console accounting is not configured for {not_configured}\")\n            return\n\n        if not not_matching:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"AAA accounting console methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAcctConsoleMethods.test","title":"<code>test(methods=None, auth_types=None)</code>","text":"<p>Run VerifyAcctConsoleMethods validation.</p> <p>Parameters:</p> Name Type Description Default <code>methods</code> <code>Optional[List[str]]</code> <p>List of AAA accounting console methods. Methods should be in the right order.</p> <code>None</code> <code>auth_types</code> <code>Optional[List[str]]</code> <p>List of accounting types to verify. List elements must be: commands, exec, system, dot1x.</p> <code>None</code> Source code in <code>anta/tests/aaa.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyAcctConsoleMethods validation.\n\n    Args:\n        methods: List of AAA accounting console methods. Methods should be in the right order.\n        auth_types: List of accounting types to verify. List elements must be: commands, exec, system, dot1x.\n    \"\"\"\n    if not methods or not auth_types:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n        return\n\n    methods_with_group = _check_group_methods(methods)\n\n    _check_auth_type(auth_types, [\"system\", \"exec\", \"commands\", \"dot1x\"])\n\n    command_output = self.instance_commands[0].json_output\n\n    not_matching = []\n    not_configured = []\n\n    for auth_type in auth_types:\n        auth_type_key = f\"{auth_type}AcctMethods\"\n\n        method_key = list(command_output[auth_type_key].keys())[0]\n\n        if not command_output[auth_type_key][method_key].get(\"consoleAction\"):\n            not_configured.append(auth_type)\n\n        if command_output[auth_type_key][method_key][\"consoleMethods\"] != methods_with_group:\n            not_matching.append(auth_type)\n\n    if not_configured:\n        self.result.is_failure(f\"AAA console accounting is not configured for {not_configured}\")\n        return\n\n    if not not_matching:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"AAA accounting console methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAcctDefaultMethods","title":"<code>VerifyAcctDefaultMethods</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the AAA accounting default method lists for different accounting types (system, exec, commands, dot1x).</p> Expected Results <ul> <li>success: The test will pass if the provided AAA accounting default method list is matching in the configured accounting types.</li> <li>failure: The test will fail if the provided AAA accounting default method list is NOT matching in the configured accounting types.</li> <li>skipped: The test will be skipped if the AAA accounting default method list or accounting type list are not provided.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyAcctDefaultMethods(AntaTest):\n\"\"\"\n    Verifies the AAA accounting default method lists for different accounting types (system, exec, commands, dot1x).\n\n    Expected Results:\n        * success: The test will pass if the provided AAA accounting default method list is matching in the configured accounting types.\n        * failure: The test will fail if the provided AAA accounting default method list is NOT matching in the configured accounting types.\n        * skipped: The test will be skipped if the AAA accounting default method list or accounting type list are not provided.\n    \"\"\"\n\n    name = \"VerifyAcctDefaultMethods\"\n    description = \"Verifies the AAA accounting default method lists for different accounting types (system, exec, commands, dot1x).\"\n    categories = [\"aaa\"]\n    commands = [AntaCommand(command=\"show aaa methods accounting\")]\n\n    @AntaTest.anta_test\n    def test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyAcctDefaultMethods validation.\n\n        Args:\n            methods: List of AAA accounting default methods. Methods should be in the right order.\n            auth_types: List of accounting types to verify. List elements must be: commands, exec, system, dot1x.\n        \"\"\"\n        if not methods or not auth_types:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n            return\n\n        methods_with_group = _check_group_methods(methods)\n\n        _check_auth_type(auth_types, [\"system\", \"exec\", \"commands\", \"dot1x\"])\n\n        command_output = self.instance_commands[0].json_output\n\n        not_matching = []\n        not_configured = []\n\n        for auth_type in auth_types:\n            auth_type_key = f\"{auth_type}AcctMethods\"\n\n            method_key = list(command_output[auth_type_key].keys())[0]\n\n            if not command_output[auth_type_key][method_key].get(\"defaultAction\"):\n                not_configured.append(auth_type)\n\n            if command_output[auth_type_key][method_key][\"defaultMethods\"] != methods_with_group:\n                not_matching.append(auth_type)\n\n        if not_configured:\n            self.result.is_failure(f\"AAA default accounting is not configured for {not_configured}\")\n            return\n\n        if not not_matching:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"AAA accounting default methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAcctDefaultMethods.test","title":"<code>test(methods=None, auth_types=None)</code>","text":"<p>Run VerifyAcctDefaultMethods validation.</p> <p>Parameters:</p> Name Type Description Default <code>methods</code> <code>Optional[List[str]]</code> <p>List of AAA accounting default methods. Methods should be in the right order.</p> <code>None</code> <code>auth_types</code> <code>Optional[List[str]]</code> <p>List of accounting types to verify. List elements must be: commands, exec, system, dot1x.</p> <code>None</code> Source code in <code>anta/tests/aaa.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyAcctDefaultMethods validation.\n\n    Args:\n        methods: List of AAA accounting default methods. Methods should be in the right order.\n        auth_types: List of accounting types to verify. List elements must be: commands, exec, system, dot1x.\n    \"\"\"\n    if not methods or not auth_types:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n        return\n\n    methods_with_group = _check_group_methods(methods)\n\n    _check_auth_type(auth_types, [\"system\", \"exec\", \"commands\", \"dot1x\"])\n\n    command_output = self.instance_commands[0].json_output\n\n    not_matching = []\n    not_configured = []\n\n    for auth_type in auth_types:\n        auth_type_key = f\"{auth_type}AcctMethods\"\n\n        method_key = list(command_output[auth_type_key].keys())[0]\n\n        if not command_output[auth_type_key][method_key].get(\"defaultAction\"):\n            not_configured.append(auth_type)\n\n        if command_output[auth_type_key][method_key][\"defaultMethods\"] != methods_with_group:\n            not_matching.append(auth_type)\n\n    if not_configured:\n        self.result.is_failure(f\"AAA default accounting is not configured for {not_configured}\")\n        return\n\n    if not not_matching:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"AAA accounting default methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAuthenMethods","title":"<code>VerifyAuthenMethods</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the AAA authentication method lists for different authentication types (login, enable, dot1x).</p> Expected Results <ul> <li>success: The test will pass if the provided AAA authentication method list is matching in the configured authentication types.</li> <li>failure: The test will fail if the provided AAA authentication method list is NOT matching in the configured authentication types.</li> <li>skipped: The test will be skipped if the AAA authentication method list or authentication type list are not provided.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyAuthenMethods(AntaTest):\n\"\"\"\n    Verifies the AAA authentication method lists for different authentication types (login, enable, dot1x).\n\n    Expected Results:\n        * success: The test will pass if the provided AAA authentication method list is matching in the configured authentication types.\n        * failure: The test will fail if the provided AAA authentication method list is NOT matching in the configured authentication types.\n        * skipped: The test will be skipped if the AAA authentication method list or authentication type list are not provided.\n    \"\"\"\n\n    name = \"VerifyAuthenMethods\"\n    description = \"Verifies the AAA authentication method lists for different authentication types (login, enable, dot1x).\"\n    categories = [\"aaa\"]\n    commands = [AntaCommand(command=\"show aaa methods authentication\")]\n\n    @AntaTest.anta_test\n    def test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyAuthenMethods validation.\n\n        Args:\n            methods: List of AAA authentication methods. Methods should be in the right order.\n            auth_types: List of authentication types to verify. List elements must be: login, enable, dot1x.\n        \"\"\"\n        if not methods or not auth_types:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n            return\n\n        methods_with_group = _check_group_methods(methods)\n\n        _check_auth_type(auth_types, [\"login\", \"enable\", \"dot1x\"])\n\n        command_output = self.instance_commands[0].json_output\n\n        not_matching = []\n\n        for auth_type in auth_types:\n            auth_type_key = f\"{auth_type}AuthenMethods\"\n\n            if auth_type_key == \"loginAuthenMethods\":\n                if not command_output[auth_type_key].get(\"login\"):\n                    self.result.is_failure(\"AAA authentication methods are not configured for login console\")\n                    return\n\n                if command_output[auth_type_key][\"login\"][\"methods\"] != methods_with_group:\n                    self.result.is_failure(f\"AAA authentication methods {methods} are not matching for login console\")\n                    return\n\n            if command_output[auth_type_key][\"default\"][\"methods\"] != methods_with_group:\n                not_matching.append(auth_type)\n\n        if not not_matching:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"AAA authentication methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAuthenMethods.test","title":"<code>test(methods=None, auth_types=None)</code>","text":"<p>Run VerifyAuthenMethods validation.</p> <p>Parameters:</p> Name Type Description Default <code>methods</code> <code>Optional[List[str]]</code> <p>List of AAA authentication methods. Methods should be in the right order.</p> <code>None</code> <code>auth_types</code> <code>Optional[List[str]]</code> <p>List of authentication types to verify. List elements must be: login, enable, dot1x.</p> <code>None</code> Source code in <code>anta/tests/aaa.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyAuthenMethods validation.\n\n    Args:\n        methods: List of AAA authentication methods. Methods should be in the right order.\n        auth_types: List of authentication types to verify. List elements must be: login, enable, dot1x.\n    \"\"\"\n    if not methods or not auth_types:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n        return\n\n    methods_with_group = _check_group_methods(methods)\n\n    _check_auth_type(auth_types, [\"login\", \"enable\", \"dot1x\"])\n\n    command_output = self.instance_commands[0].json_output\n\n    not_matching = []\n\n    for auth_type in auth_types:\n        auth_type_key = f\"{auth_type}AuthenMethods\"\n\n        if auth_type_key == \"loginAuthenMethods\":\n            if not command_output[auth_type_key].get(\"login\"):\n                self.result.is_failure(\"AAA authentication methods are not configured for login console\")\n                return\n\n            if command_output[auth_type_key][\"login\"][\"methods\"] != methods_with_group:\n                self.result.is_failure(f\"AAA authentication methods {methods} are not matching for login console\")\n                return\n\n        if command_output[auth_type_key][\"default\"][\"methods\"] != methods_with_group:\n            not_matching.append(auth_type)\n\n    if not not_matching:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"AAA authentication methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAuthzMethods","title":"<code>VerifyAuthzMethods</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the AAA authorization method lists for different authorization types (commands, exec).</p> Expected Results <ul> <li>success: The test will pass if the provided AAA authorization method list is matching in the configured authorization types.</li> <li>failure: The test will fail if the provided AAA authorization method list is NOT matching in the configured authorization types.</li> <li>skipped: The test will be skipped if the AAA authentication method list or authorization type list are not provided.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyAuthzMethods(AntaTest):\n\"\"\"\n    Verifies the AAA authorization method lists for different authorization types (commands, exec).\n\n    Expected Results:\n        * success: The test will pass if the provided AAA authorization method list is matching in the configured authorization types.\n        * failure: The test will fail if the provided AAA authorization method list is NOT matching in the configured authorization types.\n        * skipped: The test will be skipped if the AAA authentication method list or authorization type list are not provided.\n    \"\"\"\n\n    name = \"VerifyAuthzMethods\"\n    description = \"Verifies the AAA authorization method lists for different authorization types (commands, exec).\"\n    categories = [\"aaa\"]\n    commands = [AntaCommand(command=\"show aaa methods authorization\")]\n\n    @AntaTest.anta_test\n    def test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyAuthzMethods validation.\n\n        Args:\n            methods: List of AAA authorization methods. Methods should be in the right order.\n            auth_types: List of authorization types to verify. List elements must be: commands, exec.\n        \"\"\"\n        if not methods or not auth_types:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n            return\n\n        _check_auth_type(auth_types, [\"commands\", \"exec\"])\n\n        methods_with_group = _check_group_methods(methods)\n\n        command_output = self.instance_commands[0].json_output\n\n        not_matching = []\n\n        for auth_type in auth_types:\n            auth_type_key = f\"{auth_type}AuthzMethods\"\n\n            method_key = list(command_output[auth_type_key].keys())[0]\n\n            if command_output[auth_type_key][method_key][\"methods\"] != methods_with_group:\n                not_matching.append(auth_type)\n\n        if not not_matching:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"AAA authorization methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAuthzMethods.test","title":"<code>test(methods=None, auth_types=None)</code>","text":"<p>Run VerifyAuthzMethods validation.</p> <p>Parameters:</p> Name Type Description Default <code>methods</code> <code>Optional[List[str]]</code> <p>List of AAA authorization methods. Methods should be in the right order.</p> <code>None</code> <code>auth_types</code> <code>Optional[List[str]]</code> <p>List of authorization types to verify. List elements must be: commands, exec.</p> <code>None</code> Source code in <code>anta/tests/aaa.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyAuthzMethods validation.\n\n    Args:\n        methods: List of AAA authorization methods. Methods should be in the right order.\n        auth_types: List of authorization types to verify. List elements must be: commands, exec.\n    \"\"\"\n    if not methods or not auth_types:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n        return\n\n    _check_auth_type(auth_types, [\"commands\", \"exec\"])\n\n    methods_with_group = _check_group_methods(methods)\n\n    command_output = self.instance_commands[0].json_output\n\n    not_matching = []\n\n    for auth_type in auth_types:\n        auth_type_key = f\"{auth_type}AuthzMethods\"\n\n        method_key = list(command_output[auth_type_key].keys())[0]\n\n        if command_output[auth_type_key][method_key][\"methods\"] != methods_with_group:\n            not_matching.append(auth_type)\n\n    if not not_matching:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"AAA authorization methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsServerGroups","title":"<code>VerifyTacacsServerGroups</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if the provided TACACS server group(s) are configured.</p> Expected Results <ul> <li>success: The test will pass if the provided TACACS server group(s) are configured.</li> <li>failure: The test will fail if one or all the provided TACACS server group(s) are NOT configured.</li> <li>skipped: The test will be skipped if TACACS server group(s) are not provided.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyTacacsServerGroups(AntaTest):\n\"\"\"\n    Verifies if the provided TACACS server group(s) are configured.\n\n    Expected Results:\n        * success: The test will pass if the provided TACACS server group(s) are configured.\n        * failure: The test will fail if one or all the provided TACACS server group(s) are NOT configured.\n        * skipped: The test will be skipped if TACACS server group(s) are not provided.\n    \"\"\"\n\n    name = \"VerifyTacacsServerGroups\"\n    description = \"Verifies if the provided TACACS server group(s) are configured.\"\n    categories = [\"aaa\"]\n    commands = [AntaCommand(command=\"show tacacs\")]\n\n    @AntaTest.anta_test\n    def test(self, groups: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyTacacsServerGroups validation.\n\n        Args:\n            groups: List of TACACS server group.\n        \"\"\"\n        if not groups:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because groups were not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        tacacs_groups = command_output[\"groups\"]\n\n        if not tacacs_groups:\n            self.result.is_failure(\"No TACACS server group(s) are configured\")\n            return\n\n        not_configured = [group for group in groups if group not in tacacs_groups]\n\n        if not not_configured:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"TACACS server group(s) {not_configured} are not configured\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsServerGroups.test","title":"<code>test(groups=None)</code>","text":"<p>Run VerifyTacacsServerGroups validation.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>Optional[List[str]]</code> <p>List of TACACS server group.</p> <code>None</code> Source code in <code>anta/tests/aaa.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, groups: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyTacacsServerGroups validation.\n\n    Args:\n        groups: List of TACACS server group.\n    \"\"\"\n    if not groups:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because groups were not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    tacacs_groups = command_output[\"groups\"]\n\n    if not tacacs_groups:\n        self.result.is_failure(\"No TACACS server group(s) are configured\")\n        return\n\n    not_configured = [group for group in groups if group not in tacacs_groups]\n\n    if not not_configured:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"TACACS server group(s) {not_configured} are not configured\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsServers","title":"<code>VerifyTacacsServers</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies TACACS servers are configured for a specified VRF.</p> Expected Results <ul> <li>success: The test will pass if the provided TACACS servers are configured in the specified VRF.</li> <li>failure: The test will fail if the provided TACACS servers are NOT configured in the specified VRF.</li> <li>skipped: The test will be skipped if TACACS servers or VRF are not provided.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyTacacsServers(AntaTest):\n\"\"\"\n    Verifies TACACS servers are configured for a specified VRF.\n\n    Expected Results:\n        * success: The test will pass if the provided TACACS servers are configured in the specified VRF.\n        * failure: The test will fail if the provided TACACS servers are NOT configured in the specified VRF.\n        * skipped: The test will be skipped if TACACS servers or VRF are not provided.\n    \"\"\"\n\n    name = \"VerifyTacacsServers\"\n    description = \"Verifies TACACS servers are configured for a specified VRF.\"\n    categories = [\"aaa\"]\n    commands = [AntaCommand(command=\"show tacacs\")]\n\n    @AntaTest.anta_test\n    def test(self, servers: Optional[List[str]] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifyTacacsServers validation.\n\n        Args:\n            servers: List of TACACS servers IP addresses.\n            vrf: The name of the VRF to transport TACACS messages. Defaults to 'default'.\n        \"\"\"\n        if not servers or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because servers or vrf were not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        tacacs_servers = command_output[\"tacacsServers\"]\n\n        if not tacacs_servers:\n            self.result.is_failure(\"No TACACS servers are configured\")\n            return\n\n        not_configured = [\n            server\n            for server in servers\n            if not any(server == tacacs_server[\"serverInfo\"][\"hostname\"] and vrf == tacacs_server[\"serverInfo\"][\"vrf\"] for tacacs_server in tacacs_servers)\n        ]\n\n        if not not_configured:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"TACACS servers {not_configured} are not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsServers.test","title":"<code>test(servers=None, vrf='default')</code>","text":"<p>Run VerifyTacacsServers validation.</p> <p>Parameters:</p> Name Type Description Default <code>servers</code> <code>Optional[List[str]]</code> <p>List of TACACS servers IP addresses.</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF to transport TACACS messages. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/aaa.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, servers: Optional[List[str]] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifyTacacsServers validation.\n\n    Args:\n        servers: List of TACACS servers IP addresses.\n        vrf: The name of the VRF to transport TACACS messages. Defaults to 'default'.\n    \"\"\"\n    if not servers or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because servers or vrf were not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    tacacs_servers = command_output[\"tacacsServers\"]\n\n    if not tacacs_servers:\n        self.result.is_failure(\"No TACACS servers are configured\")\n        return\n\n    not_configured = [\n        server\n        for server in servers\n        if not any(server == tacacs_server[\"serverInfo\"][\"hostname\"] and vrf == tacacs_server[\"serverInfo\"][\"vrf\"] for tacacs_server in tacacs_servers)\n    ]\n\n    if not not_configured:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"TACACS servers {not_configured} are not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsSourceIntf","title":"<code>VerifyTacacsSourceIntf</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies TACACS source-interface for a specified VRF.</p> Expected Results <ul> <li>success: The test will pass if the provided TACACS source-interface is configured in the specified VRF.</li> <li>failure: The test will fail if the provided TACACS source-interface is NOT configured in the specified VRF.</li> <li>skipped: The test will be skipped if source-interface or VRF is not provided.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyTacacsSourceIntf(AntaTest):\n\"\"\"\n    Verifies TACACS source-interface for a specified VRF.\n\n    Expected Results:\n        * success: The test will pass if the provided TACACS source-interface is configured in the specified VRF.\n        * failure: The test will fail if the provided TACACS source-interface is NOT configured in the specified VRF.\n        * skipped: The test will be skipped if source-interface or VRF is not provided.\n    \"\"\"\n\n    name = \"VerifyTacacsSourceIntf\"\n    description = \"Verifies TACACS source-interface for a specified VRF.\"\n    categories = [\"aaa\"]\n    commands = [AntaCommand(command=\"show tacacs\")]\n\n    @AntaTest.anta_test\n    def test(self, intf: Optional[str] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifyTacacsSourceIntf validation.\n\n        Args:\n            intf: Source-interface to use as source IP of TACACS messages.\n            vrf: The name of the VRF to transport TACACS messages. Defaults to 'default'.\n        \"\"\"\n        if not intf or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because intf or vrf was not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        try:\n            if command_output[\"srcIntf\"][vrf] == intf:\n                self.result.is_success()\n            else:\n                self.result.is_failure(f\"Wrong source-interface configured in VRF {vrf}\")\n\n        except KeyError:\n            self.result.is_failure(f\"Source-interface {intf} is not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsSourceIntf.test","title":"<code>test(intf=None, vrf='default')</code>","text":"<p>Run VerifyTacacsSourceIntf validation.</p> <p>Parameters:</p> Name Type Description Default <code>intf</code> <code>Optional[str]</code> <p>Source-interface to use as source IP of TACACS messages.</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF to transport TACACS messages. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/aaa.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, intf: Optional[str] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifyTacacsSourceIntf validation.\n\n    Args:\n        intf: Source-interface to use as source IP of TACACS messages.\n        vrf: The name of the VRF to transport TACACS messages. Defaults to 'default'.\n    \"\"\"\n    if not intf or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because intf or vrf was not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    try:\n        if command_output[\"srcIntf\"][vrf] == intf:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Wrong source-interface configured in VRF {vrf}\")\n\n    except KeyError:\n        self.result.is_failure(f\"Source-interface {intf} is not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.configuration/","title":"Configuration","text":""},{"location":"api/tests.configuration/#anta-catalog-for-configuration-tests","title":"ANTA catalog for configuration tests","text":"<p>Test functions related to the device configuration</p>"},{"location":"api/tests.configuration/#anta.tests.configuration.VerifyRunningConfigDiffs","title":"<code>VerifyRunningConfigDiffs</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies there is no difference between the running-config and the startup-config.</p> Source code in <code>anta/tests/configuration.py</code> <pre><code>class VerifyRunningConfigDiffs(AntaTest):\n\"\"\"\n    Verifies there is no difference between the running-config and the startup-config.\n    \"\"\"\n\n    name = \"VerifyRunningConfigDiffs\"\n    description = \"\"\n    categories = [\"configuration\"]\n    commands = [AntaCommand(command=\"show running-config diffs\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyRunningConfigDiffs validation\"\"\"\n        command_output = self.instance_commands[0].output\n        if command_output is None or command_output == \"\":\n            self.result.is_success()\n        else:\n            self.result.is_failure()\n            self.result.is_failure(str(command_output))\n</code></pre>"},{"location":"api/tests.configuration/#anta.tests.configuration.VerifyRunningConfigDiffs.test","title":"<code>test()</code>","text":"<p>Run VerifyRunningConfigDiffs validation</p> Source code in <code>anta/tests/configuration.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyRunningConfigDiffs validation\"\"\"\n    command_output = self.instance_commands[0].output\n    if command_output is None or command_output == \"\":\n        self.result.is_success()\n    else:\n        self.result.is_failure()\n        self.result.is_failure(str(command_output))\n</code></pre>"},{"location":"api/tests.configuration/#anta.tests.configuration.VerifyZeroTouch","title":"<code>VerifyZeroTouch</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies ZeroTouch is disabled.</p> Source code in <code>anta/tests/configuration.py</code> <pre><code>class VerifyZeroTouch(AntaTest):\n\"\"\"\n    Verifies ZeroTouch is disabled.\n    \"\"\"\n\n    name = \"VerifyZeroTouch\"\n    description = \"Verifies ZeroTouch is disabled.\"\n    categories = [\"configuration\"]\n    commands = [AntaCommand(command=\"show zerotouch\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyZeroTouch validation\"\"\"\n\n        command_output = self.instance_commands[0].output\n\n        assert isinstance(command_output, dict)\n        if command_output[\"mode\"] == \"disabled\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"ZTP is NOT disabled\")\n</code></pre>"},{"location":"api/tests.configuration/#anta.tests.configuration.VerifyZeroTouch.test","title":"<code>test()</code>","text":"<p>Run VerifyZeroTouch validation</p> Source code in <code>anta/tests/configuration.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyZeroTouch validation\"\"\"\n\n    command_output = self.instance_commands[0].output\n\n    assert isinstance(command_output, dict)\n    if command_output[\"mode\"] == \"disabled\":\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"ZTP is NOT disabled\")\n</code></pre>"},{"location":"api/tests.connectivity/","title":"Connectivity","text":""},{"location":"api/tests.connectivity/#anta-catalog-for-connectivity-tests","title":"ANTA catalog for connectivity tests","text":"<p>Test functions related to various connectivity checks</p>"},{"location":"api/tests.connectivity/#anta.tests.connectivity.VerifyReachability","title":"<code>VerifyReachability</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Test network reachability to one or many destination IP(s).</p> Expected Results <ul> <li>success: The test will pass if all destination IP(s) are reachable.</li> <li>failure: The test will fail if one or many destination IP(s) are unreachable.</li> <li>error: The test will give an error if the destination IP(s) or the source interface/IP(s) are not provided as template_params.</li> </ul> Source code in <code>anta/tests/connectivity.py</code> <pre><code>class VerifyReachability(AntaTest):\n\"\"\"\n    Test network reachability to one or many destination IP(s).\n\n    Expected Results:\n        * success: The test will pass if all destination IP(s) are reachable.\n        * failure: The test will fail if one or many destination IP(s) are unreachable.\n        * error: The test will give an error if the destination IP(s) or the source interface/IP(s) are not provided as template_params.\n    \"\"\"\n\n    name = \"VerifyReachability\"\n    description = \"Test the network reachability to one or many destination IP(s).\"\n    categories = [\"connectivity\"]\n    template = AntaTemplate(template=\"ping {dst} source {src} repeat 2\")\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyReachability validation.\n        \"\"\"\n\n        failures = []\n\n        for command in self.instance_commands:\n            if command.params and (\"src\" and \"dst\") in command.params:\n                src, dst = command.params[\"src\"], command.params[\"dst\"]\n            else:\n                self.result.is_error(\"The destination IP(s) or the source interface/IP(s) are not provided as template_params\")\n                return\n\n            if \"2 received\" not in command.json_output[\"messages\"][0]:\n                failures.append((src, dst))\n\n        if not failures:\n            self.result.is_success()\n\n        else:\n            self.result.is_failure(f\"Connectivity test failed for the following source-destination pairs: {failures}\")\n</code></pre>"},{"location":"api/tests.connectivity/#anta.tests.connectivity.VerifyReachability.test","title":"<code>test()</code>","text":"<p>Run VerifyReachability validation.</p> Source code in <code>anta/tests/connectivity.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyReachability validation.\n    \"\"\"\n\n    failures = []\n\n    for command in self.instance_commands:\n        if command.params and (\"src\" and \"dst\") in command.params:\n            src, dst = command.params[\"src\"], command.params[\"dst\"]\n        else:\n            self.result.is_error(\"The destination IP(s) or the source interface/IP(s) are not provided as template_params\")\n            return\n\n        if \"2 received\" not in command.json_output[\"messages\"][0]:\n            failures.append((src, dst))\n\n    if not failures:\n        self.result.is_success()\n\n    else:\n        self.result.is_failure(f\"Connectivity test failed for the following source-destination pairs: {failures}\")\n</code></pre>"},{"location":"api/tests.field_notices/","title":"Field Notices","text":""},{"location":"api/tests.field_notices/#anta-catalog-for-field-notices-tests","title":"ANTA catalog for Field Notices tests","text":"<p>Test functions to flag field notices</p>"},{"location":"api/tests.field_notices/#anta.tests.field_notices.VerifyFieldNotice44Resolution","title":"<code>VerifyFieldNotice44Resolution</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the device is using an Aboot version that fix the bug discussed in the field notice 44 (Aboot manages system settings prior to EOS initialization).</p> <p>https://www.arista.com/en/support/advisories-notices/field-notice/8756-field-notice-44</p> Source code in <code>anta/tests/field_notices.py</code> <pre><code>class VerifyFieldNotice44Resolution(AntaTest):\n\"\"\"\n    Verifies the device is using an Aboot version that fix the bug discussed\n    in the field notice 44 (Aboot manages system settings prior to EOS initialization).\n\n    https://www.arista.com/en/support/advisories-notices/field-notice/8756-field-notice-44\n    \"\"\"\n\n    name = \"VerifyFieldNotice44Resolution\"\n    description = (\n        \"Verifies the device is using an Aboot version that fix the bug discussed in the field notice 44 (Aboot manages system settings prior to EOS initialization)\"\n    )\n    categories = [\"field notices\", \"software\"]\n    commands = [AntaCommand(command=\"show version detail\")]\n\n    # TODO maybe implement ONLY ON PLATFORMS instead\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:  # type: ignore[override]\n\"\"\"Run VerifyFieldNotice44Resolution validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        devices = [\n            \"DCS-7010T-48\",\n            \"DCS-7010T-48-DC\",\n            \"DCS-7050TX-48\",\n            \"DCS-7050TX-64\",\n            \"DCS-7050TX-72\",\n            \"DCS-7050TX-72Q\",\n            \"DCS-7050TX-96\",\n            \"DCS-7050TX2-128\",\n            \"DCS-7050SX-64\",\n            \"DCS-7050SX-72\",\n            \"DCS-7050SX-72Q\",\n            \"DCS-7050SX2-72Q\",\n            \"DCS-7050SX-96\",\n            \"DCS-7050SX2-128\",\n            \"DCS-7050QX-32S\",\n            \"DCS-7050QX2-32S\",\n            \"DCS-7050SX3-48YC12\",\n            \"DCS-7050CX3-32S\",\n            \"DCS-7060CX-32S\",\n            \"DCS-7060CX2-32S\",\n            \"DCS-7060SX2-48YC6\",\n            \"DCS-7160-48YC6\",\n            \"DCS-7160-48TC6\",\n            \"DCS-7160-32CQ\",\n            \"DCS-7280SE-64\",\n            \"DCS-7280SE-68\",\n            \"DCS-7280SE-72\",\n            \"DCS-7150SC-24-CLD\",\n            \"DCS-7150SC-64-CLD\",\n            \"DCS-7020TR-48\",\n            \"DCS-7020TRA-48\",\n            \"DCS-7020SR-24C2\",\n            \"DCS-7020SRG-24C2\",\n            \"DCS-7280TR-48C6\",\n            \"DCS-7280TRA-48C6\",\n            \"DCS-7280SR-48C6\",\n            \"DCS-7280SRA-48C6\",\n            \"DCS-7280SRAM-48C6\",\n            \"DCS-7280SR2K-48C6-M\",\n            \"DCS-7280SR2-48YC6\",\n            \"DCS-7280SR2A-48YC6\",\n            \"DCS-7280SRM-40CX2\",\n            \"DCS-7280QR-C36\",\n            \"DCS-7280QRA-C36S\",\n        ]\n        variants = [\"-SSD-F\", \"-SSD-R\", \"-M-F\", \"-M-R\", \"-F\", \"-R\"]\n\n        model = command_output[\"modelName\"]\n        # TODO this list could be a regex\n        for variant in variants:\n            model = model.replace(variant, \"\")\n        if model not in devices:\n            self.result.is_skipped(\"device is not impacted by FN044\")\n            return\n\n        for component in command_output[\"details\"][\"components\"]:\n            if component[\"name\"] == \"Aboot\":\n                aboot_version = component[\"version\"].split(\"-\")[2]\n        self.result.is_success()\n        if aboot_version.startswith(\"4.0.\") and int(aboot_version.split(\".\")[2]) &lt; 7:\n            self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n        elif aboot_version.startswith(\"4.1.\") and int(aboot_version.split(\".\")[2]) &lt; 1:\n            self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n        elif aboot_version.startswith(\"6.0.\") and int(aboot_version.split(\".\")[2]) &lt; 9:\n            self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n        elif aboot_version.startswith(\"6.1.\") and int(aboot_version.split(\".\")[2]) &lt; 7:\n            self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n</code></pre>"},{"location":"api/tests.field_notices/#anta.tests.field_notices.VerifyFieldNotice44Resolution.test","title":"<code>test()</code>","text":"<p>Run VerifyFieldNotice44Resolution validation</p> Source code in <code>anta/tests/field_notices.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self) -&gt; None:  # type: ignore[override]\n\"\"\"Run VerifyFieldNotice44Resolution validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    devices = [\n        \"DCS-7010T-48\",\n        \"DCS-7010T-48-DC\",\n        \"DCS-7050TX-48\",\n        \"DCS-7050TX-64\",\n        \"DCS-7050TX-72\",\n        \"DCS-7050TX-72Q\",\n        \"DCS-7050TX-96\",\n        \"DCS-7050TX2-128\",\n        \"DCS-7050SX-64\",\n        \"DCS-7050SX-72\",\n        \"DCS-7050SX-72Q\",\n        \"DCS-7050SX2-72Q\",\n        \"DCS-7050SX-96\",\n        \"DCS-7050SX2-128\",\n        \"DCS-7050QX-32S\",\n        \"DCS-7050QX2-32S\",\n        \"DCS-7050SX3-48YC12\",\n        \"DCS-7050CX3-32S\",\n        \"DCS-7060CX-32S\",\n        \"DCS-7060CX2-32S\",\n        \"DCS-7060SX2-48YC6\",\n        \"DCS-7160-48YC6\",\n        \"DCS-7160-48TC6\",\n        \"DCS-7160-32CQ\",\n        \"DCS-7280SE-64\",\n        \"DCS-7280SE-68\",\n        \"DCS-7280SE-72\",\n        \"DCS-7150SC-24-CLD\",\n        \"DCS-7150SC-64-CLD\",\n        \"DCS-7020TR-48\",\n        \"DCS-7020TRA-48\",\n        \"DCS-7020SR-24C2\",\n        \"DCS-7020SRG-24C2\",\n        \"DCS-7280TR-48C6\",\n        \"DCS-7280TRA-48C6\",\n        \"DCS-7280SR-48C6\",\n        \"DCS-7280SRA-48C6\",\n        \"DCS-7280SRAM-48C6\",\n        \"DCS-7280SR2K-48C6-M\",\n        \"DCS-7280SR2-48YC6\",\n        \"DCS-7280SR2A-48YC6\",\n        \"DCS-7280SRM-40CX2\",\n        \"DCS-7280QR-C36\",\n        \"DCS-7280QRA-C36S\",\n    ]\n    variants = [\"-SSD-F\", \"-SSD-R\", \"-M-F\", \"-M-R\", \"-F\", \"-R\"]\n\n    model = command_output[\"modelName\"]\n    # TODO this list could be a regex\n    for variant in variants:\n        model = model.replace(variant, \"\")\n    if model not in devices:\n        self.result.is_skipped(\"device is not impacted by FN044\")\n        return\n\n    for component in command_output[\"details\"][\"components\"]:\n        if component[\"name\"] == \"Aboot\":\n            aboot_version = component[\"version\"].split(\"-\")[2]\n    self.result.is_success()\n    if aboot_version.startswith(\"4.0.\") and int(aboot_version.split(\".\")[2]) &lt; 7:\n        self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n    elif aboot_version.startswith(\"4.1.\") and int(aboot_version.split(\".\")[2]) &lt; 1:\n        self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n    elif aboot_version.startswith(\"6.0.\") and int(aboot_version.split(\".\")[2]) &lt; 9:\n        self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n    elif aboot_version.startswith(\"6.1.\") and int(aboot_version.split(\".\")[2]) &lt; 7:\n        self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n</code></pre>"},{"location":"api/tests.field_notices/#anta.tests.field_notices.VerifyFieldNotice72Resolution","title":"<code>VerifyFieldNotice72Resolution</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Checks if the device is potentially exposed to Field Notice 72, and if the issue has been mitigated.</p> <p>https://www.arista.com/en/support/advisories-notices/field-notice/17410-field-notice-0072</p> Source code in <code>anta/tests/field_notices.py</code> <pre><code>class VerifyFieldNotice72Resolution(AntaTest):\n\"\"\"\n    Checks if the device is potentially exposed to Field Notice 72, and if the issue has been mitigated.\n\n    https://www.arista.com/en/support/advisories-notices/field-notice/17410-field-notice-0072\n    \"\"\"\n\n    name = \"VerifyFieldNotice72Resolution\"\n    description = \"Verifies if the device has exposeure to FN72, and if the issue has been mitigated\"\n    categories = [\"field notices\", \"software\"]\n    commands = [AntaCommand(command=\"show version detail\")]\n\n    # TODO maybe implement ONLY ON PLATFORMS instead\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:  # type: ignore[override]\n\"\"\"Run VerifyFieldNotice72Resolution validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        devices = [\"DCS-7280SR3-48YC8\", \"DCS-7280SR3K-48YC8\"]\n        variants = [\"-SSD-F\", \"-SSD-R\", \"-M-F\", \"-M-R\", \"-F\", \"-R\"]\n        model = command_output[\"modelName\"]\n\n        for variant in variants:\n            model = model.replace(variant, \"\")\n        if model not in devices:\n            self.result.is_skipped(\"Platform is not impacted by FN072\")\n            return\n\n        serial = command_output[\"serialNumber\"]\n        number = int(serial[3:7])\n\n        if \"JPE\" not in serial and \"JAS\" not in serial:\n            self.result.is_skipped(\"Device not exposed\")\n            return\n\n        if model == \"DCS-7280SR3-48YC8\" and \"JPE\" in serial and number &gt;= 2131:\n            self.result.is_skipped(\"Device not exposed\")\n            return\n\n        if model == \"DCS-7280SR3-48YC8\" and \"JAS\" in serial and number &gt;= 2041:\n            self.result.is_skipped(\"Device not exposed\")\n            return\n\n        if model == \"DCS-7280SR3K-48YC8\" and \"JPE\" in serial and number &gt;= 2134:\n            self.result.is_skipped(\"Device not exposed\")\n            return\n\n        if model == \"DCS-7280SR3K-48YC8\" and \"JAS\" in serial and number &gt;= 2041:\n            self.result.is_skipped(\"Device not exposed\")\n            return\n\n        # Because each of the if checks above will return if taken, we only run the long\n        # check if we get this far\n        for entry in command_output[\"details\"][\"components\"]:\n            if entry[\"name\"] == \"FixedSystemvrm1\":\n                if int(entry[\"version\"]) &lt; 7:\n                    self.result.is_failure(\"Device is exposed to FN72\")\n                else:\n                    self.result.is_success(\"FN72 is mitigated\")\n                return\n        # We should never hit this point\n        self.result.is_error(\"Error in running test - FixedSystemvrm1 not found\")\n        return\n</code></pre>"},{"location":"api/tests.field_notices/#anta.tests.field_notices.VerifyFieldNotice72Resolution.test","title":"<code>test()</code>","text":"<p>Run VerifyFieldNotice72Resolution validation</p> Source code in <code>anta/tests/field_notices.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self) -&gt; None:  # type: ignore[override]\n\"\"\"Run VerifyFieldNotice72Resolution validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    devices = [\"DCS-7280SR3-48YC8\", \"DCS-7280SR3K-48YC8\"]\n    variants = [\"-SSD-F\", \"-SSD-R\", \"-M-F\", \"-M-R\", \"-F\", \"-R\"]\n    model = command_output[\"modelName\"]\n\n    for variant in variants:\n        model = model.replace(variant, \"\")\n    if model not in devices:\n        self.result.is_skipped(\"Platform is not impacted by FN072\")\n        return\n\n    serial = command_output[\"serialNumber\"]\n    number = int(serial[3:7])\n\n    if \"JPE\" not in serial and \"JAS\" not in serial:\n        self.result.is_skipped(\"Device not exposed\")\n        return\n\n    if model == \"DCS-7280SR3-48YC8\" and \"JPE\" in serial and number &gt;= 2131:\n        self.result.is_skipped(\"Device not exposed\")\n        return\n\n    if model == \"DCS-7280SR3-48YC8\" and \"JAS\" in serial and number &gt;= 2041:\n        self.result.is_skipped(\"Device not exposed\")\n        return\n\n    if model == \"DCS-7280SR3K-48YC8\" and \"JPE\" in serial and number &gt;= 2134:\n        self.result.is_skipped(\"Device not exposed\")\n        return\n\n    if model == \"DCS-7280SR3K-48YC8\" and \"JAS\" in serial and number &gt;= 2041:\n        self.result.is_skipped(\"Device not exposed\")\n        return\n\n    # Because each of the if checks above will return if taken, we only run the long\n    # check if we get this far\n    for entry in command_output[\"details\"][\"components\"]:\n        if entry[\"name\"] == \"FixedSystemvrm1\":\n            if int(entry[\"version\"]) &lt; 7:\n                self.result.is_failure(\"Device is exposed to FN72\")\n            else:\n                self.result.is_success(\"FN72 is mitigated\")\n            return\n    # We should never hit this point\n    self.result.is_error(\"Error in running test - FixedSystemvrm1 not found\")\n    return\n</code></pre>"},{"location":"api/tests.hardware/","title":"Hardware","text":""},{"location":"api/tests.hardware/#anta-catalog-for-hardware-tests","title":"ANTA catalog for hardware tests","text":"<p>Test functions related to the hardware or environement</p>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyAdverseDrops","title":"<code>VerifyAdverseDrops</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies there is no adverse drops on DCS7280E and DCS7500E.</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyAdverseDrops(AntaTest):\n\"\"\"\n    Verifies there is no adverse drops on DCS7280E and DCS7500E.\n    \"\"\"\n\n    name = \"VerifyAdverseDrops\"\n    description = \"Verifies there is no adverse drops on DCS7280E and DCS7500E\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show hardware counter drop\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyAdverseDrops validation\"\"\"\n        command_output = self.instance_commands[0].json_output\n        total_adverse_drop = command_output[\"totalAdverseDrops\"] if \"totalAdverseDrops\" in command_output.keys() else \"\"\n        if total_adverse_drop == 0:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device TotalAdverseDrops counter is {total_adverse_drop}\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyAdverseDrops.test","title":"<code>test()</code>","text":"<p>Run VerifyAdverseDrops validation</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyAdverseDrops validation\"\"\"\n    command_output = self.instance_commands[0].json_output\n    total_adverse_drop = command_output[\"totalAdverseDrops\"] if \"totalAdverseDrops\" in command_output.keys() else \"\"\n    if total_adverse_drop == 0:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Device TotalAdverseDrops counter is {total_adverse_drop}\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentCooling","title":"<code>VerifyEnvironmentCooling</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the fans status is in the accepted states list.</p> <p>Default accepted states list is [\u2018ok\u2019]</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyEnvironmentCooling(AntaTest):\n\"\"\"\n    Verifies the fans status is in the accepted states list.\n\n    Default accepted states list is ['ok']\n    \"\"\"\n\n    name = \"VerifyEnvironmentCooling\"\n    description = \"Verifies the fans status is OK for fans\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show system environment cooling\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self, accepted_states: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyEnvironmentCooling validation\n\n        Args:\n            accepted_states: Accepted states list for fan status\n        \"\"\"\n        if accepted_states is None:\n            accepted_states = [\"ok\"]\n\n        command_output = self.instance_commands[0].json_output\n        self.result.is_success()\n        # First go through power supplies fans\n        for power_supply in command_output.get(\"powerSupplySlots\", []):\n            for fan in power_supply.get(\"fans\", []):\n                if (state := fan[\"status\"]) not in accepted_states:\n                    if self.result.result == \"success\":\n                        self.result.is_failure(f\"Some fans state are not in the accepted list: {accepted_states}.\")\n                    self.result.is_failure(f\"Fan {fan['label']} on PowerSupply {power_supply['label']} has state '{state}'.\")\n        # Then go through Fan Trays\n        for fan_tray in command_output.get(\"fanTraySlots\", []):\n            for fan in fan_tray.get(\"fans\", []):\n                if (state := fan[\"status\"]) not in accepted_states:\n                    if self.result.result == \"success\":\n                        self.result.is_failure(f\"Some fans state are not in the accepted list: {accepted_states}.\")\n                    self.result.is_failure(f\"Fan {fan['label']} on Fan Tray {fan_tray['label']} has state '{state}'.\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentCooling.test","title":"<code>test(accepted_states=None)</code>","text":"<p>Run VerifyEnvironmentCooling validation</p> <p>Parameters:</p> Name Type Description Default <code>accepted_states</code> <code>Optional[List[str]]</code> <p>Accepted states list for fan status</p> <code>None</code> Source code in <code>anta/tests/hardware.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self, accepted_states: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyEnvironmentCooling validation\n\n    Args:\n        accepted_states: Accepted states list for fan status\n    \"\"\"\n    if accepted_states is None:\n        accepted_states = [\"ok\"]\n\n    command_output = self.instance_commands[0].json_output\n    self.result.is_success()\n    # First go through power supplies fans\n    for power_supply in command_output.get(\"powerSupplySlots\", []):\n        for fan in power_supply.get(\"fans\", []):\n            if (state := fan[\"status\"]) not in accepted_states:\n                if self.result.result == \"success\":\n                    self.result.is_failure(f\"Some fans state are not in the accepted list: {accepted_states}.\")\n                self.result.is_failure(f\"Fan {fan['label']} on PowerSupply {power_supply['label']} has state '{state}'.\")\n    # Then go through Fan Trays\n    for fan_tray in command_output.get(\"fanTraySlots\", []):\n        for fan in fan_tray.get(\"fans\", []):\n            if (state := fan[\"status\"]) not in accepted_states:\n                if self.result.result == \"success\":\n                    self.result.is_failure(f\"Some fans state are not in the accepted list: {accepted_states}.\")\n                self.result.is_failure(f\"Fan {fan['label']} on Fan Tray {fan_tray['label']} has state '{state}'.\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentPower","title":"<code>VerifyEnvironmentPower</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the power supplies status is in the accepted states list</p> <p>The default accepted states list is [\u2018ok\u2019]</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyEnvironmentPower(AntaTest):\n\"\"\"\n    Verifies the power supplies status is in the accepted states list\n\n    The default accepted states list is ['ok']\n    \"\"\"\n\n    name = \"VerifyEnvironmentPower\"\n    description = \"Verifies the power supplies status is OK\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show system environment power\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self, accepted_states: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyEnvironmentPower validation\n\n        Args:\n            accepted_states: Accepted states list for power supplies\n        \"\"\"\n        if accepted_states is None:\n            accepted_states = [\"ok\"]\n        command_output = self.instance_commands[0].json_output\n        power_supplies = command_output[\"powerSupplies\"] if \"powerSupplies\" in command_output.keys() else \"{}\"\n        wrong_power_supplies = {\n            powersupply: {\"state\": value[\"state\"]} for powersupply, value in dict(power_supplies).items() if value[\"state\"] not in accepted_states\n        }\n        if not wrong_power_supplies:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following power supplies states are not in the accepted_states list {accepted_states}\")\n            self.result.messages.append(str(wrong_power_supplies))\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentPower.test","title":"<code>test(accepted_states=None)</code>","text":"<p>Run VerifyEnvironmentPower validation</p> <p>Parameters:</p> Name Type Description Default <code>accepted_states</code> <code>Optional[List[str]]</code> <p>Accepted states list for power supplies</p> <code>None</code> Source code in <code>anta/tests/hardware.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self, accepted_states: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyEnvironmentPower validation\n\n    Args:\n        accepted_states: Accepted states list for power supplies\n    \"\"\"\n    if accepted_states is None:\n        accepted_states = [\"ok\"]\n    command_output = self.instance_commands[0].json_output\n    power_supplies = command_output[\"powerSupplies\"] if \"powerSupplies\" in command_output.keys() else \"{}\"\n    wrong_power_supplies = {\n        powersupply: {\"state\": value[\"state\"]} for powersupply, value in dict(power_supplies).items() if value[\"state\"] not in accepted_states\n    }\n    if not wrong_power_supplies:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following power supplies states are not in the accepted_states list {accepted_states}\")\n        self.result.messages.append(str(wrong_power_supplies))\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentSystemCooling","title":"<code>VerifyEnvironmentSystemCooling</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the System Cooling is ok.</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyEnvironmentSystemCooling(AntaTest):\n\"\"\"\n    Verifies the System Cooling is ok.\n    \"\"\"\n\n    name = \"VerifyEnvironmentSystemCooling\"\n    description = \"Verifies the fans status is OK for fans\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show system environment cooling\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyEnvironmentCooling validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n        sys_status = command_output[\"systemStatus\"] if \"systemStatus\" in command_output.keys() else \"\"\n\n        self.result.is_success()\n        if sys_status != \"coolingOk\":\n            self.result.is_failure(f\"Device System cooling is not OK: {sys_status}\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentSystemCooling.test","title":"<code>test()</code>","text":"<p>Run VerifyEnvironmentCooling validation</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyEnvironmentCooling validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n    sys_status = command_output[\"systemStatus\"] if \"systemStatus\" in command_output.keys() else \"\"\n\n    self.result.is_success()\n    if sys_status != \"coolingOk\":\n        self.result.is_failure(f\"Device System cooling is not OK: {sys_status}\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyTemperature","title":"<code>VerifyTemperature</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies device temparture is currently OK (temperatureOK).</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyTemperature(AntaTest):\n\"\"\"\n    Verifies device temparture is currently OK (temperatureOK).\n    \"\"\"\n\n    name = \"VerifyTemperature\"\n    description = \"Verifies device temparture is currently OK (temperatureOK)\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show system environment temperature\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyTemperature validation\"\"\"\n        command_output = self.instance_commands[0].json_output\n        temperature_status = command_output[\"systemStatus\"] if \"systemStatus\" in command_output.keys() else \"\"\n        if temperature_status == \"temperatureOk\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device temperature is not OK, systemStatus: {temperature_status }\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyTemperature.test","title":"<code>test()</code>","text":"<p>Run VerifyTemperature validation</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyTemperature validation\"\"\"\n    command_output = self.instance_commands[0].json_output\n    temperature_status = command_output[\"systemStatus\"] if \"systemStatus\" in command_output.keys() else \"\"\n    if temperature_status == \"temperatureOk\":\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Device temperature is not OK, systemStatus: {temperature_status }\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyTransceiversManufacturers","title":"<code>VerifyTransceiversManufacturers</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies Manufacturers of all Transceivers.</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyTransceiversManufacturers(AntaTest):\n\"\"\"\n    Verifies Manufacturers of all Transceivers.\n    \"\"\"\n\n    name = \"VerifyTransceiversManufacturers\"\n    description = \"\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show inventory\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self, manufacturers: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyTransceiversManufacturers validation\n\n        Args:\n            manufacturers: List of allowed transceivers manufacturers.\n        \"\"\"\n        if not manufacturers:\n            self.result.is_skipped(f\"{self.__class__.name} was not run as no manufacturers were given\")\n        else:\n            command_output = self.instance_commands[0].json_output\n            wrong_manufacturers = {interface: value[\"mfgName\"] for interface, value in command_output[\"xcvrSlots\"].items() if value[\"mfgName\"] not in manufacturers}\n            if not wrong_manufacturers:\n                self.result.is_success()\n            else:\n                self.result.is_failure(\"The following interfaces have transceivers from unauthorized manufacturers\")\n                self.result.messages.append(str(wrong_manufacturers))\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyTransceiversManufacturers.test","title":"<code>test(manufacturers=None)</code>","text":"<p>Run VerifyTransceiversManufacturers validation</p> <p>Parameters:</p> Name Type Description Default <code>manufacturers</code> <code>Optional[List[str]]</code> <p>List of allowed transceivers manufacturers.</p> <code>None</code> Source code in <code>anta/tests/hardware.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self, manufacturers: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyTransceiversManufacturers validation\n\n    Args:\n        manufacturers: List of allowed transceivers manufacturers.\n    \"\"\"\n    if not manufacturers:\n        self.result.is_skipped(f\"{self.__class__.name} was not run as no manufacturers were given\")\n    else:\n        command_output = self.instance_commands[0].json_output\n        wrong_manufacturers = {interface: value[\"mfgName\"] for interface, value in command_output[\"xcvrSlots\"].items() if value[\"mfgName\"] not in manufacturers}\n        if not wrong_manufacturers:\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"The following interfaces have transceivers from unauthorized manufacturers\")\n            self.result.messages.append(str(wrong_manufacturers))\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyTransceiversTemperature","title":"<code>VerifyTransceiversTemperature</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies Transceivers temperature is currently OK.</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyTransceiversTemperature(AntaTest):\n\"\"\"\n    Verifies Transceivers temperature is currently OK.\n    \"\"\"\n\n    name = \"VerifyTransceiversTemperature\"\n    description = \"Verifies Transceivers temperature is currently OK\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show system environment temperature transceiver\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyTransceiversTemperature validation\"\"\"\n        command_output = self.instance_commands[0].json_output\n        sensors = command_output[\"tempSensors\"] if \"tempSensors\" in command_output.keys() else \"\"\n        wrong_sensors = {\n            sensor[\"name\"]: {\n                \"hwStatus\": sensor[\"hwStatus\"],\n                \"alertCount\": sensor[\"alertCount\"],\n            }\n            for sensor in sensors\n            if sensor[\"hwStatus\"] != \"ok\" or sensor[\"alertCount\"] != 0\n        }\n        if not wrong_sensors:\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"The following sensors do not have the correct temperature or had alarms in the past:\")\n            self.result.messages.append(str(wrong_sensors))\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyTransceiversTemperature.test","title":"<code>test()</code>","text":"<p>Run VerifyTransceiversTemperature validation</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyTransceiversTemperature validation\"\"\"\n    command_output = self.instance_commands[0].json_output\n    sensors = command_output[\"tempSensors\"] if \"tempSensors\" in command_output.keys() else \"\"\n    wrong_sensors = {\n        sensor[\"name\"]: {\n            \"hwStatus\": sensor[\"hwStatus\"],\n            \"alertCount\": sensor[\"alertCount\"],\n        }\n        for sensor in sensors\n        if sensor[\"hwStatus\"] != \"ok\" or sensor[\"alertCount\"] != 0\n    }\n    if not wrong_sensors:\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"The following sensors do not have the correct temperature or had alarms in the past:\")\n        self.result.messages.append(str(wrong_sensors))\n</code></pre>"},{"location":"api/tests.interfaces/","title":"Interfaces","text":""},{"location":"api/tests.interfaces/#anta-catalog-for-interfaces-tests","title":"ANTA catalog for interfaces tests","text":"<p>Test functions related to the device interfaces</p>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyIPProxyARP","title":"<code>VerifyIPProxyARP</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if Proxy-ARP is enabled for the provided list of interface(s).</p> Expected Results <ul> <li>success: The test will pass if Proxy-ARP is enabled on the specified interface(s).</li> <li>failure: The test will fail if Proxy-ARP is disabled on the specified interface(s).</li> <li>error: The test will give an error if a list of interface(s) is not provided as template_params.</li> </ul> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyIPProxyARP(AntaTest):\n\"\"\"\n    Verifies if Proxy-ARP is enabled for the provided list of interface(s).\n\n    Expected Results:\n        * success: The test will pass if Proxy-ARP is enabled on the specified interface(s).\n        * failure: The test will fail if Proxy-ARP is disabled on the specified interface(s).\n        * error: The test will give an error if a list of interface(s) is not provided as template_params.\n\n    \"\"\"\n\n    name = \"VerifyIPProxyARP\"\n    description = \"Verifies if Proxy-ARP is enabled for the provided list of interface(s).\"\n    categories = [\"interfaces\"]\n    template = AntaTemplate(template=\"show ip interface {intf}\")\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyIPProxyARP validation.\n        \"\"\"\n\n        disabled_intf = []\n        for command in self.instance_commands:\n            if command.params and \"intf\" in command.params:\n                intf = command.params[\"intf\"]\n            if not command.json_output[\"interfaces\"][intf][\"proxyArp\"]:\n                disabled_intf.append(intf)\n\n        if disabled_intf:\n            self.result.is_failure(f\"The following interface(s) have Proxy-ARP disabled: {disabled_intf}\")\n\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyIPProxyARP.test","title":"<code>test()</code>","text":"<p>Run VerifyIPProxyARP validation.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyIPProxyARP validation.\n    \"\"\"\n\n    disabled_intf = []\n    for command in self.instance_commands:\n        if command.params and \"intf\" in command.params:\n            intf = command.params[\"intf\"]\n        if not command.json_output[\"interfaces\"][intf][\"proxyArp\"]:\n            disabled_intf.append(intf)\n\n    if disabled_intf:\n        self.result.is_failure(f\"The following interface(s) have Proxy-ARP disabled: {disabled_intf}\")\n\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyIllegalLACP","title":"<code>VerifyIllegalLACP</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies there is no illegal LACP packets received.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyIllegalLACP(AntaTest):\n\"\"\"\n    Verifies there is no illegal LACP packets received.\n    \"\"\"\n\n    name = \"VerifyIllegalLACP\"\n    description = \"Verifies there is no illegal LACP packets received.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show lacp counters all-ports\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyIllegalLACP validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        po_with_illegal_lacp: List[Dict[str, Dict[str, int]]] = []\n        for portchannel, portchannel_dict in command_output[\"portChannels\"].items():\n            po_with_illegal_lacp.extend(\n                {portchannel: interface} for interface, interface_dict in portchannel_dict[\"interfaces\"].items() if interface_dict[\"illegalRxCount\"] != 0\n            )\n\n        if not po_with_illegal_lacp:\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"The following port-channels have recieved illegal lacp packets on the \" f\"following ports: {po_with_illegal_lacp}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyIllegalLACP.test","title":"<code>test()</code>","text":"<p>Run VerifyIllegalLACP validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyIllegalLACP validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    po_with_illegal_lacp: List[Dict[str, Dict[str, int]]] = []\n    for portchannel, portchannel_dict in command_output[\"portChannels\"].items():\n        po_with_illegal_lacp.extend(\n            {portchannel: interface} for interface, interface_dict in portchannel_dict[\"interfaces\"].items() if interface_dict[\"illegalRxCount\"] != 0\n        )\n\n    if not po_with_illegal_lacp:\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"The following port-channels have recieved illegal lacp packets on the \" f\"following ports: {po_with_illegal_lacp}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceDiscards","title":"<code>VerifyInterfaceDiscards</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies interfaces packet discard counters are equal to zero.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyInterfaceDiscards(AntaTest):\n\"\"\"\n    Verifies interfaces packet discard counters are equal to zero.\n    \"\"\"\n\n    name = \"VerifyInterfaceDiscards\"\n    description = \"Verifies interfaces packet discard counters are equal to zero.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show interfaces counters discards\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceDiscards validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        wrong_interfaces: List[Dict[str, Dict[str, int]]] = []\n\n        for interface, outer_v in command_output[\"interfaces\"].items():\n            wrong_interfaces.extend({interface: outer_v} for counter, value in outer_v.items() if value &gt; 0)\n        if not wrong_interfaces:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following interfaces have non 0 discard counter(s): {wrong_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceDiscards.test","title":"<code>test()</code>","text":"<p>Run VerifyInterfaceDiscards validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceDiscards validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    wrong_interfaces: List[Dict[str, Dict[str, int]]] = []\n\n    for interface, outer_v in command_output[\"interfaces\"].items():\n        wrong_interfaces.extend({interface: outer_v} for counter, value in outer_v.items() if value &gt; 0)\n    if not wrong_interfaces:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following interfaces have non 0 discard counter(s): {wrong_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceErrDisabled","title":"<code>VerifyInterfaceErrDisabled</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies there is no interface in error disable state.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyInterfaceErrDisabled(AntaTest):\n\"\"\"\n    Verifies there is no interface in error disable state.\n    \"\"\"\n\n    name = \"VerifyInterfaceErrDisabled\"\n    description = \"Verifies there is no interface in error disable state.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show interfaces status\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceErrDisabled validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        errdisabled_interfaces = [interface for interface, value in command_output[\"interfaceStatuses\"].items() if value[\"linkStatus\"] == \"errdisabled\"]\n\n        if errdisabled_interfaces:\n            self.result.is_failure(f\"The following interfaces are in error disabled state: {errdisabled_interfaces}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceErrDisabled.test","title":"<code>test()</code>","text":"<p>Run VerifyInterfaceErrDisabled validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceErrDisabled validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    errdisabled_interfaces = [interface for interface, value in command_output[\"interfaceStatuses\"].items() if value[\"linkStatus\"] == \"errdisabled\"]\n\n    if errdisabled_interfaces:\n        self.result.is_failure(f\"The following interfaces are in error disabled state: {errdisabled_interfaces}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceErrors","title":"<code>VerifyInterfaceErrors</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies interfaces error counters are equal to zero.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyInterfaceErrors(AntaTest):\n\"\"\"\n    Verifies interfaces error counters are equal to zero.\n    \"\"\"\n\n    name = \"VerifyInterfaceErrors\"\n    description = \"Verifies interfaces error counters are equal to zero.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show interfaces counters errors\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceUtilization validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        wrong_interfaces: List[Dict[str, Dict[str, int]]] = []\n        for interface, outer_v in command_output[\"interfaceErrorCounters\"].items():\n            wrong_interfaces.extend({interface: outer_v} for counter, value in outer_v.items() if value &gt; 0)\n        if not wrong_interfaces:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following interfaces have non 0 error counter(s): {wrong_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceErrors.test","title":"<code>test()</code>","text":"<p>Run VerifyInterfaceUtilization validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceUtilization validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    wrong_interfaces: List[Dict[str, Dict[str, int]]] = []\n    for interface, outer_v in command_output[\"interfaceErrorCounters\"].items():\n        wrong_interfaces.extend({interface: outer_v} for counter, value in outer_v.items() if value &gt; 0)\n    if not wrong_interfaces:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following interfaces have non 0 error counter(s): {wrong_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceUtilization","title":"<code>VerifyInterfaceUtilization</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies interfaces utilization is below 75%.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyInterfaceUtilization(AntaTest):\n\"\"\"\n    Verifies interfaces utilization is below 75%.\n    \"\"\"\n\n    name = \"VerifyInterfaceUtilization\"\n    description = \"Verifies interfaces utilization is below 75%.\"\n    categories = [\"interfaces\"]\n    # TODO - move from text to json if possible\n    commands = [AntaCommand(command=\"show interfaces counters rates\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceUtilization validation\"\"\"\n\n        command_output = self.instance_commands[0].text_output\n\n        wrong_interfaces = {}\n        for line in command_output.split(\"\\n\")[1:]:\n            if len(line) &gt; 0:\n                if line.split()[-5] == \"-\" or line.split()[-2] == \"-\":\n                    pass\n                elif float(line.split()[-5].replace(\"%\", \"\")) &gt; 75.0:\n                    wrong_interfaces[line.split()[0]] = line.split()[-5]\n                elif float(line.split()[-2].replace(\"%\", \"\")) &gt; 75.0:\n                    wrong_interfaces[line.split()[0]] = line.split()[-2]\n\n        if not wrong_interfaces:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following interfaces have a usage &gt; 75%: {wrong_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceUtilization.test","title":"<code>test()</code>","text":"<p>Run VerifyInterfaceUtilization validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceUtilization validation\"\"\"\n\n    command_output = self.instance_commands[0].text_output\n\n    wrong_interfaces = {}\n    for line in command_output.split(\"\\n\")[1:]:\n        if len(line) &gt; 0:\n            if line.split()[-5] == \"-\" or line.split()[-2] == \"-\":\n                pass\n            elif float(line.split()[-5].replace(\"%\", \"\")) &gt; 75.0:\n                wrong_interfaces[line.split()[0]] = line.split()[-5]\n            elif float(line.split()[-2].replace(\"%\", \"\")) &gt; 75.0:\n                wrong_interfaces[line.split()[0]] = line.split()[-2]\n\n    if not wrong_interfaces:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following interfaces have a usage &gt; 75%: {wrong_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfacesStatus","title":"<code>VerifyInterfacesStatus</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the number of Ethernet interfaces up/up on the device is higher or equal than a value.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyInterfacesStatus(AntaTest):\n\"\"\"\n    Verifies the number of Ethernet interfaces up/up on the device is higher or equal than a value.\n    \"\"\"\n\n    name = \"VerifyInterfacesStatus\"\n    description = \"Verifies the number of Ethernet interfaces up/up on the device is higher or equal than a value.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show interfaces description\")]\n\n    @AntaTest.anta_test\n    def test(self, minimum: Optional[int] = None) -&gt; None:\n\"\"\"\n        Run VerifyInterfacesStatus validation\n\n        Args:\n            minimum: Expected minimum number of Ethernet interfaces up/up.\n        \"\"\"\n\n        if minimum is None or minimum &lt; 0:\n            self.result.is_skipped(f\"VerifyInterfacesStatus was not run as an invalid minimum value was given {minimum}.\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        count_up_up = 0\n        other_ethernet_interfaces = []\n\n        for interface in command_output[\"interfaceDescriptions\"]:\n            interface_dict = command_output[\"interfaceDescriptions\"][interface]\n            if \"Ethernet\" in interface:\n                if re.match(r\"connected|up\", interface_dict[\"lineProtocolStatus\"]) and re.match(r\"connected|up\", interface_dict[\"interfaceStatus\"]):\n                    count_up_up += 1\n                else:\n                    other_ethernet_interfaces.append(interface)\n\n        if count_up_up &gt;= minimum:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Only {count_up_up}, less than {minimum} Ethernet interfaces are UP/UP\")\n            self.result.messages.append(f\"The following Ethernet interfaces are not UP/UP: {other_ethernet_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfacesStatus.test","title":"<code>test(minimum=None)</code>","text":"<p>Run VerifyInterfacesStatus validation</p> <p>Parameters:</p> Name Type Description Default <code>minimum</code> <code>Optional[int]</code> <p>Expected minimum number of Ethernet interfaces up/up.</p> <code>None</code> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, minimum: Optional[int] = None) -&gt; None:\n\"\"\"\n    Run VerifyInterfacesStatus validation\n\n    Args:\n        minimum: Expected minimum number of Ethernet interfaces up/up.\n    \"\"\"\n\n    if minimum is None or minimum &lt; 0:\n        self.result.is_skipped(f\"VerifyInterfacesStatus was not run as an invalid minimum value was given {minimum}.\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    count_up_up = 0\n    other_ethernet_interfaces = []\n\n    for interface in command_output[\"interfaceDescriptions\"]:\n        interface_dict = command_output[\"interfaceDescriptions\"][interface]\n        if \"Ethernet\" in interface:\n            if re.match(r\"connected|up\", interface_dict[\"lineProtocolStatus\"]) and re.match(r\"connected|up\", interface_dict[\"interfaceStatus\"]):\n                count_up_up += 1\n            else:\n                other_ethernet_interfaces.append(interface)\n\n    if count_up_up &gt;= minimum:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Only {count_up_up}, less than {minimum} Ethernet interfaces are UP/UP\")\n        self.result.messages.append(f\"The following Ethernet interfaces are not UP/UP: {other_ethernet_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyL3MTU","title":"<code>VerifyL3MTU</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the global layer 3 Maximum Transfer Unit (MTU) for all layer 3 interfaces.</p> Expected Results <ul> <li>success: The test will pass if all layer 3 interfaces have the proper MTU configured.</li> <li>failure: The test will fail if one or many layer 3 interfaces have the wrong MTU configured.</li> <li>skipped: The test will be skipped if the MTU value is not provided.</li> </ul> Limitations <ul> <li>Only Ethernet, Port-Channel, Vlan interfaces are supported.</li> <li>Other interface types, like Management, Loopback, Vxlan, Tunnel are currently not supported.</li> </ul> <p>https://www.arista.com/en/support/toi/eos-4-23-1f/14388-global-knob-to-set-mtu-for-all-layer-3-interfaces</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyL3MTU(AntaTest):\n\"\"\"\n    Verifies the global layer 3 Maximum Transfer Unit (MTU) for all layer 3 interfaces.\n\n    Expected Results:\n        * success: The test will pass if all layer 3 interfaces have the proper MTU configured.\n        * failure: The test will fail if one or many layer 3 interfaces have the wrong MTU configured.\n        * skipped: The test will be skipped if the MTU value is not provided.\n\n    Limitations:\n        * Only Ethernet, Port-Channel, Vlan interfaces are supported.\n        * Other interface types, like Management, Loopback, Vxlan, Tunnel are currently not supported.\n\n    https://www.arista.com/en/support/toi/eos-4-23-1f/14388-global-knob-to-set-mtu-for-all-layer-3-interfaces\n\n    \"\"\"\n\n    name = \"VerifyL3MTU\"\n    description = \"Verifies the global layer 3 Maximum Transfer Unit (MTU) for all layer 3 interfaces.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show interfaces\")]\n\n    NOT_SUPPORTED_INTERFACES: List[str] = [\"Management\", \"Loopback\", \"Vxlan\", \"Tunnel\"]\n\n    @AntaTest.anta_test\n    def test(self, mtu: int = 1500) -&gt; None:\n\"\"\"\n        Run VerifyL3MTU validation\n\n        Args:\n          mtu: Layer 3 MTU to verify. Defaults to 1500.\n\n        \"\"\"\n\n        if not mtu:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because mtu was not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        wrong_l3mtu_intf = []\n\n        for interface, values in command_output[\"interfaces\"].items():\n            if re.sub(r\"\\d+$\", \"\", interface) not in self.NOT_SUPPORTED_INTERFACES:\n                if values[\"forwardingModel\"] == \"routed\" and values[\"mtu\"] != mtu:\n                    wrong_l3mtu_intf.append(interface)\n\n        if not wrong_l3mtu_intf:\n            self.result.is_success()\n\n        else:\n            self.result.is_failure(f\"The following interface(s) have the wrong MTU configured: {wrong_l3mtu_intf}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyL3MTU.test","title":"<code>test(mtu=1500)</code>","text":"<p>Run VerifyL3MTU validation</p> <p>Parameters:</p> Name Type Description Default <code>mtu</code> <code>int</code> <p>Layer 3 MTU to verify. Defaults to 1500.</p> <code>1500</code> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, mtu: int = 1500) -&gt; None:\n\"\"\"\n    Run VerifyL3MTU validation\n\n    Args:\n      mtu: Layer 3 MTU to verify. Defaults to 1500.\n\n    \"\"\"\n\n    if not mtu:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because mtu was not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    wrong_l3mtu_intf = []\n\n    for interface, values in command_output[\"interfaces\"].items():\n        if re.sub(r\"\\d+$\", \"\", interface) not in self.NOT_SUPPORTED_INTERFACES:\n            if values[\"forwardingModel\"] == \"routed\" and values[\"mtu\"] != mtu:\n                wrong_l3mtu_intf.append(interface)\n\n    if not wrong_l3mtu_intf:\n        self.result.is_success()\n\n    else:\n        self.result.is_failure(f\"The following interface(s) have the wrong MTU configured: {wrong_l3mtu_intf}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyLoopbackCount","title":"<code>VerifyLoopbackCount</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the number of loopback interfaces on the device is the one we expect and if none of the loopback is down.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyLoopbackCount(AntaTest):\n\"\"\"\n    Verifies the number of loopback interfaces on the device is the one we expect and if none of the loopback is down.\n    \"\"\"\n\n    name = \"VerifyLoopbackCount\"\n    description = \"Verifies the number of loopback interfaces on the device is the one we expect and if none of the loopback is down.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show ip interface brief\")]\n\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"\n        Run VerifyLoopbackCount validation\n\n        Args:\n            number: Number of loopback interfaces expected to be present.\n        \"\"\"\n\n        if number is None:\n            self.result.is_skipped(\"VerifyLoopbackCount was not run as no number value was given.\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        loopback_count = 0\n        down_loopback_interfaces = []\n\n        for interface in command_output[\"interfaces\"]:\n            interface_dict = command_output[\"interfaces\"][interface]\n            if \"Loopback\" in interface:\n                loopback_count += 1\n                if not (interface_dict[\"lineProtocolStatus\"] == \"up\" and interface_dict[\"interfaceStatus\"] == \"connected\"):\n                    down_loopback_interfaces.append(interface)\n\n        if loopback_count == number and len(down_loopback_interfaces) == 0:\n            self.result.is_success()\n        else:\n            self.result.is_failure()\n            if loopback_count != number:\n                self.result.is_failure(f\"Found {loopback_count} Loopbacks when expecting {number}\")\n            elif len(down_loopback_interfaces) != 0:\n                self.result.is_failure(f\"The following Loopbacks are not up: {down_loopback_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyLoopbackCount.test","title":"<code>test(number=None)</code>","text":"<p>Run VerifyLoopbackCount validation</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>Number of loopback interfaces expected to be present.</p> <code>None</code> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"\n    Run VerifyLoopbackCount validation\n\n    Args:\n        number: Number of loopback interfaces expected to be present.\n    \"\"\"\n\n    if number is None:\n        self.result.is_skipped(\"VerifyLoopbackCount was not run as no number value was given.\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    loopback_count = 0\n    down_loopback_interfaces = []\n\n    for interface in command_output[\"interfaces\"]:\n        interface_dict = command_output[\"interfaces\"][interface]\n        if \"Loopback\" in interface:\n            loopback_count += 1\n            if not (interface_dict[\"lineProtocolStatus\"] == \"up\" and interface_dict[\"interfaceStatus\"] == \"connected\"):\n                down_loopback_interfaces.append(interface)\n\n    if loopback_count == number and len(down_loopback_interfaces) == 0:\n        self.result.is_success()\n    else:\n        self.result.is_failure()\n        if loopback_count != number:\n            self.result.is_failure(f\"Found {loopback_count} Loopbacks when expecting {number}\")\n        elif len(down_loopback_interfaces) != 0:\n            self.result.is_failure(f\"The following Loopbacks are not up: {down_loopback_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyPortChannels","title":"<code>VerifyPortChannels</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies there is no inactive port in port channels.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyPortChannels(AntaTest):\n\"\"\"\n    Verifies there is no inactive port in port channels.\n    \"\"\"\n\n    name = \"VerifyPortChannels\"\n    description = \"Verifies there is no inactive port in port channels.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show port-channel\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyPortChannels validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        po_with_invactive_ports: List[Dict[str, str]] = []\n        for portchannel, portchannel_dict in command_output[\"portChannels\"].items():\n            if len(portchannel_dict[\"inactivePorts\"]) != 0:\n                po_with_invactive_ports.extend({portchannel: portchannel_dict[\"inactivePorts\"]})\n\n        if not po_with_invactive_ports:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following port-channels have inactive port(s): {po_with_invactive_ports}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyPortChannels.test","title":"<code>test()</code>","text":"<p>Run VerifyPortChannels validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyPortChannels validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    po_with_invactive_ports: List[Dict[str, str]] = []\n    for portchannel, portchannel_dict in command_output[\"portChannels\"].items():\n        if len(portchannel_dict[\"inactivePorts\"]) != 0:\n            po_with_invactive_ports.extend({portchannel: portchannel_dict[\"inactivePorts\"]})\n\n    if not po_with_invactive_ports:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following port-channels have inactive port(s): {po_with_invactive_ports}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifySVI","title":"<code>VerifySVI</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies there is no interface vlan down.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifySVI(AntaTest):\n\"\"\"\n    Verifies there is no interface vlan down.\n    \"\"\"\n\n    name = \"VerifySVI\"\n    description = \"Verifies there is no interface vlan down.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show ip interface brief\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifySVI validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        down_svis = []\n\n        for interface in command_output[\"interfaces\"]:\n            interface_dict = command_output[\"interfaces\"][interface]\n            if \"Vlan\" in interface:\n                if not (interface_dict[\"lineProtocolStatus\"] == \"up\" and interface_dict[\"interfaceStatus\"] == \"connected\"):\n                    down_svis.append(interface)\n\n        if len(down_svis) == 0:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following SVIs are not up: {down_svis}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifySVI.test","title":"<code>test()</code>","text":"<p>Run VerifySVI validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifySVI validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    down_svis = []\n\n    for interface in command_output[\"interfaces\"]:\n        interface_dict = command_output[\"interfaces\"][interface]\n        if \"Vlan\" in interface:\n            if not (interface_dict[\"lineProtocolStatus\"] == \"up\" and interface_dict[\"interfaceStatus\"] == \"connected\"):\n                down_svis.append(interface)\n\n    if len(down_svis) == 0:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following SVIs are not up: {down_svis}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyStormControlDrops","title":"<code>VerifyStormControlDrops</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the device did not drop packets due its to storm-control configuration.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyStormControlDrops(AntaTest):\n\"\"\"\n    Verifies the device did not drop packets due its to storm-control configuration.\n    \"\"\"\n\n    name = \"VerifyStormControlDrops\"\n    description = \"Verifies the device did not drop packets due its to storm-control configuration.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show storm-control\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyStormControlDrops validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        storm_controlled_interfaces: Dict[str, Dict[str, Any]] = {}\n        for interface, interface_dict in command_output[\"interfaces\"].items():\n            for traffic_type, traffic_type_dict in interface_dict[\"trafficTypes\"].items():\n                if \"drop\" in traffic_type_dict and traffic_type_dict[\"drop\"] != 0:\n                    storm_controlled_interface_dict = storm_controlled_interfaces.setdefault(interface, {})\n                    storm_controlled_interface_dict.update({traffic_type: traffic_type_dict[\"drop\"]})\n\n        if not storm_controlled_interfaces:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following interfaces have none 0 storm-control drop counters {storm_controlled_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyStormControlDrops.test","title":"<code>test()</code>","text":"<p>Run VerifyStormControlDrops validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyStormControlDrops validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    storm_controlled_interfaces: Dict[str, Dict[str, Any]] = {}\n    for interface, interface_dict in command_output[\"interfaces\"].items():\n        for traffic_type, traffic_type_dict in interface_dict[\"trafficTypes\"].items():\n            if \"drop\" in traffic_type_dict and traffic_type_dict[\"drop\"] != 0:\n                storm_controlled_interface_dict = storm_controlled_interfaces.setdefault(interface, {})\n                storm_controlled_interface_dict.update({traffic_type: traffic_type_dict[\"drop\"]})\n\n    if not storm_controlled_interfaces:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following interfaces have none 0 storm-control drop counters {storm_controlled_interfaces}\")\n</code></pre>"},{"location":"api/tests.logging/","title":"Logging","text":""},{"location":"api/tests.logging/#anta-catalog-for-logging-tests","title":"ANTA catalog for logging tests","text":"<p>Test functions related to the EOS various logging settings</p> <p>NOTE: \u2018show logging\u2019 does not support json output yet</p>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingAccounting","title":"<code>VerifyLoggingAccounting</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if AAA accounting logs are generated.</p> Expected Results <ul> <li>success: The test will pass if AAA accounting logs are generated.</li> <li>failure: The test will fail if AAA accounting logs are NOT generated.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingAccounting(AntaTest):\n\"\"\"\n    Verifies if AAA accounting logs are generated.\n\n    Expected Results:\n        * success: The test will pass if AAA accounting logs are generated.\n        * failure: The test will fail if AAA accounting logs are NOT generated.\n    \"\"\"\n\n    name = \"VerifyLoggingAccounting\"\n    description = \"Verifies if AAA accounting logs are generated.\"\n    categories = [\"logging\"]\n    commands = [AntaCommand(command=\"show aaa accounting logs | tail\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyLoggingAccountingvalidation.\n        \"\"\"\n        pattern = r\"cmd=show aaa accounting logs\"\n        output = self.instance_commands[0].text_output\n\n        if re.search(pattern, output):\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"AAA accounting logs are not generated\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingAccounting.test","title":"<code>test()</code>","text":"<p>Run VerifyLoggingAccountingvalidation.</p> Source code in <code>anta/tests/logging.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyLoggingAccountingvalidation.\n    \"\"\"\n    pattern = r\"cmd=show aaa accounting logs\"\n    output = self.instance_commands[0].text_output\n\n    if re.search(pattern, output):\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"AAA accounting logs are not generated\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingHostname","title":"<code>VerifyLoggingHostname</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if logs are generated with the device FQDN.</p> Expected Results <ul> <li>success: The test will pass if logs are generated with the device FQDN.</li> <li>failure: The test will fail if logs are NOT generated with the device FQDN.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingHostname(AntaTest):\n\"\"\"\n    Verifies if logs are generated with the device FQDN.\n\n    Expected Results:\n        * success: The test will pass if logs are generated with the device FQDN.\n        * failure: The test will fail if logs are NOT generated with the device FQDN.\n    \"\"\"\n\n    name = \"VerifyLoggingHostname\"\n    description = \"Verifies if logs are generated with the device FQDN.\"\n    categories = [\"logging\"]\n    commands = [\n        AntaCommand(command=\"show hostname\"),\n        AntaCommand(command=\"send log level informational message ANTA VerifyLoggingHostname validation\"),\n        AntaCommand(command=\"show logging informational last 30 seconds | grep ANTA\", ofmt=\"text\"),\n    ]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyLoggingHostname validation.\n        \"\"\"\n        output_hostname = self.instance_commands[0].json_output\n        output_logging = self.instance_commands[2].text_output\n        fqdn = output_hostname[\"fqdn\"]\n        lines = output_logging.strip().split(\"\\n\")[::-1]\n\n        log_pattern = r\"ANTA VerifyLoggingHostname validation\"\n\n        last_line_with_pattern = \"\"\n        for line in lines:\n            if re.search(log_pattern, line):\n                last_line_with_pattern = line\n                break\n\n        if fqdn in last_line_with_pattern:\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"Logs are not generated with the device FQDN\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingHostname.test","title":"<code>test()</code>","text":"<p>Run VerifyLoggingHostname validation.</p> Source code in <code>anta/tests/logging.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyLoggingHostname validation.\n    \"\"\"\n    output_hostname = self.instance_commands[0].json_output\n    output_logging = self.instance_commands[2].text_output\n    fqdn = output_hostname[\"fqdn\"]\n    lines = output_logging.strip().split(\"\\n\")[::-1]\n\n    log_pattern = r\"ANTA VerifyLoggingHostname validation\"\n\n    last_line_with_pattern = \"\"\n    for line in lines:\n        if re.search(log_pattern, line):\n            last_line_with_pattern = line\n            break\n\n    if fqdn in last_line_with_pattern:\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"Logs are not generated with the device FQDN\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingHosts","title":"<code>VerifyLoggingHosts</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies logging hosts (syslog servers) for a specified VRF.</p> Expected Results <ul> <li>success: The test will pass if the provided syslog servers are configured in the specified VRF.</li> <li>failure: The test will fail if the provided syslog servers are NOT configured in the specified VRF.</li> <li>skipped: The test will be skipped if syslog servers or VRF are not provided.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingHosts(AntaTest):\n\"\"\"\n    Verifies logging hosts (syslog servers) for a specified VRF.\n\n    Expected Results:\n        * success: The test will pass if the provided syslog servers are configured in the specified VRF.\n        * failure: The test will fail if the provided syslog servers are NOT configured in the specified VRF.\n        * skipped: The test will be skipped if syslog servers or VRF are not provided.\n    \"\"\"\n\n    name = \"VerifyLoggingHosts\"\n    description = \"Verifies logging hosts (syslog servers) for a specified VRF.\"\n    categories = [\"logging\"]\n    commands = [AntaCommand(command=\"show logging\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self, hosts: Optional[List[str]] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifyLoggingHosts validation.\n\n        Args:\n            hosts: List of hosts (syslog servers) IP addresses.\n            vrf: The name of the VRF to transport log messages. Defaults to 'default'.\n        \"\"\"\n        if not hosts or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because hosts or vrf were not supplied\")\n            return\n\n        output = self.instance_commands[0].text_output\n\n        not_configured = []\n\n        for host in hosts:\n            pattern = rf\"Logging to '{host}'.*VRF {vrf}\"\n            if not re.search(pattern, _get_logging_states(self.logger, output)):\n                not_configured.append(host)\n\n        if not not_configured:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Syslog servers {not_configured} are not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingHosts.test","title":"<code>test(hosts=None, vrf='default')</code>","text":"<p>Run VerifyLoggingHosts validation.</p> <p>Parameters:</p> Name Type Description Default <code>hosts</code> <code>Optional[List[str]]</code> <p>List of hosts (syslog servers) IP addresses.</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF to transport log messages. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/logging.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, hosts: Optional[List[str]] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifyLoggingHosts validation.\n\n    Args:\n        hosts: List of hosts (syslog servers) IP addresses.\n        vrf: The name of the VRF to transport log messages. Defaults to 'default'.\n    \"\"\"\n    if not hosts or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because hosts or vrf were not supplied\")\n        return\n\n    output = self.instance_commands[0].text_output\n\n    not_configured = []\n\n    for host in hosts:\n        pattern = rf\"Logging to '{host}'.*VRF {vrf}\"\n        if not re.search(pattern, _get_logging_states(self.logger, output)):\n            not_configured.append(host)\n\n    if not not_configured:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Syslog servers {not_configured} are not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingLogsGeneration","title":"<code>VerifyLoggingLogsGeneration</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if logs are generated.</p> Expected Results <ul> <li>success: The test will pass if logs are generated.</li> <li>failure: The test will fail if logs are NOT generated.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingLogsGeneration(AntaTest):\n\"\"\"\n    Verifies if logs are generated.\n\n    Expected Results:\n        * success: The test will pass if logs are generated.\n        * failure: The test will fail if logs are NOT generated.\n    \"\"\"\n\n    name = \"VerifyLoggingLogsGeneration\"\n    description = \"Verifies if logs are generated.\"\n    categories = [\"logging\"]\n    commands = [\n        AntaCommand(command=\"send log level informational message ANTA VerifyLoggingLogsGeneration validation\"),\n        AntaCommand(command=\"show logging informational last 30 seconds | grep ANTA\", ofmt=\"text\"),\n    ]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyLoggingLogs validation.\n        \"\"\"\n        log_pattern = r\"ANTA VerifyLoggingLogsGeneration validation\"\n\n        output = self.instance_commands[1].text_output\n        lines = output.strip().split(\"\\n\")[::-1]\n\n        for line in lines:\n            if re.search(log_pattern, line):\n                self.result.is_success()\n                return\n\n        self.result.is_failure(\"Logs are not generated\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingLogsGeneration.test","title":"<code>test()</code>","text":"<p>Run VerifyLoggingLogs validation.</p> Source code in <code>anta/tests/logging.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyLoggingLogs validation.\n    \"\"\"\n    log_pattern = r\"ANTA VerifyLoggingLogsGeneration validation\"\n\n    output = self.instance_commands[1].text_output\n    lines = output.strip().split(\"\\n\")[::-1]\n\n    for line in lines:\n        if re.search(log_pattern, line):\n            self.result.is_success()\n            return\n\n    self.result.is_failure(\"Logs are not generated\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingPersistent","title":"<code>VerifyLoggingPersistent</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if logging persistent is enabled and logs are saved in flash.</p> Expected Results <ul> <li>success: The test will pass if logging persistent is enabled and logs are in flash.</li> <li>failure: The test will fail if logging persistent is disabled or no logs are saved in flash.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingPersistent(AntaTest):\n\"\"\"\n    Verifies if logging persistent is enabled and logs are saved in flash.\n\n    Expected Results:\n        * success: The test will pass if logging persistent is enabled and logs are in flash.\n        * failure: The test will fail if logging persistent is disabled or no logs are saved in flash.\n    \"\"\"\n\n    name = \"VerifyLoggingPersistent\"\n    description = \"Verifies if logging persistent is enabled and logs are saved in flash.\"\n    categories = [\"logging\"]\n    commands = [\n        AntaCommand(command=\"show logging\", ofmt=\"text\"),\n        AntaCommand(command=\"dir flash:/persist/messages\", ofmt=\"text\"),\n    ]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyLoggingPersistent validation.\n        \"\"\"\n        self.result.is_success()\n\n        log_output = self.instance_commands[0].text_output\n        dir_flash_output = self.instance_commands[1].text_output\n\n        if \"Persistent logging: disabled\" in _get_logging_states(self.logger, log_output):\n            self.result.is_failure(\"Persistent logging is disabled\")\n            return\n\n        pattern = r\"-rw-\\s+(\\d+)\"\n        persist_logs = re.search(pattern, dir_flash_output)\n\n        if not persist_logs or int(persist_logs.group(1)) == 0:\n            self.result.is_failure(\"No persistent logs are saved in flash\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingPersistent.test","title":"<code>test()</code>","text":"<p>Run VerifyLoggingPersistent validation.</p> Source code in <code>anta/tests/logging.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyLoggingPersistent validation.\n    \"\"\"\n    self.result.is_success()\n\n    log_output = self.instance_commands[0].text_output\n    dir_flash_output = self.instance_commands[1].text_output\n\n    if \"Persistent logging: disabled\" in _get_logging_states(self.logger, log_output):\n        self.result.is_failure(\"Persistent logging is disabled\")\n        return\n\n    pattern = r\"-rw-\\s+(\\d+)\"\n    persist_logs = re.search(pattern, dir_flash_output)\n\n    if not persist_logs or int(persist_logs.group(1)) == 0:\n        self.result.is_failure(\"No persistent logs are saved in flash\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingSourceIntf","title":"<code>VerifyLoggingSourceIntf</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies logging source-interface for a specified VRF.</p> Expected Results <ul> <li>success: The test will pass if the provided logging source-interface is configured in the specified VRF.</li> <li>failure: The test will fail if the provided logging source-interface is NOT configured in the specified VRF.</li> <li>skipped: The test will be skipped if source-interface or VRF is not provided.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingSourceIntf(AntaTest):\n\"\"\"\n    Verifies logging source-interface for a specified VRF.\n\n    Expected Results:\n        * success: The test will pass if the provided logging source-interface is configured in the specified VRF.\n        * failure: The test will fail if the provided logging source-interface is NOT configured in the specified VRF.\n        * skipped: The test will be skipped if source-interface or VRF is not provided.\n    \"\"\"\n\n    name = \"VerifyLoggingSourceInt\"\n    description = \"Verifies logging source-interface for a specified VRF.\"\n    categories = [\"logging\"]\n    commands = [AntaCommand(command=\"show logging\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self, intf: Optional[str] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifyLoggingSrcDst validation.\n\n        Args:\n            intf: Source-interface to use as source IP of log messages.\n            vrf: The name of the VRF to transport log messages. Defaults to 'default'.\n        \"\"\"\n        if not intf or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because intf or vrf was not supplied\")\n            return\n\n        output = self.instance_commands[0].text_output\n\n        pattern = rf\"Logging source-interface '{intf}'.*VRF {vrf}\"\n\n        if re.search(pattern, _get_logging_states(self.logger, output)):\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Source-interface '{intf}' is not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingSourceIntf.test","title":"<code>test(intf=None, vrf='default')</code>","text":"<p>Run VerifyLoggingSrcDst validation.</p> <p>Parameters:</p> Name Type Description Default <code>intf</code> <code>Optional[str]</code> <p>Source-interface to use as source IP of log messages.</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF to transport log messages. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/logging.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, intf: Optional[str] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifyLoggingSrcDst validation.\n\n    Args:\n        intf: Source-interface to use as source IP of log messages.\n        vrf: The name of the VRF to transport log messages. Defaults to 'default'.\n    \"\"\"\n    if not intf or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because intf or vrf was not supplied\")\n        return\n\n    output = self.instance_commands[0].text_output\n\n    pattern = rf\"Logging source-interface '{intf}'.*VRF {vrf}\"\n\n    if re.search(pattern, _get_logging_states(self.logger, output)):\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Source-interface '{intf}' is not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingTimestamp","title":"<code>VerifyLoggingTimestamp</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if logs are generated with the approprate timestamp.</p> Expected Results <ul> <li>success: The test will pass if logs are generated with the appropriated timestamp.</li> <li>failure: The test will fail if logs are NOT generated with the appropriated timestamp.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingTimestamp(AntaTest):\n\"\"\"\n    Verifies if logs are generated with the approprate timestamp.\n\n    Expected Results:\n        * success: The test will pass if logs are generated with the appropriated timestamp.\n        * failure: The test will fail if logs are NOT generated with the appropriated timestamp.\n    \"\"\"\n\n    name = \"VerifyLoggingTimestamp\"\n    description = \"Verifies if logs are generated with the appropriate timestamp.\"\n    categories = [\"logging\"]\n    commands = [\n        AntaCommand(command=\"send log level informational message ANTA VerifyLoggingTimestamp validation\"),\n        AntaCommand(command=\"show logging informational last 30 seconds | grep ANTA\", ofmt=\"text\"),\n    ]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyLoggingTimestamp validation.\n        \"\"\"\n        log_pattern = r\"ANTA VerifyLoggingTimestamp validation\"\n        timestamp_pattern = r\"\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{6}-\\d{2}:\\d{2}\"\n\n        output = self.instance_commands[1].text_output\n\n        lines = output.strip().split(\"\\n\")[::-1]\n\n        last_line_with_pattern = \"\"\n        for line in lines:\n            if re.search(log_pattern, line):\n                last_line_with_pattern = line\n                break\n\n        if re.search(timestamp_pattern, last_line_with_pattern):\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"Logs are not generated with the appropriate timestamp format\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingTimestamp.test","title":"<code>test()</code>","text":"<p>Run VerifyLoggingTimestamp validation.</p> Source code in <code>anta/tests/logging.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyLoggingTimestamp validation.\n    \"\"\"\n    log_pattern = r\"ANTA VerifyLoggingTimestamp validation\"\n    timestamp_pattern = r\"\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{6}-\\d{2}:\\d{2}\"\n\n    output = self.instance_commands[1].text_output\n\n    lines = output.strip().split(\"\\n\")[::-1]\n\n    last_line_with_pattern = \"\"\n    for line in lines:\n        if re.search(log_pattern, line):\n            last_line_with_pattern = line\n            break\n\n    if re.search(timestamp_pattern, last_line_with_pattern):\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"Logs are not generated with the appropriate timestamp format\")\n</code></pre>"},{"location":"api/tests/","title":"Overview","text":""},{"location":"api/tests/#anta-tests-landing-page","title":"ANTA Tests landing page","text":"<p>This section describes all the available tests provided by ANTA package.</p> <ul> <li>AAA</li> <li>Configuration</li> <li>Connectivity</li> <li>Field Notice</li> <li>Hardware</li> <li>Interfaces</li> <li>Logging</li> <li>MLAG</li> <li>Multicast</li> <li>Profiles</li> <li>Routing Generic</li> <li>Routing BGP</li> <li>Routing OSPF</li> <li>Security</li> <li>SNMP</li> <li>Software</li> <li>STP</li> <li>System</li> <li>VxLAN</li> </ul> <p>All these tests can be imported in a catalog to be used by the anta cli or in your own framework</p>"},{"location":"api/tests.mlag/","title":"MLAG","text":""},{"location":"api/tests.mlag/#anta-catalog-for-mlag-tests","title":"ANTA catalog for mlag tests","text":"<p>Test functions related to Multi-chassis Link Aggregation (MLAG)</p>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagConfigSanity","title":"<code>VerifyMlagConfigSanity</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>This test verifies there are no MLAG config-sanity inconsistencies.</p> Expected Results <ul> <li>success: The test will pass if there are NO MLAG config-sanity inconsistencies.</li> <li>failure: The test will fail if there are MLAG config-sanity inconsistencies.</li> <li>skipped: The test will be skipped if MLAG is \u2018disabled\u2019.</li> <li>error: The test will give an error if \u2018mlagActive\u2019 is not found in the JSON response.</li> </ul> Source code in <code>anta/tests/mlag.py</code> <pre><code>class VerifyMlagConfigSanity(AntaTest):\n\"\"\"\n    This test verifies there are no MLAG config-sanity inconsistencies.\n\n    Expected Results:\n        * success: The test will pass if there are NO MLAG config-sanity inconsistencies.\n        * failure: The test will fail if there are MLAG config-sanity inconsistencies.\n        * skipped: The test will be skipped if MLAG is 'disabled'.\n        * error: The test will give an error if 'mlagActive' is not found in the JSON response.\n    \"\"\"\n\n    name = \"VerifyMlagConfigSanity\"\n    description = \"This test verifies there are no MLAG config-sanity inconsistencies.\"\n    categories = [\"mlag\"]\n    commands = [AntaCommand(command=\"show mlag config-sanity\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyMlagConfigSanity validation\n        \"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if (mlag_status := get_value(command_output, \"mlagActive\")) is None:\n            self.result.is_error(\"Incorrect JSON response - 'mlagActive' state was not found\")\n            return\n\n        if mlag_status is False:\n            self.result.is_skipped(\"MLAG is disabled\")\n            return\n\n        keys_to_verify = [\"globalConfiguration\", \"interfaceConfiguration\"]\n        verified_output = {key: get_value(command_output, key) for key in keys_to_verify}\n\n        if not any(verified_output.values()):\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"MLAG config-sanity returned inconsistencies: {verified_output}\")\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagConfigSanity.test","title":"<code>test()</code>","text":"<p>Run VerifyMlagConfigSanity validation</p> Source code in <code>anta/tests/mlag.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyMlagConfigSanity validation\n    \"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if (mlag_status := get_value(command_output, \"mlagActive\")) is None:\n        self.result.is_error(\"Incorrect JSON response - 'mlagActive' state was not found\")\n        return\n\n    if mlag_status is False:\n        self.result.is_skipped(\"MLAG is disabled\")\n        return\n\n    keys_to_verify = [\"globalConfiguration\", \"interfaceConfiguration\"]\n    verified_output = {key: get_value(command_output, key) for key in keys_to_verify}\n\n    if not any(verified_output.values()):\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"MLAG config-sanity returned inconsistencies: {verified_output}\")\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagDualPrimary","title":"<code>VerifyMlagDualPrimary</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>This test verifies the dual-primary detection and its parameters of the MLAG configuration.</p> Expected Results <ul> <li>success: The test will pass if the dual-primary detection is enabled and its parameters are configured properly.</li> <li>failure: The test will fail if the dual-primary detection is NOT enabled or its parameters are NOT configured properly.</li> <li>skipped: The test will be skipped if the dual-primary parameters are NOT provided or if MLAG is \u2018disabled\u2019.</li> </ul> Source code in <code>anta/tests/mlag.py</code> <pre><code>class VerifyMlagDualPrimary(AntaTest):\n\"\"\"\n    This test verifies the dual-primary detection and its parameters of the MLAG configuration.\n\n    Expected Results:\n        * success: The test will pass if the dual-primary detection is enabled and its parameters are configured properly.\n        * failure: The test will fail if the dual-primary detection is NOT enabled or its parameters are NOT configured properly.\n        * skipped: The test will be skipped if the dual-primary parameters are NOT provided or if MLAG is 'disabled'.\n    \"\"\"\n\n    name = \"VerifyMlagDualPrimary\"\n    description = \"This test verifies the dual-primary detection and its parameters of the MLAG configuration.\"\n    categories = [\"mlag\"]\n    commands = [AntaCommand(command=\"show mlag detail\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(\n        self, detection_delay: Optional[int] = None, errdisabled: bool = False, recovery_delay: Optional[int] = None, recovery_delay_non_mlag: Optional[int] = None\n    ) -&gt; None:\n\"\"\"\n        Run VerifyMlagDualPrimary validation\n\n        Args:\n            detection_delay: Delay detection for &lt;N&gt; seconds.\n            errdisabled: Errdisabled all interfaces when dual-primary is detected. Defaults to False.\n            recovery_delay: Delay (seconds) after dual-primary detection resolves until non peer-link ports that are part of an MLAG are enabled.\n            recovery_delay_non_mlag: Delay (seconds) after dual-primary detection resolves until ports that are not part of an MLAG are enabled.\n        \"\"\"\n\n        if detection_delay is None or errdisabled is None or recovery_delay is None or recovery_delay_non_mlag is None:\n            self.result.is_skipped(\n                f\"{self.__class__.name} did not run because detection_delay, errdisabled, recovery_delay or recovery_delay_non_mlag were not supplied\"\n            )\n            return\n\n        errdisabled_action = \"errdisableAllInterfaces\" if errdisabled else \"none\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if command_output[\"state\"] == \"disabled\":\n            self.result.is_skipped(\"MLAG is disabled\")\n            return\n\n        if command_output[\"dualPrimaryDetectionState\"] == \"disabled\":\n            self.result.is_failure(\"Dual-primary detection is disabled\")\n            return\n\n        keys_to_verify = [\"detail.dualPrimaryDetectionDelay\", \"detail.dualPrimaryAction\", \"dualPrimaryMlagRecoveryDelay\", \"dualPrimaryNonMlagRecoveryDelay\"]\n        verified_output = {key: get_value(command_output, key) for key in keys_to_verify}\n\n        if (\n            verified_output[\"detail.dualPrimaryDetectionDelay\"] == detection_delay\n            and verified_output[\"detail.dualPrimaryAction\"] == errdisabled_action\n            and verified_output[\"dualPrimaryMlagRecoveryDelay\"] == recovery_delay\n            and verified_output[\"dualPrimaryNonMlagRecoveryDelay\"] == recovery_delay_non_mlag\n        ):\n            self.result.is_success()\n\n        else:\n            self.result.is_failure(f\"The dual-primary parameters are not configured properly: {verified_output}\")\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagDualPrimary.test","title":"<code>test(detection_delay=None, errdisabled=False, recovery_delay=None, recovery_delay_non_mlag=None)</code>","text":"<p>Run VerifyMlagDualPrimary validation</p> <p>Parameters:</p> Name Type Description Default <code>detection_delay</code> <code>Optional[int]</code> <p>Delay detection for  seconds. <code>None</code> <code>errdisabled</code> <code>bool</code> <p>Errdisabled all interfaces when dual-primary is detected. Defaults to False.</p> <code>False</code> <code>recovery_delay</code> <code>Optional[int]</code> <p>Delay (seconds) after dual-primary detection resolves until non peer-link ports that are part of an MLAG are enabled.</p> <code>None</code> <code>recovery_delay_non_mlag</code> <code>Optional[int]</code> <p>Delay (seconds) after dual-primary detection resolves until ports that are not part of an MLAG are enabled.</p> <code>None</code> Source code in <code>anta/tests/mlag.py</code> <pre><code>@AntaTest.anta_test\ndef test(\n    self, detection_delay: Optional[int] = None, errdisabled: bool = False, recovery_delay: Optional[int] = None, recovery_delay_non_mlag: Optional[int] = None\n) -&gt; None:\n\"\"\"\n    Run VerifyMlagDualPrimary validation\n\n    Args:\n        detection_delay: Delay detection for &lt;N&gt; seconds.\n        errdisabled: Errdisabled all interfaces when dual-primary is detected. Defaults to False.\n        recovery_delay: Delay (seconds) after dual-primary detection resolves until non peer-link ports that are part of an MLAG are enabled.\n        recovery_delay_non_mlag: Delay (seconds) after dual-primary detection resolves until ports that are not part of an MLAG are enabled.\n    \"\"\"\n\n    if detection_delay is None or errdisabled is None or recovery_delay is None or recovery_delay_non_mlag is None:\n        self.result.is_skipped(\n            f\"{self.__class__.name} did not run because detection_delay, errdisabled, recovery_delay or recovery_delay_non_mlag were not supplied\"\n        )\n        return\n\n    errdisabled_action = \"errdisableAllInterfaces\" if errdisabled else \"none\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if command_output[\"state\"] == \"disabled\":\n        self.result.is_skipped(\"MLAG is disabled\")\n        return\n\n    if command_output[\"dualPrimaryDetectionState\"] == \"disabled\":\n        self.result.is_failure(\"Dual-primary detection is disabled\")\n        return\n\n    keys_to_verify = [\"detail.dualPrimaryDetectionDelay\", \"detail.dualPrimaryAction\", \"dualPrimaryMlagRecoveryDelay\", \"dualPrimaryNonMlagRecoveryDelay\"]\n    verified_output = {key: get_value(command_output, key) for key in keys_to_verify}\n\n    if (\n        verified_output[\"detail.dualPrimaryDetectionDelay\"] == detection_delay\n        and verified_output[\"detail.dualPrimaryAction\"] == errdisabled_action\n        and verified_output[\"dualPrimaryMlagRecoveryDelay\"] == recovery_delay\n        and verified_output[\"dualPrimaryNonMlagRecoveryDelay\"] == recovery_delay_non_mlag\n    ):\n        self.result.is_success()\n\n    else:\n        self.result.is_failure(f\"The dual-primary parameters are not configured properly: {verified_output}\")\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagInterfaces","title":"<code>VerifyMlagInterfaces</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>This test verifies there are no inactive or active-partial MLAG ports.</p> Expected Results <ul> <li>success: The test will pass if there are NO inactive or active-partial MLAG ports.</li> <li>failure: The test will fail if there are inactive or active-partial MLAG ports.</li> <li>skipped: The test will be skipped if MLAG is \u2018disabled\u2019.</li> </ul> Source code in <code>anta/tests/mlag.py</code> <pre><code>class VerifyMlagInterfaces(AntaTest):\n\"\"\"\n    This test verifies there are no inactive or active-partial MLAG ports.\n\n    Expected Results:\n        * success: The test will pass if there are NO inactive or active-partial MLAG ports.\n        * failure: The test will fail if there are inactive or active-partial MLAG ports.\n        * skipped: The test will be skipped if MLAG is 'disabled'.\n    \"\"\"\n\n    name = \"VerifyMlagInterfaces\"\n    description = \"This test verifies there are no inactive or active-partial MLAG ports.\"\n    categories = [\"mlag\"]\n    commands = [AntaCommand(command=\"show mlag\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyMlagInterfaces validation\n        \"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if command_output[\"state\"] == \"disabled\":\n            self.result.is_skipped(\"MLAG is disabled\")\n            return\n\n        if command_output[\"mlagPorts\"][\"Inactive\"] == 0 and command_output[\"mlagPorts\"][\"Active-partial\"] == 0:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"MLAG status is not OK: {command_output['mlagPorts']}\")\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagInterfaces.test","title":"<code>test()</code>","text":"<p>Run VerifyMlagInterfaces validation</p> Source code in <code>anta/tests/mlag.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyMlagInterfaces validation\n    \"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if command_output[\"state\"] == \"disabled\":\n        self.result.is_skipped(\"MLAG is disabled\")\n        return\n\n    if command_output[\"mlagPorts\"][\"Inactive\"] == 0 and command_output[\"mlagPorts\"][\"Active-partial\"] == 0:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"MLAG status is not OK: {command_output['mlagPorts']}\")\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagReloadDelay","title":"<code>VerifyMlagReloadDelay</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>This test verifies the reload-delay parameters of the MLAG configuration.</p> Expected Results <ul> <li>success: The test will pass if the reload-delay parameters are configured properly.</li> <li>failure: The test will fail if the reload-delay parameters are NOT configured properly.</li> <li>skipped: The test will be skipped if the reload-delay parameters are NOT provided or if MLAG is \u2018disabled\u2019.</li> </ul> Source code in <code>anta/tests/mlag.py</code> <pre><code>class VerifyMlagReloadDelay(AntaTest):\n\"\"\"\n    This test verifies the reload-delay parameters of the MLAG configuration.\n\n    Expected Results:\n        * success: The test will pass if the reload-delay parameters are configured properly.\n        * failure: The test will fail if the reload-delay parameters are NOT configured properly.\n        * skipped: The test will be skipped if the reload-delay parameters are NOT provided or if MLAG is 'disabled'.\n    \"\"\"\n\n    name = \"VerifyMlagReloadDelay\"\n    description = \"This test verifies the reload-delay parameters of the MLAG configuration.\"\n    categories = [\"mlag\"]\n    commands = [AntaCommand(command=\"show mlag\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self, reload_delay: Optional[int] = None, reload_delay_non_mlag: Optional[int] = None) -&gt; None:\n\"\"\"\n        Run VerifyMlagReloadDelay validation\n\n        Args:\n            reload_delay: Delay (seconds) after reboot until non peer-link ports that are part of an MLAG are enabled.\n            reload_delay_non_mlag: Delay (seconds) after reboot until ports that are not part of an MLAG are enabled.\n        \"\"\"\n\n        if not reload_delay or not reload_delay_non_mlag:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because reload_delay or reload_delay_non_mlag were not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        if command_output[\"state\"] == \"disabled\":\n            self.result.is_skipped(\"MLAG is disabled\")\n            return\n\n        keys_to_verify = [\"reloadDelay\", \"reloadDelayNonMlag\"]\n        verified_output = {key: get_value(command_output, key) for key in keys_to_verify}\n\n        if verified_output[\"reloadDelay\"] == reload_delay and verified_output[\"reloadDelayNonMlag\"] == reload_delay_non_mlag:\n            self.result.is_success()\n\n        else:\n            self.result.is_failure(f\"The reload-delay parameters are not configured properly: {verified_output}\")\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagReloadDelay.test","title":"<code>test(reload_delay=None, reload_delay_non_mlag=None)</code>","text":"<p>Run VerifyMlagReloadDelay validation</p> <p>Parameters:</p> Name Type Description Default <code>reload_delay</code> <code>Optional[int]</code> <p>Delay (seconds) after reboot until non peer-link ports that are part of an MLAG are enabled.</p> <code>None</code> <code>reload_delay_non_mlag</code> <code>Optional[int]</code> <p>Delay (seconds) after reboot until ports that are not part of an MLAG are enabled.</p> <code>None</code> Source code in <code>anta/tests/mlag.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, reload_delay: Optional[int] = None, reload_delay_non_mlag: Optional[int] = None) -&gt; None:\n\"\"\"\n    Run VerifyMlagReloadDelay validation\n\n    Args:\n        reload_delay: Delay (seconds) after reboot until non peer-link ports that are part of an MLAG are enabled.\n        reload_delay_non_mlag: Delay (seconds) after reboot until ports that are not part of an MLAG are enabled.\n    \"\"\"\n\n    if not reload_delay or not reload_delay_non_mlag:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because reload_delay or reload_delay_non_mlag were not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    if command_output[\"state\"] == \"disabled\":\n        self.result.is_skipped(\"MLAG is disabled\")\n        return\n\n    keys_to_verify = [\"reloadDelay\", \"reloadDelayNonMlag\"]\n    verified_output = {key: get_value(command_output, key) for key in keys_to_verify}\n\n    if verified_output[\"reloadDelay\"] == reload_delay and verified_output[\"reloadDelayNonMlag\"] == reload_delay_non_mlag:\n        self.result.is_success()\n\n    else:\n        self.result.is_failure(f\"The reload-delay parameters are not configured properly: {verified_output}\")\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagStatus","title":"<code>VerifyMlagStatus</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>This test verifies the health status of the MLAG configuration.</p> Expected Results <ul> <li>success: The test will pass if the MLAG state is \u2018active\u2019, negotiation status is \u2018connected\u2019,            peer-link status and local interface status are \u2018up\u2019.</li> <li>failure: The test will fail if the MLAG state is not \u2018active\u2019, negotiation status is not \u2018connected\u2019,            peer-link status or local interface status are not \u2018up\u2019.</li> <li>skipped: The test will be skipped if MLAG is \u2018disabled\u2019.</li> </ul> Source code in <code>anta/tests/mlag.py</code> <pre><code>class VerifyMlagStatus(AntaTest):\n\"\"\"\n    This test verifies the health status of the MLAG configuration.\n\n    Expected Results:\n        * success: The test will pass if the MLAG state is 'active', negotiation status is 'connected',\n                   peer-link status and local interface status are 'up'.\n        * failure: The test will fail if the MLAG state is not 'active', negotiation status is not 'connected',\n                   peer-link status or local interface status are not 'up'.\n        * skipped: The test will be skipped if MLAG is 'disabled'.\n    \"\"\"\n\n    name = \"VerifyMlagStatus\"\n    description = \"This test verifies the health status of the MLAG configuration.\"\n    categories = [\"mlag\"]\n    commands = [AntaCommand(command=\"show mlag\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyMlagStatus validation\n        \"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if command_output[\"state\"] == \"disabled\":\n            self.result.is_skipped(\"MLAG is disabled\")\n            return\n\n        keys_to_verify = [\"state\", \"negStatus\", \"localIntfStatus\", \"peerLinkStatus\"]\n        verified_output = {key: get_value(command_output, key) for key in keys_to_verify}\n\n        if (\n            verified_output[\"state\"] == \"active\"\n            and verified_output[\"negStatus\"] == \"connected\"\n            and verified_output[\"localIntfStatus\"] == \"up\"\n            and verified_output[\"peerLinkStatus\"] == \"up\"\n        ):\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"MLAG status is not OK: {verified_output}\")\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagStatus.test","title":"<code>test()</code>","text":"<p>Run VerifyMlagStatus validation</p> Source code in <code>anta/tests/mlag.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyMlagStatus validation\n    \"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if command_output[\"state\"] == \"disabled\":\n        self.result.is_skipped(\"MLAG is disabled\")\n        return\n\n    keys_to_verify = [\"state\", \"negStatus\", \"localIntfStatus\", \"peerLinkStatus\"]\n    verified_output = {key: get_value(command_output, key) for key in keys_to_verify}\n\n    if (\n        verified_output[\"state\"] == \"active\"\n        and verified_output[\"negStatus\"] == \"connected\"\n        and verified_output[\"localIntfStatus\"] == \"up\"\n        and verified_output[\"peerLinkStatus\"] == \"up\"\n    ):\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"MLAG status is not OK: {verified_output}\")\n</code></pre>"},{"location":"api/tests.multicast/","title":"Multicast","text":""},{"location":"api/tests.multicast/#anta-catalog-for-multicast-tests","title":"ANTA catalog for multicast tests","text":"<p>Test functions related to multicast</p>"},{"location":"api/tests.multicast/#anta.tests.multicast.VerifyIGMPSnoopingGlobal","title":"<code>VerifyIGMPSnoopingGlobal</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the IGMP snooping global configuration.</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>str</code> <p>Expected global IGMP snooping configuration (enabled or disabled).</p> required Source code in <code>anta/tests/multicast.py</code> <pre><code>class VerifyIGMPSnoopingGlobal(AntaTest):\n\"\"\"\n    Verifies the IGMP snooping global configuration.\n\n    Args:\n        configuration (str): Expected global IGMP snooping configuration (enabled or disabled).\n    \"\"\"\n\n    name = \"VerifyIGMPSnoopingGlobal\"\n    description = \"Verifies the IGMP snooping global configuration.\"\n    categories = [\"multicast\", \"igmp\"]\n    commands = [AntaCommand(command=\"show ip igmp snooping\")]\n\n    @AntaTest.anta_test\n    def test(self, configuration: Optional[str] = None) -&gt; None:\n\"\"\"\n        Run VerifyIGMPSnoopingGlobal validation\n\n        Args:\n            configuration: Expected global IGMP configuration (enabled or disabled).\n        \"\"\"\n\n        if not configuration:\n            self.result.is_skipped(\"VerifyIGMPSnoopingGlobal was not run as no configuration was given\")\n            return\n\n        if configuration not in [\"enabled\", \"disabled\"]:\n            self.result.is_error(f\"VerifyIGMPSnoopingGlobal was not run as 'configuration': {configuration} is not in the allowed values: ['enabled', 'disabled'])\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        self.result.is_success()\n        if (igmp_state := command_output[\"igmpSnoopingState\"]) != configuration:\n            self.result.is_failure(f\"IGMP state is not valid: {igmp_state}\")\n</code></pre>"},{"location":"api/tests.multicast/#anta.tests.multicast.VerifyIGMPSnoopingGlobal.test","title":"<code>test(configuration=None)</code>","text":"<p>Run VerifyIGMPSnoopingGlobal validation</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>Optional[str]</code> <p>Expected global IGMP configuration (enabled or disabled).</p> <code>None</code> Source code in <code>anta/tests/multicast.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, configuration: Optional[str] = None) -&gt; None:\n\"\"\"\n    Run VerifyIGMPSnoopingGlobal validation\n\n    Args:\n        configuration: Expected global IGMP configuration (enabled or disabled).\n    \"\"\"\n\n    if not configuration:\n        self.result.is_skipped(\"VerifyIGMPSnoopingGlobal was not run as no configuration was given\")\n        return\n\n    if configuration not in [\"enabled\", \"disabled\"]:\n        self.result.is_error(f\"VerifyIGMPSnoopingGlobal was not run as 'configuration': {configuration} is not in the allowed values: ['enabled', 'disabled'])\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    self.result.is_success()\n    if (igmp_state := command_output[\"igmpSnoopingState\"]) != configuration:\n        self.result.is_failure(f\"IGMP state is not valid: {igmp_state}\")\n</code></pre>"},{"location":"api/tests.multicast/#anta.tests.multicast.VerifyIGMPSnoopingVlans","title":"<code>VerifyIGMPSnoopingVlans</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the IGMP snooping configuration for some VLANs.</p> <p>Parameters:</p> Name Type Description Default <code>vlans</code> <code>List[str]</code> <p>A list of VLANs</p> required <code>configuration</code> <code>str</code> <p>Expected IGMP snooping configuration (enabled or disabled) for these VLANs.</p> required Source code in <code>anta/tests/multicast.py</code> <pre><code>class VerifyIGMPSnoopingVlans(AntaTest):\n\"\"\"\n    Verifies the IGMP snooping configuration for some VLANs.\n\n    Args:\n        vlans (List[str]): A list of VLANs\n        configuration (str): Expected IGMP snooping configuration (enabled or disabled) for these VLANs.\n    \"\"\"\n\n    name = \"VerifyIGMPSnoopingVlans\"\n    description = \"Verifies the IGMP snooping configuration for some VLANs.\"\n    categories = [\"multicast\", \"igmp\"]\n    commands = [AntaCommand(command=\"show ip igmp snooping\")]\n\n    @AntaTest.anta_test\n    def test(self, vlans: Optional[List[str]] = None, configuration: Optional[str] = None) -&gt; None:\n\"\"\"\n        Run VerifyIGMPSnoopingVlans validation\n\n        Args:\n            vlans: List of VLANs.\n            configuration: Expected IGMP configuration (enabled or disabled) for these VLANs.\n        \"\"\"\n\n        if not vlans or not configuration:\n            self.result.is_skipped(\"VerifyIGMPSnoopingVlans was not run as no vlans or configuration was given\")\n            return\n        if configuration not in [\"enabled\", \"disabled\"]:\n            self.result.is_error(f\"VerifyIGMPSnoopingVlans was not run as 'configuration': {configuration} is not in the allowed values: ['enabled', 'disabled'])\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        self.result.is_success()\n        for vlan in vlans:\n            if vlan not in command_output[\"vlans\"]:\n                self.result.is_failure(f\"Supplied vlan {vlan} is not present on the device.\")\n                continue\n\n            igmp_state = command_output[\"vlans\"][str(vlan)][\"igmpSnoopingState\"]\n            if igmp_state != configuration:\n                self.result.is_failure(f\"IGMP state for vlan {vlan} is {igmp_state}\")\n</code></pre>"},{"location":"api/tests.multicast/#anta.tests.multicast.VerifyIGMPSnoopingVlans.test","title":"<code>test(vlans=None, configuration=None)</code>","text":"<p>Run VerifyIGMPSnoopingVlans validation</p> <p>Parameters:</p> Name Type Description Default <code>vlans</code> <code>Optional[List[str]]</code> <p>List of VLANs.</p> <code>None</code> <code>configuration</code> <code>Optional[str]</code> <p>Expected IGMP configuration (enabled or disabled) for these VLANs.</p> <code>None</code> Source code in <code>anta/tests/multicast.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, vlans: Optional[List[str]] = None, configuration: Optional[str] = None) -&gt; None:\n\"\"\"\n    Run VerifyIGMPSnoopingVlans validation\n\n    Args:\n        vlans: List of VLANs.\n        configuration: Expected IGMP configuration (enabled or disabled) for these VLANs.\n    \"\"\"\n\n    if not vlans or not configuration:\n        self.result.is_skipped(\"VerifyIGMPSnoopingVlans was not run as no vlans or configuration was given\")\n        return\n    if configuration not in [\"enabled\", \"disabled\"]:\n        self.result.is_error(f\"VerifyIGMPSnoopingVlans was not run as 'configuration': {configuration} is not in the allowed values: ['enabled', 'disabled'])\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    self.result.is_success()\n    for vlan in vlans:\n        if vlan not in command_output[\"vlans\"]:\n            self.result.is_failure(f\"Supplied vlan {vlan} is not present on the device.\")\n            continue\n\n        igmp_state = command_output[\"vlans\"][str(vlan)][\"igmpSnoopingState\"]\n        if igmp_state != configuration:\n            self.result.is_failure(f\"IGMP state for vlan {vlan} is {igmp_state}\")\n</code></pre>"},{"location":"api/tests.profiles/","title":"Profiles","text":""},{"location":"api/tests.profiles/#anta-catalog-for-profiles-tests","title":"ANTA catalog for profiles tests","text":"<p>Test functions related to ASIC profiles</p>"},{"location":"api/tests.profiles/#anta.tests.profiles.VerifyTcamProfile","title":"<code>VerifyTcamProfile</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the device is using the configured TCAM profile.</p> Source code in <code>anta/tests/profiles.py</code> <pre><code>class VerifyTcamProfile(AntaTest):\n\"\"\"\n    Verifies the device is using the configured TCAM profile.\n    \"\"\"\n\n    name = \"VerifyTcamProfile\"\n    description = \"Verify that the assigned TCAM profile is actually running on the device\"\n    categories = [\"profiles\"]\n    commands = [AntaCommand(command=\"show hardware tcam profile\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self, profile: Optional[str] = None) -&gt; None:\n\"\"\"\n        Run VerifyTcamProfile validation\n\n        Args:\n            profile: Expected TCAM profile.\n        \"\"\"\n        if not profile:\n            self.result.is_skipped(\"VerifyTcamProfile was not run as no profile was given\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n        if command_output[\"pmfProfiles\"][\"FixedSystem\"][\"status\"] == command_output[\"pmfProfiles\"][\"FixedSystem\"][\"config\"] == profile:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Incorrect profile running on device: {command_output['pmfProfiles']['FixedSystem']['status']}\")\n</code></pre>"},{"location":"api/tests.profiles/#anta.tests.profiles.VerifyTcamProfile.test","title":"<code>test(profile=None)</code>","text":"<p>Run VerifyTcamProfile validation</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[str]</code> <p>Expected TCAM profile.</p> <code>None</code> Source code in <code>anta/tests/profiles.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self, profile: Optional[str] = None) -&gt; None:\n\"\"\"\n    Run VerifyTcamProfile validation\n\n    Args:\n        profile: Expected TCAM profile.\n    \"\"\"\n    if not profile:\n        self.result.is_skipped(\"VerifyTcamProfile was not run as no profile was given\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n    if command_output[\"pmfProfiles\"][\"FixedSystem\"][\"status\"] == command_output[\"pmfProfiles\"][\"FixedSystem\"][\"config\"] == profile:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Incorrect profile running on device: {command_output['pmfProfiles']['FixedSystem']['status']}\")\n</code></pre>"},{"location":"api/tests.profiles/#anta.tests.profiles.VerifyUnifiedForwardingTableMode","title":"<code>VerifyUnifiedForwardingTableMode</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the device is using the expected Unified Forwarding Table mode.</p> Source code in <code>anta/tests/profiles.py</code> <pre><code>class VerifyUnifiedForwardingTableMode(AntaTest):\n\"\"\"\n    Verifies the device is using the expected Unified Forwarding Table mode.\n    \"\"\"\n\n    name = \"VerifyUnifiedForwardingTableMode\"\n    description = \"\"\n    categories = [\"profiles\"]\n    commands = [AntaCommand(command=\"show platform trident forwarding-table partition\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self, mode: Optional[str] = None) -&gt; None:\n\"\"\"\n        Run VerifyUnifiedForwardingTableMode validation\n\n        Args:\n            mode: Expected UFT mode.\n        \"\"\"\n        if not mode:\n            self.result.is_skipped(\"VerifyUnifiedForwardingTableMode was not run as no mode was given\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n        if command_output[\"uftMode\"] == mode:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device is not running correct UFT mode (expected: {mode} / running: {command_output['uftMode']})\")\n</code></pre>"},{"location":"api/tests.profiles/#anta.tests.profiles.VerifyUnifiedForwardingTableMode.test","title":"<code>test(mode=None)</code>","text":"<p>Run VerifyUnifiedForwardingTableMode validation</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>Optional[str]</code> <p>Expected UFT mode.</p> <code>None</code> Source code in <code>anta/tests/profiles.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self, mode: Optional[str] = None) -&gt; None:\n\"\"\"\n    Run VerifyUnifiedForwardingTableMode validation\n\n    Args:\n        mode: Expected UFT mode.\n    \"\"\"\n    if not mode:\n        self.result.is_skipped(\"VerifyUnifiedForwardingTableMode was not run as no mode was given\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n    if command_output[\"uftMode\"] == mode:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Device is not running correct UFT mode (expected: {mode} / running: {command_output['uftMode']})\")\n</code></pre>"},{"location":"api/tests.routing.bgp/","title":"BGP","text":""},{"location":"api/tests.routing.bgp/#anta-catalog-for-routing-bgp-tests","title":"ANTA catalog for routing-bgp tests","text":"<p>BGP test functions</p>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPEVPNCount","title":"<code>VerifyBGPEVPNCount</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies all EVPN BGP sessions are established (default VRF) and the actual number of BGP EVPN neighbors is the one we expect (default VRF).</p> <ul> <li>self.result = \u201cskipped\u201d if the <code>number</code> parameter is missing</li> <li>self.result = \u201csuccess\u201d if all EVPN BGP sessions are Established and if the actual                      number of BGP EVPN neighbors is the one we expect.</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPEVPNCount(AntaTest):\n\"\"\"\n    Verifies all EVPN BGP sessions are established (default VRF)\n    and the actual number of BGP EVPN neighbors is the one we expect (default VRF).\n\n    * self.result = \"skipped\" if the `number` parameter is missing\n    * self.result = \"success\" if all EVPN BGP sessions are Established and if the actual\n                         number of BGP EVPN neighbors is the one we expect.\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPEVPNCount\"\n    description = \"Verifies all EVPN BGP sessions are established (default VRF) and the actual number of BGP EVPN neighbors is the one we expect (default VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaCommand(command=\"show bgp evpn summary\")]\n\n    @check_bgp_family_enable(\"evpn\")\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"\n        Run VerifyBGPEVPNCount validation\n\n        Args:\n            number: The expected number of BGP EVPN neighbors in the default VRF.\n        \"\"\"\n        if not number:\n            self.result.is_skipped(\"VerifyBGPEVPNCount could not run because number was not supplied.\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        peers = command_output[\"vrfs\"][\"default\"][\"peers\"]\n        non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n        if not non_established_peers and len(peers) == number:\n            self.result.is_success()\n        else:\n            self.result.is_failure()\n            if len(peers) != number:\n                self.result.is_failure(f\"Expecting {number} BGP EVPN peers and got {len(peers)}\")\n            if non_established_peers:\n                self.result.is_failure(f\"The following EVPN peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPEVPNCount.test","title":"<code>test(number=None)</code>","text":"<p>Run VerifyBGPEVPNCount validation</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The expected number of BGP EVPN neighbors in the default VRF.</p> <code>None</code> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>@check_bgp_family_enable(\"evpn\")\n@AntaTest.anta_test\ndef test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"\n    Run VerifyBGPEVPNCount validation\n\n    Args:\n        number: The expected number of BGP EVPN neighbors in the default VRF.\n    \"\"\"\n    if not number:\n        self.result.is_skipped(\"VerifyBGPEVPNCount could not run because number was not supplied.\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    peers = command_output[\"vrfs\"][\"default\"][\"peers\"]\n    non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n    if not non_established_peers and len(peers) == number:\n        self.result.is_success()\n    else:\n        self.result.is_failure()\n        if len(peers) != number:\n            self.result.is_failure(f\"Expecting {number} BGP EVPN peers and got {len(peers)}\")\n        if non_established_peers:\n            self.result.is_failure(f\"The following EVPN peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPEVPNState","title":"<code>VerifyBGPEVPNState</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies all EVPN BGP sessions are established (default VRF).</p> <ul> <li>self.result = \u201cskipped\u201d if no BGP EVPN peers are returned by the device</li> <li>self.result = \u201csuccess\u201d if all EVPN BGP sessions are established.</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPEVPNState(AntaTest):\n\"\"\"\n    Verifies all EVPN BGP sessions are established (default VRF).\n\n    * self.result = \"skipped\" if no BGP EVPN peers are returned by the device\n    * self.result = \"success\" if all EVPN BGP sessions are established.\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPEVPNState\"\n    description = \"Verifies all EVPN BGP sessions are established (default VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaCommand(command=\"show bgp evpn summary\")]\n\n    @check_bgp_family_enable(\"evpn\")\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyBGPEVPNState validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        bgp_vrfs = command_output[\"vrfs\"]\n\n        peers = bgp_vrfs[\"default\"][\"peers\"]\n        non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n        if not non_established_peers:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following EVPN peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPEVPNState.test","title":"<code>test()</code>","text":"<p>Run VerifyBGPEVPNState validation</p> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>@check_bgp_family_enable(\"evpn\")\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyBGPEVPNState validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    bgp_vrfs = command_output[\"vrfs\"]\n\n    peers = bgp_vrfs[\"default\"][\"peers\"]\n    non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n    if not non_established_peers:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following EVPN peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPIPv4UnicastCount","title":"<code>VerifyBGPIPv4UnicastCount</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies all IPv4 unicast BGP sessions are established and all BGP messages queues for these sessions are empty and the actual number of BGP IPv4 unicast neighbors is the one we expect.</p> <ul> <li>self.result = \u201cskipped\u201d if the <code>number</code> or <code>vrf</code> parameter is missing</li> <li>self.result = \u201csuccess\u201d if all IPv4 unicast BGP sessions are established                      and if all BGP messages queues for these sessions are empty                      and if the actual number of BGP IPv4 unicast neighbors is equal to `number.</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPIPv4UnicastCount(AntaTest):\n\"\"\"\n    Verifies all IPv4 unicast BGP sessions are established\n    and all BGP messages queues for these sessions are empty\n    and the actual number of BGP IPv4 unicast neighbors is the one we expect.\n\n    * self.result = \"skipped\" if the `number` or `vrf` parameter is missing\n    * self.result = \"success\" if all IPv4 unicast BGP sessions are established\n                         and if all BGP messages queues for these sessions are empty\n                         and if the actual number of BGP IPv4 unicast neighbors is equal to `number.\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPIPv4UnicastCount\"\n    description = (\n        \"Verifies all IPv4 unicast BGP sessions are established and all their BGP messages queues are empty and \"\n        \" the actual number of BGP IPv4 unicast neighbors is the one we expect.\"\n    )\n    categories = [\"routing\", \"bgp\"]\n    template = AntaTemplate(template=\"show bgp ipv4 unicast summary vrf {vrf}\")\n\n    @check_bgp_family_enable(\"ipv4\")\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"\n        Run VerifyBGPIPv4UnicastCount validation\n\n        Args:\n            number: The expected number of BGP IPv4 unicast neighbors.\n            vrf: VRF to verify (template parameter)\n        \"\"\"\n\n        if not number:\n            self.result.is_skipped(\"VerifyBGPIPv4UnicastCount could not run because number was not supplied\")\n            return\n\n        self.result.is_success()\n\n        for command in self.instance_commands:\n            if command.params and \"vrf\" in command.params:\n                vrf = command.params[\"vrf\"]\n\n            peers = command.json_output[\"vrfs\"][vrf][\"peers\"]\n            state_issue = _check_bgp_vrfs(command.json_output[\"vrfs\"])\n\n            if len(peers) != number:\n                self.result.is_failure(f\"Expecting {number} BGP peer in vrf {vrf} and got {len(peers)}\")\n            if state_issue:\n                self.result.is_failure(f\"The following IPv4 peers are not established: {state_issue}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPIPv4UnicastCount.test","title":"<code>test(number=None)</code>","text":"<p>Run VerifyBGPIPv4UnicastCount validation</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The expected number of BGP IPv4 unicast neighbors.</p> <code>None</code> <code>vrf</code> <p>VRF to verify (template parameter)</p> required Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>@check_bgp_family_enable(\"ipv4\")\n@AntaTest.anta_test\ndef test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"\n    Run VerifyBGPIPv4UnicastCount validation\n\n    Args:\n        number: The expected number of BGP IPv4 unicast neighbors.\n        vrf: VRF to verify (template parameter)\n    \"\"\"\n\n    if not number:\n        self.result.is_skipped(\"VerifyBGPIPv4UnicastCount could not run because number was not supplied\")\n        return\n\n    self.result.is_success()\n\n    for command in self.instance_commands:\n        if command.params and \"vrf\" in command.params:\n            vrf = command.params[\"vrf\"]\n\n        peers = command.json_output[\"vrfs\"][vrf][\"peers\"]\n        state_issue = _check_bgp_vrfs(command.json_output[\"vrfs\"])\n\n        if len(peers) != number:\n            self.result.is_failure(f\"Expecting {number} BGP peer in vrf {vrf} and got {len(peers)}\")\n        if state_issue:\n            self.result.is_failure(f\"The following IPv4 peers are not established: {state_issue}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPIPv4UnicastState","title":"<code>VerifyBGPIPv4UnicastState</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF).</p> <ul> <li>self.result = \u201cskipped\u201d if no BGP vrf are returned by the device</li> <li>self.result = \u201csuccess\u201d if all IPv4 unicast BGP sessions are established (for all VRF)                      and all BGP messages queues for these sessions are empty (for all VRF).</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPIPv4UnicastState(AntaTest):\n\"\"\"\n    Verifies all IPv4 unicast BGP sessions are established (for all VRF)\n    and all BGP messages queues for these sessions are empty (for all VRF).\n\n    * self.result = \"skipped\" if no BGP vrf are returned by the device\n    * self.result = \"success\" if all IPv4 unicast BGP sessions are established (for all VRF)\n                         and all BGP messages queues for these sessions are empty (for all VRF).\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPIPv4UnicastState\"\n    description = \"Verifies all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaCommand(command=\"show bgp ipv4 unicast summary vrf all\")]\n\n    @check_bgp_family_enable(\"ipv4\")\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyBGPIPv4UnicastState validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n        state_issue = _check_bgp_vrfs(command_output[\"vrfs\"])\n\n        if not state_issue:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Some IPv4 Unicast BGP Peer are not up: {state_issue}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPIPv4UnicastState.test","title":"<code>test()</code>","text":"<p>Run VerifyBGPIPv4UnicastState validation</p> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>@check_bgp_family_enable(\"ipv4\")\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyBGPIPv4UnicastState validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n    state_issue = _check_bgp_vrfs(command_output[\"vrfs\"])\n\n    if not state_issue:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Some IPv4 Unicast BGP Peer are not up: {state_issue}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPIPv6UnicastState","title":"<code>VerifyBGPIPv6UnicastState</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF).</p> <ul> <li>self.result = \u201cskipped\u201d if no BGP vrf are returned by the device</li> <li>self.result = \u201csuccess\u201d if all IPv6 unicast BGP sessions are established (for all VRF)                      and all BGP messages queues for these sessions are empty (for all VRF).</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPIPv6UnicastState(AntaTest):\n\"\"\"\n    Verifies all IPv6 unicast BGP sessions are established (for all VRF)\n    and all BGP messages queues for these sessions are empty (for all VRF).\n\n    * self.result = \"skipped\" if no BGP vrf are returned by the device\n    * self.result = \"success\" if all IPv6 unicast BGP sessions are established (for all VRF)\n                         and all BGP messages queues for these sessions are empty (for all VRF).\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPIPv6UnicastState\"\n    description = \"Verifies all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaCommand(command=\"show bgp ipv6 unicast summary vrf all\")]\n\n    @check_bgp_family_enable(\"ipv6\")\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyBGPIPv6UnicastState validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        state_issue = _check_bgp_vrfs(command_output[\"vrfs\"])\n\n        if not state_issue:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Some IPv4 Unicast BGP Peer are not up: {state_issue}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPIPv6UnicastState.test","title":"<code>test()</code>","text":"<p>Run VerifyBGPIPv6UnicastState validation</p> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>@check_bgp_family_enable(\"ipv6\")\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyBGPIPv6UnicastState validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    state_issue = _check_bgp_vrfs(command_output[\"vrfs\"])\n\n    if not state_issue:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Some IPv4 Unicast BGP Peer are not up: {state_issue}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPRTCCount","title":"<code>VerifyBGPRTCCount</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies all RTC BGP sessions are established (default VRF) and the actual number of BGP RTC neighbors is the one we expect (default VRF).</p> <ul> <li>self.result = \u201cskipped\u201d if the <code>number</code> parameter is missing</li> <li>self.result = \u201csuccess\u201d if all RTC BGP sessions are Established and if the actual                      number of BGP RTC neighbors is the one we expect.</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPRTCCount(AntaTest):\n\"\"\"\n    Verifies all RTC BGP sessions are established (default VRF)\n    and the actual number of BGP RTC neighbors is the one we expect (default VRF).\n\n    * self.result = \"skipped\" if the `number` parameter is missing\n    * self.result = \"success\" if all RTC BGP sessions are Established and if the actual\n                         number of BGP RTC neighbors is the one we expect.\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPRTCCount\"\n    description = \"Verifies all RTC BGP sessions are established (default VRF) and the actual number of BGP RTC neighbors is the one we expect (default VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaCommand(command=\"show bgp rt-membership summary\")]\n\n    @check_bgp_family_enable(\"rtc\")\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"\n        Run VerifyBGPRTCCount validation\n\n        Args:\n            number: The expected number of BGP RTC neighbors (default VRF).\n        \"\"\"\n        if not number:\n            self.result.is_skipped(\"VerifyBGPRTCCount could not run because number was not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        peers = command_output[\"vrfs\"][\"default\"][\"peers\"]\n        non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n        if not non_established_peers and len(peers) == number:\n            self.result.is_success()\n        else:\n            self.result.is_failure()\n            if len(peers) != number:\n                self.result.is_failure(f\"Expecting {number} BGP RTC peers and got {len(peers)}\")\n            if non_established_peers:\n                self.result.is_failure(f\"The following RTC peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPRTCCount.test","title":"<code>test(number=None)</code>","text":"<p>Run VerifyBGPRTCCount validation</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The expected number of BGP RTC neighbors (default VRF).</p> <code>None</code> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>@check_bgp_family_enable(\"rtc\")\n@AntaTest.anta_test\ndef test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"\n    Run VerifyBGPRTCCount validation\n\n    Args:\n        number: The expected number of BGP RTC neighbors (default VRF).\n    \"\"\"\n    if not number:\n        self.result.is_skipped(\"VerifyBGPRTCCount could not run because number was not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    peers = command_output[\"vrfs\"][\"default\"][\"peers\"]\n    non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n    if not non_established_peers and len(peers) == number:\n        self.result.is_success()\n    else:\n        self.result.is_failure()\n        if len(peers) != number:\n            self.result.is_failure(f\"Expecting {number} BGP RTC peers and got {len(peers)}\")\n        if non_established_peers:\n            self.result.is_failure(f\"The following RTC peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPRTCState","title":"<code>VerifyBGPRTCState</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies all RTC BGP sessions are established (default VRF).</p> <ul> <li>self.result = \u201cskipped\u201d if no BGP RTC peers are returned by the device</li> <li>self.result = \u201csuccess\u201d if all RTC BGP sessions are established.</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPRTCState(AntaTest):\n\"\"\"\n    Verifies all RTC BGP sessions are established (default VRF).\n\n    * self.result = \"skipped\" if no BGP RTC peers are returned by the device\n    * self.result = \"success\" if all RTC BGP sessions are established.\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPRTCState\"\n    description = \"Verifies all RTC BGP sessions are established (default VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaCommand(command=\"show bgp rt-membership summary\")]\n\n    @check_bgp_family_enable(\"rtc\")\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyBGPRTCState validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        bgp_vrfs = command_output[\"vrfs\"]\n\n        peers = bgp_vrfs[\"default\"][\"peers\"]\n        non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n        if not non_established_peers:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following RTC peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPRTCState.test","title":"<code>test()</code>","text":"<p>Run VerifyBGPRTCState validation</p> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>@check_bgp_family_enable(\"rtc\")\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyBGPRTCState validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    bgp_vrfs = command_output[\"vrfs\"]\n\n    peers = bgp_vrfs[\"default\"][\"peers\"]\n    non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n    if not non_established_peers:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following RTC peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.generic/","title":"Generic","text":""},{"location":"api/tests.routing.generic/#anta-catalog-for-routing-generic-tests","title":"ANTA catalog for routing-generic tests","text":"<p>Generic routing test functions</p>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyBFD","title":"<code>VerifyBFD</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies there is no BFD peer in down state (all VRF, IPv4 neighbors).</p> Source code in <code>anta/tests/routing/generic.py</code> <pre><code>class VerifyBFD(AntaTest):\n\"\"\"\n    Verifies there is no BFD peer in down state (all VRF, IPv4 neighbors).\n    \"\"\"\n\n    name = \"VerifyBFD\"\n    description = \"Verifies there is no BFD peer in down state (all VRF, IPv4 neighbors).\"\n    categories = [\"routing\", \"generic\"]\n    # revision 1 as later revision introduce additional nesting for type\n    commands = [AntaCommand(command=\"show bfd peers\", revision=1)]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyBFD validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        self.result.is_success()\n\n        for _, vrf_data in command_output[\"vrfs\"].items():\n            for _, neighbor_data in vrf_data[\"ipv4Neighbors\"].items():\n                for peer, peer_data in neighbor_data[\"peerStats\"].items():\n                    if (peer_status := peer_data[\"status\"]) != \"up\":\n                        failure_message = f\"bfd state for peer '{peer}' is {peer_status} (expected up).\"\n                        if (peer_l3intf := peer_data.get(\"l3intf\")) is not None and peer_l3intf != \"\":\n                            failure_message += f\" Interface: {peer_l3intf}.\"\n                        self.result.is_failure(failure_message)\n</code></pre>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyBFD.test","title":"<code>test()</code>","text":"<p>Run VerifyBFD validation</p> Source code in <code>anta/tests/routing/generic.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyBFD validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    self.result.is_success()\n\n    for _, vrf_data in command_output[\"vrfs\"].items():\n        for _, neighbor_data in vrf_data[\"ipv4Neighbors\"].items():\n            for peer, peer_data in neighbor_data[\"peerStats\"].items():\n                if (peer_status := peer_data[\"status\"]) != \"up\":\n                    failure_message = f\"bfd state for peer '{peer}' is {peer_status} (expected up).\"\n                    if (peer_l3intf := peer_data.get(\"l3intf\")) is not None and peer_l3intf != \"\":\n                        failure_message += f\" Interface: {peer_l3intf}.\"\n                    self.result.is_failure(failure_message)\n</code></pre>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingProtocolModel","title":"<code>VerifyRoutingProtocolModel</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the configured routing protocol model is the one we expect. And if there is no mismatch between the configured and operating routing protocol model.</p> <pre><code>model(str): Expected routing protocol model (multi-agent or ribd). Default is multi-agent\n</code></pre> Source code in <code>anta/tests/routing/generic.py</code> <pre><code>class VerifyRoutingProtocolModel(AntaTest):\n\"\"\"\n    Verifies the configured routing protocol model is the one we expect.\n    And if there is no mismatch between the configured and operating routing protocol model.\n\n        model(str): Expected routing protocol model (multi-agent or ribd). Default is multi-agent\n    \"\"\"\n\n    name = \"VerifyRoutingProtocolModel\"\n    description = (\n        \"Verifies the configured routing protocol model is the expected one and if there is no mismatch between the configured and operating routing protocol model.\"\n    )\n    categories = [\"routing\", \"generic\"]\n    # \"revision\": 3\n    commands = [AntaCommand(command=\"show ip route summary\")]\n\n    @AntaTest.anta_test\n    def test(self, model: Optional[str] = \"multi-agent\") -&gt; None:\n\"\"\"Run VerifyRoutingProtocolModel validation\"\"\"\n\n        if not model:\n            self.result.is_skipped(\"VerifyRoutingProtocolModel was not run as no model was given\")\n            return\n        command_output = self.instance_commands[0].json_output\n\n        configured_model = command_output[\"protoModelStatus\"][\"configuredProtoModel\"]\n        operating_model = command_output[\"protoModelStatus\"][\"operatingProtoModel\"]\n        if configured_model == operating_model == model:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"routing model is misconfigured: configured: {configured_model} - operating: {operating_model} - expected: {model}\")\n</code></pre>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingProtocolModel.test","title":"<code>test(model='multi-agent')</code>","text":"<p>Run VerifyRoutingProtocolModel validation</p> Source code in <code>anta/tests/routing/generic.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, model: Optional[str] = \"multi-agent\") -&gt; None:\n\"\"\"Run VerifyRoutingProtocolModel validation\"\"\"\n\n    if not model:\n        self.result.is_skipped(\"VerifyRoutingProtocolModel was not run as no model was given\")\n        return\n    command_output = self.instance_commands[0].json_output\n\n    configured_model = command_output[\"protoModelStatus\"][\"configuredProtoModel\"]\n    operating_model = command_output[\"protoModelStatus\"][\"operatingProtoModel\"]\n    if configured_model == operating_model == model:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"routing model is misconfigured: configured: {configured_model} - operating: {operating_model} - expected: {model}\")\n</code></pre>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingTableSize","title":"<code>VerifyRoutingTableSize</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the size of the IP routing table (default VRF). Should be between the two provided thresholds.</p> <p>Parameters:</p> Name Type Description Default <code>minimum(int)</code> <p>Expected minimum routing table (default VRF) size.</p> required <code>maximum(int)</code> <p>Expected maximum routing table (default VRF) size.</p> required Source code in <code>anta/tests/routing/generic.py</code> <pre><code>class VerifyRoutingTableSize(AntaTest):\n\"\"\"\n    Verifies the size of the IP routing table (default VRF).\n    Should be between the two provided thresholds.\n\n    Args:\n        minimum(int): Expected minimum routing table (default VRF) size.\n        maximum(int): Expected maximum routing table (default VRF) size.\n    \"\"\"\n\n    name = \"VerifyRoutingTableSize\"\n    description = \"Verifies the size of the IP routing table (default VRF). Should be between the two provided thresholds.\"\n    categories = [\"routing\", \"generic\"]\n    # \"revision\": 3\n    commands = [AntaCommand(command=\"show ip route summary\")]\n\n    @AntaTest.anta_test\n    def test(self, minimum: Optional[int] = None, maximum: Optional[int] = None) -&gt; None:\n\"\"\"Run VerifyRoutingTableSize validation\"\"\"\n\n        if not minimum or not maximum:\n            self.result.is_skipped(f\"VerifyRoutingTableSize was not run as either minimum {minimum} or maximum {maximum} was not provided\")\n            return\n        if not isinstance(minimum, int) or not isinstance(maximum, int):\n            self.result.is_error(f\"VerifyRoutingTableSize was not run as either minimum {minimum} or maximum {maximum} is not a valid value (integer)\")\n            return\n        if maximum &lt; minimum:\n            self.result.is_error(f\"VerifyRoutingTableSize was not run as minimum {minimum} is greate than maximum {maximum}.\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n        total_routes = int(command_output[\"vrfs\"][\"default\"][\"totalRoutes\"])\n        if minimum &lt;= total_routes &lt;= maximum:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"routing-table has {total_routes} routes and not between min ({minimum}) and maximum ({maximum})\")\n</code></pre>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingTableSize.test","title":"<code>test(minimum=None, maximum=None)</code>","text":"<p>Run VerifyRoutingTableSize validation</p> Source code in <code>anta/tests/routing/generic.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, minimum: Optional[int] = None, maximum: Optional[int] = None) -&gt; None:\n\"\"\"Run VerifyRoutingTableSize validation\"\"\"\n\n    if not minimum or not maximum:\n        self.result.is_skipped(f\"VerifyRoutingTableSize was not run as either minimum {minimum} or maximum {maximum} was not provided\")\n        return\n    if not isinstance(minimum, int) or not isinstance(maximum, int):\n        self.result.is_error(f\"VerifyRoutingTableSize was not run as either minimum {minimum} or maximum {maximum} is not a valid value (integer)\")\n        return\n    if maximum &lt; minimum:\n        self.result.is_error(f\"VerifyRoutingTableSize was not run as minimum {minimum} is greate than maximum {maximum}.\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n    total_routes = int(command_output[\"vrfs\"][\"default\"][\"totalRoutes\"])\n    if minimum &lt;= total_routes &lt;= maximum:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"routing-table has {total_routes} routes and not between min ({minimum}) and maximum ({maximum})\")\n</code></pre>"},{"location":"api/tests.routing.ospf/","title":"OSPF","text":""},{"location":"api/tests.routing.ospf/#anta-catalog-for-routing-ospf-tests","title":"ANTA catalog for routing-ospf tests","text":"<p>OSPF test functions</p>"},{"location":"api/tests.routing.ospf/#anta.tests.routing.ospf.VerifyOSPFNeighborCount","title":"<code>VerifyOSPFNeighborCount</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the number of OSPF neighbors in FULL state is the one we expect.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>The expected number of OSPF neighbors in FULL state.</p> required Source code in <code>anta/tests/routing/ospf.py</code> <pre><code>class VerifyOSPFNeighborCount(AntaTest):\n\"\"\"\n    Verifies the number of OSPF neighbors in FULL state is the one we expect.\n\n    Args:\n        number (int): The expected number of OSPF neighbors in FULL state.\n    \"\"\"\n\n    name = \"VerifyOSPFNeighborCount\"\n    description = \"Verifies the number of OSPF neighbors in FULL state is the one we expect.\"\n    categories = [\"routing\", \"ospf\"]\n    commands = [AntaCommand(command=\"show ip ospf neighbor\")]\n\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"Run VerifyOSPFNeighborCount validation\"\"\"\n        if not (isinstance(number, int) and number &gt;= 0):\n            self.result.is_skipped(f\"VerifyOSPFNeighborCount was not run as the number given '{number}' is not a valid value.\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        if (neighbor_count := _count_ospf_neighbor(command_output)) == 0:\n            self.result.is_skipped(\"no OSPF neighbor found\")\n            return\n\n        self.result.is_success()\n\n        if neighbor_count != number:\n            self.result.is_failure(f\"device has {neighbor_count} neighbors (expected {number})\")\n\n        not_full_neighbors = _get_not_full_ospf_neighbors(command_output)\n        print(not_full_neighbors)\n        if not_full_neighbors:\n            self.result.is_failure(f\"Some neighbors are not correctly configured: {not_full_neighbors}.\")\n</code></pre>"},{"location":"api/tests.routing.ospf/#anta.tests.routing.ospf.VerifyOSPFNeighborCount.test","title":"<code>test(number=None)</code>","text":"<p>Run VerifyOSPFNeighborCount validation</p> Source code in <code>anta/tests/routing/ospf.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"Run VerifyOSPFNeighborCount validation\"\"\"\n    if not (isinstance(number, int) and number &gt;= 0):\n        self.result.is_skipped(f\"VerifyOSPFNeighborCount was not run as the number given '{number}' is not a valid value.\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    if (neighbor_count := _count_ospf_neighbor(command_output)) == 0:\n        self.result.is_skipped(\"no OSPF neighbor found\")\n        return\n\n    self.result.is_success()\n\n    if neighbor_count != number:\n        self.result.is_failure(f\"device has {neighbor_count} neighbors (expected {number})\")\n\n    not_full_neighbors = _get_not_full_ospf_neighbors(command_output)\n    print(not_full_neighbors)\n    if not_full_neighbors:\n        self.result.is_failure(f\"Some neighbors are not correctly configured: {not_full_neighbors}.\")\n</code></pre>"},{"location":"api/tests.routing.ospf/#anta.tests.routing.ospf.VerifyOSPFNeighborState","title":"<code>VerifyOSPFNeighborState</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies all OSPF neighbors are in FULL state.</p> Source code in <code>anta/tests/routing/ospf.py</code> <pre><code>class VerifyOSPFNeighborState(AntaTest):\n\"\"\"\n    Verifies all OSPF neighbors are in FULL state.\n    \"\"\"\n\n    name = \"VerifyOSPFNeighborState\"\n    description = \"Verifies all OSPF neighbors are in FULL state.\"\n    categories = [\"routing\", \"ospf\"]\n    commands = [AntaCommand(command=\"show ip ospf neighbor\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyOSPFNeighborState validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if _count_ospf_neighbor(command_output) == 0:\n            self.result.is_skipped(\"no OSPF neighbor found\")\n            return\n\n        self.result.is_success()\n\n        not_full_neighbors = _get_not_full_ospf_neighbors(command_output)\n        if not_full_neighbors:\n            self.result.is_failure(f\"Some neighbors are not correctly configured: {not_full_neighbors}.\")\n</code></pre>"},{"location":"api/tests.routing.ospf/#anta.tests.routing.ospf.VerifyOSPFNeighborState.test","title":"<code>test()</code>","text":"<p>Run VerifyOSPFNeighborState validation</p> Source code in <code>anta/tests/routing/ospf.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyOSPFNeighborState validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if _count_ospf_neighbor(command_output) == 0:\n        self.result.is_skipped(\"no OSPF neighbor found\")\n        return\n\n    self.result.is_success()\n\n    not_full_neighbors = _get_not_full_ospf_neighbors(command_output)\n    if not_full_neighbors:\n        self.result.is_failure(f\"Some neighbors are not correctly configured: {not_full_neighbors}.\")\n</code></pre>"},{"location":"api/tests.security/","title":"Security","text":""},{"location":"api/tests.security/#anta-catalog-for-security-tests","title":"ANTA catalog for security tests","text":"<p>Test functions related to the EOS various security settings</p>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIHttpStatus","title":"<code>VerifyAPIHttpStatus</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if eAPI HTTP server is disabled globally.</p> Expected Results <ul> <li>success: The test will pass if eAPI HTTP server is disabled globally.</li> <li>failure: The test will fail if eAPI HTTP server is NOT disabled globally.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifyAPIHttpStatus(AntaTest):\n\"\"\"\n    Verifies if eAPI HTTP server is disabled globally.\n\n    Expected Results:\n        * success: The test will pass if eAPI HTTP server is disabled globally.\n        * failure: The test will fail if eAPI HTTP server is NOT disabled globally.\n    \"\"\"\n\n    name = \"VerifyAPIHttpStatus\"\n    description = \"Verifies if eAPI HTTP server is disabled globally.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management api http-commands\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyAPIHTTPStatus validation.\n        \"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if command_output[\"enabled\"] and not command_output[\"httpServer\"][\"running\"]:\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"eAPI HTTP server is enabled globally\")\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIHttpStatus.test","title":"<code>test()</code>","text":"<p>Run VerifyAPIHTTPStatus validation.</p> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyAPIHTTPStatus validation.\n    \"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if command_output[\"enabled\"] and not command_output[\"httpServer\"][\"running\"]:\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"eAPI HTTP server is enabled globally\")\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIHttpsSSL","title":"<code>VerifyAPIHttpsSSL</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if eAPI HTTPS server SSL profile is configured and valid.</p> Expected results <ul> <li>success: The test will pass if the eAPI HTTPS server SSL profile is configured and valid.</li> <li>failure: The test will fail if the eAPI HTTPS server SSL profile is NOT configured, misconfigured or invalid.</li> <li>skipped: The test will be skipped if the SSL profile is not provided.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifyAPIHttpsSSL(AntaTest):\n\"\"\"\n    Verifies if eAPI HTTPS server SSL profile is configured and valid.\n\n    Expected results:\n        * success: The test will pass if the eAPI HTTPS server SSL profile is configured and valid.\n        * failure: The test will fail if the eAPI HTTPS server SSL profile is NOT configured, misconfigured or invalid.\n        * skipped: The test will be skipped if the SSL profile is not provided.\n    \"\"\"\n\n    name = \"VerifyAPIHttpsSSL\"\n    description = \"Verifies if eAPI HTTPS server SSL profile is configured and valid.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management api http-commands\")]\n\n    @AntaTest.anta_test\n    def test(self, profile: Optional[str] = None) -&gt; None:\n\"\"\"\n        Run VerifyAPIHttpsSSL validation.\n\n        Args:\n            profile: SSL profile to verify.\n        \"\"\"\n        if not profile:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because profile was not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        try:\n            if command_output[\"sslProfile\"][\"name\"] == profile and command_output[\"sslProfile\"][\"state\"] == \"valid\":\n                self.result.is_success()\n            else:\n                self.result.is_failure(f\"eAPI HTTPS server SSL profile ({profile}) is misconfigured or invalid\")\n\n        except KeyError:\n            self.result.is_failure(f\"eAPI HTTPS server SSL profile ({profile}) is not configured\")\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIHttpsSSL.test","title":"<code>test(profile=None)</code>","text":"<p>Run VerifyAPIHttpsSSL validation.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[str]</code> <p>SSL profile to verify.</p> <code>None</code> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, profile: Optional[str] = None) -&gt; None:\n\"\"\"\n    Run VerifyAPIHttpsSSL validation.\n\n    Args:\n        profile: SSL profile to verify.\n    \"\"\"\n    if not profile:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because profile was not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    try:\n        if command_output[\"sslProfile\"][\"name\"] == profile and command_output[\"sslProfile\"][\"state\"] == \"valid\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"eAPI HTTPS server SSL profile ({profile}) is misconfigured or invalid\")\n\n    except KeyError:\n        self.result.is_failure(f\"eAPI HTTPS server SSL profile ({profile}) is not configured\")\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIIPv4Acl","title":"<code>VerifyAPIIPv4Acl</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if eAPI has the right number IPv4 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if eAPI has the provided number of IPv4 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if eAPI has not the right number of IPv4 ACL(s) in the specified VRF.</li> <li>skipped: The test will be skipped if the number of IPv4 ACL(s) or VRF parameter is not provided.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifyAPIIPv4Acl(AntaTest):\n\"\"\"\n    Verifies if eAPI has the right number IPv4 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if eAPI has the provided number of IPv4 ACL(s) in the specified VRF.\n        * failure: The test will fail if eAPI has not the right number of IPv4 ACL(s) in the specified VRF.\n        * skipped: The test will be skipped if the number of IPv4 ACL(s) or VRF parameter is not provided.\n    \"\"\"\n\n    name = \"VerifyAPIIPv4Acl\"\n    description = \"Verifies if eAPI has the right number IPv4 ACL(s) configured for a specified VRF.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management api http-commands ip access-list summary\")]\n\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifyAPIIPv4Acl validation.\n\n        Args:\n            number: The number of expected IPv4 ACL(s).\n            vrf: The name of the VRF in which to check for eAPI. Defaults to 'default'.\n        \"\"\"\n        if not number or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        ipv4_acl_list = command_output[\"ipAclList\"][\"aclList\"]\n        ipv4_acl_number = len(ipv4_acl_list)\n        not_configured_acl_list = []\n\n        if ipv4_acl_number != number:\n            self.result.is_failure(f\"Expected {number} eAPI IPv4 ACL(s) in vrf {vrf} but got {ipv4_acl_number}\")\n            return\n\n        for ipv4_acl in ipv4_acl_list:\n            if vrf not in ipv4_acl[\"configuredVrfs\"] or vrf not in ipv4_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv4_acl[\"name\"])\n\n        if not_configured_acl_list:\n            self.result.is_failure(f\"eAPI IPv4 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIIPv4Acl.test","title":"<code>test(number=None, vrf='default')</code>","text":"<p>Run VerifyAPIIPv4Acl validation.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The number of expected IPv4 ACL(s).</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF in which to check for eAPI. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifyAPIIPv4Acl validation.\n\n    Args:\n        number: The number of expected IPv4 ACL(s).\n        vrf: The name of the VRF in which to check for eAPI. Defaults to 'default'.\n    \"\"\"\n    if not number or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    ipv4_acl_list = command_output[\"ipAclList\"][\"aclList\"]\n    ipv4_acl_number = len(ipv4_acl_list)\n    not_configured_acl_list = []\n\n    if ipv4_acl_number != number:\n        self.result.is_failure(f\"Expected {number} eAPI IPv4 ACL(s) in vrf {vrf} but got {ipv4_acl_number}\")\n        return\n\n    for ipv4_acl in ipv4_acl_list:\n        if vrf not in ipv4_acl[\"configuredVrfs\"] or vrf not in ipv4_acl[\"activeVrfs\"]:\n            not_configured_acl_list.append(ipv4_acl[\"name\"])\n\n    if not_configured_acl_list:\n        self.result.is_failure(f\"eAPI IPv4 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIIPv6Acl","title":"<code>VerifyAPIIPv6Acl</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if eAPI has the right number IPv6 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if eAPI has the provided number of IPv6 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if eAPI has not the right number of IPv6 ACL(s) in the specified VRF.</li> <li>skipped: The test will be skipped if the number of IPv6 ACL(s) or VRF parameter is not provided.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifyAPIIPv6Acl(AntaTest):\n\"\"\"\n    Verifies if eAPI has the right number IPv6 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if eAPI has the provided number of IPv6 ACL(s) in the specified VRF.\n        * failure: The test will fail if eAPI has not the right number of IPv6 ACL(s) in the specified VRF.\n        * skipped: The test will be skipped if the number of IPv6 ACL(s) or VRF parameter is not provided.\n    \"\"\"\n\n    name = \"VerifyAPIIPv6Acl\"\n    description = \"Verifies if eAPI has the right number IPv6 ACL(s) configured for a specified VRF.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management api http-commands ipv6 access-list summary\")]\n\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifyAPIIPv6Acl validation.\n\n        Args:\n            number: The number of expected IPv6 ACL(s).\n            vrf: The name of the VRF in which to check for eAPI. Defaults to 'default'.\n        \"\"\"\n        if not number or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        ipv6_acl_list = command_output[\"ipv6AclList\"][\"aclList\"]\n        ipv6_acl_number = len(ipv6_acl_list)\n        not_configured_acl_list = []\n\n        if ipv6_acl_number != number:\n            self.result.is_failure(f\"Expected {number} eAPI IPv6 ACL(s) in vrf {vrf} but got {ipv6_acl_number}\")\n            return\n\n        for ipv6_acl in ipv6_acl_list:\n            if vrf not in ipv6_acl[\"configuredVrfs\"] or vrf not in ipv6_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv6_acl[\"name\"])\n\n        if not_configured_acl_list:\n            self.result.is_failure(f\"eAPI IPv6 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIIPv6Acl.test","title":"<code>test(number=None, vrf='default')</code>","text":"<p>Run VerifyAPIIPv6Acl validation.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The number of expected IPv6 ACL(s).</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF in which to check for eAPI. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifyAPIIPv6Acl validation.\n\n    Args:\n        number: The number of expected IPv6 ACL(s).\n        vrf: The name of the VRF in which to check for eAPI. Defaults to 'default'.\n    \"\"\"\n    if not number or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    ipv6_acl_list = command_output[\"ipv6AclList\"][\"aclList\"]\n    ipv6_acl_number = len(ipv6_acl_list)\n    not_configured_acl_list = []\n\n    if ipv6_acl_number != number:\n        self.result.is_failure(f\"Expected {number} eAPI IPv6 ACL(s) in vrf {vrf} but got {ipv6_acl_number}\")\n        return\n\n    for ipv6_acl in ipv6_acl_list:\n        if vrf not in ipv6_acl[\"configuredVrfs\"] or vrf not in ipv6_acl[\"activeVrfs\"]:\n            not_configured_acl_list.append(ipv6_acl[\"name\"])\n\n    if not_configured_acl_list:\n        self.result.is_failure(f\"eAPI IPv6 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHIPv4Acl","title":"<code>VerifySSHIPv4Acl</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if the SSHD agent has the right number IPv4 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if the SSHD agent has the provided number of IPv4 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if the SSHD agent has not the right number of IPv4 ACL(s) in the specified VRF.</li> <li>skipped: The test will be skipped if the number of IPv4 ACL(s) or VRF parameter is not provided.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifySSHIPv4Acl(AntaTest):\n\"\"\"\n    Verifies if the SSHD agent has the right number IPv4 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if the SSHD agent has the provided number of IPv4 ACL(s) in the specified VRF.\n        * failure: The test will fail if the SSHD agent has not the right number of IPv4 ACL(s) in the specified VRF.\n        * skipped: The test will be skipped if the number of IPv4 ACL(s) or VRF parameter is not provided.\n    \"\"\"\n\n    name = \"VerifySSHIPv4Acl\"\n    description = \"Verifies if the SSHD agent has IPv4 ACL(s) configured.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management ssh ip access-list summary\")]\n\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifySSHIPv4Acl validation.\n\n        Args:\n            number: The number of expected IPv4 ACL(s).\n            vrf: The name of the VRF in which to check for the SSHD agent. Defaults to 'default'.\n        \"\"\"\n        if not number or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        ipv4_acl_list = command_output[\"ipAclList\"][\"aclList\"]\n        ipv4_acl_number = len(ipv4_acl_list)\n        not_configured_acl_list = []\n\n        if ipv4_acl_number != number:\n            self.result.is_failure(f\"Expected {number} SSH IPv4 ACL(s) in vrf {vrf} but got {ipv4_acl_number}\")\n            return\n\n        for ipv4_acl in ipv4_acl_list:\n            if vrf not in ipv4_acl[\"configuredVrfs\"] or vrf not in ipv4_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv4_acl[\"name\"])\n\n        if not_configured_acl_list:\n            self.result.is_failure(f\"SSH IPv4 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHIPv4Acl.test","title":"<code>test(number=None, vrf='default')</code>","text":"<p>Run VerifySSHIPv4Acl validation.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The number of expected IPv4 ACL(s).</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF in which to check for the SSHD agent. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifySSHIPv4Acl validation.\n\n    Args:\n        number: The number of expected IPv4 ACL(s).\n        vrf: The name of the VRF in which to check for the SSHD agent. Defaults to 'default'.\n    \"\"\"\n    if not number or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    ipv4_acl_list = command_output[\"ipAclList\"][\"aclList\"]\n    ipv4_acl_number = len(ipv4_acl_list)\n    not_configured_acl_list = []\n\n    if ipv4_acl_number != number:\n        self.result.is_failure(f\"Expected {number} SSH IPv4 ACL(s) in vrf {vrf} but got {ipv4_acl_number}\")\n        return\n\n    for ipv4_acl in ipv4_acl_list:\n        if vrf not in ipv4_acl[\"configuredVrfs\"] or vrf not in ipv4_acl[\"activeVrfs\"]:\n            not_configured_acl_list.append(ipv4_acl[\"name\"])\n\n    if not_configured_acl_list:\n        self.result.is_failure(f\"SSH IPv4 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHIPv6Acl","title":"<code>VerifySSHIPv6Acl</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if the SSHD agent has the right number IPv6 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if the SSHD agent has the provided number of IPv6 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if the SSHD agent has not the right number of IPv6 ACL(s) in the specified VRF.</li> <li>skipped: The test will be skipped if the number of IPv6 ACL(s) or VRF parameter is not provided.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifySSHIPv6Acl(AntaTest):\n\"\"\"\n    Verifies if the SSHD agent has the right number IPv6 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if the SSHD agent has the provided number of IPv6 ACL(s) in the specified VRF.\n        * failure: The test will fail if the SSHD agent has not the right number of IPv6 ACL(s) in the specified VRF.\n        * skipped: The test will be skipped if the number of IPv6 ACL(s) or VRF parameter is not provided.\n    \"\"\"\n\n    name = \"VerifySSHIPv6Acl\"\n    description = \"Verifies if the SSHD agent has IPv6 ACL(s) configured.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management ssh ipv6 access-list summary\")]\n\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifySSHIPv6Acl validation.\n\n        Args:\n            number: The number of expected IPv6 ACL(s).\n            vrf: The name of the VRF in which to check for the SSHD agent. Defaults to 'default'.\n        \"\"\"\n        if not number or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        ipv6_acl_list = command_output[\"ipv6AclList\"][\"aclList\"]\n        ipv6_acl_number = len(ipv6_acl_list)\n        not_configured_acl_list = []\n\n        if ipv6_acl_number != number:\n            self.result.is_failure(f\"Expected {number} SSH IPv6 ACL(s) in vrf {vrf} but got {ipv6_acl_number}\")\n            return\n\n        for ipv6_acl in ipv6_acl_list:\n            if vrf not in ipv6_acl[\"configuredVrfs\"] or vrf not in ipv6_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv6_acl[\"name\"])\n\n        if not_configured_acl_list:\n            self.result.is_failure(f\"SSH IPv6 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHIPv6Acl.test","title":"<code>test(number=None, vrf='default')</code>","text":"<p>Run VerifySSHIPv6Acl validation.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The number of expected IPv6 ACL(s).</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF in which to check for the SSHD agent. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifySSHIPv6Acl validation.\n\n    Args:\n        number: The number of expected IPv6 ACL(s).\n        vrf: The name of the VRF in which to check for the SSHD agent. Defaults to 'default'.\n    \"\"\"\n    if not number or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    ipv6_acl_list = command_output[\"ipv6AclList\"][\"aclList\"]\n    ipv6_acl_number = len(ipv6_acl_list)\n    not_configured_acl_list = []\n\n    if ipv6_acl_number != number:\n        self.result.is_failure(f\"Expected {number} SSH IPv6 ACL(s) in vrf {vrf} but got {ipv6_acl_number}\")\n        return\n\n    for ipv6_acl in ipv6_acl_list:\n        if vrf not in ipv6_acl[\"configuredVrfs\"] or vrf not in ipv6_acl[\"activeVrfs\"]:\n            not_configured_acl_list.append(ipv6_acl[\"name\"])\n\n    if not_configured_acl_list:\n        self.result.is_failure(f\"SSH IPv6 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHStatus","title":"<code>VerifySSHStatus</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if the SSHD agent is disabled in the default VRF.</p> Expected Results <ul> <li>success: The test will pass if the SSHD agent is disabled in the default VRF.</li> <li>failure: The test will fail if the SSHD agent is NOT disabled in the default VRF.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifySSHStatus(AntaTest):\n\"\"\"\n    Verifies if the SSHD agent is disabled in the default VRF.\n\n    Expected Results:\n        * success: The test will pass if the SSHD agent is disabled in the default VRF.\n        * failure: The test will fail if the SSHD agent is NOT disabled in the default VRF.\n    \"\"\"\n\n    name = \"VerifySSHStatus\"\n    description = \"Verifies if the SSHD agent is disabled in the default VRF.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management ssh\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifySSHStatus validation.\n        \"\"\"\n\n        command_output = self.instance_commands[0].text_output\n\n        line = [line for line in command_output.split(\"\\n\") if line.startswith(\"SSHD status\")][0]\n        status = line.split(\"is \")[1]\n\n        if status == \"disabled\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(line)\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHStatus.test","title":"<code>test()</code>","text":"<p>Run VerifySSHStatus validation.</p> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifySSHStatus validation.\n    \"\"\"\n\n    command_output = self.instance_commands[0].text_output\n\n    line = [line for line in command_output.split(\"\\n\") if line.startswith(\"SSHD status\")][0]\n    status = line.split(\"is \")[1]\n\n    if status == \"disabled\":\n        self.result.is_success()\n    else:\n        self.result.is_failure(line)\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyTelnetStatus","title":"<code>VerifyTelnetStatus</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if Telnet is disabled in the default VRF.</p> Expected Results <ul> <li>success: The test will pass if Telnet is disabled in the default VRF.</li> <li>failure: The test will fail if Telnet is NOT disabled in the default VRF.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifyTelnetStatus(AntaTest):\n\"\"\"\n    Verifies if Telnet is disabled in the default VRF.\n\n    Expected Results:\n        * success: The test will pass if Telnet is disabled in the default VRF.\n        * failure: The test will fail if Telnet is NOT disabled in the default VRF.\n    \"\"\"\n\n    name = \"VerifyTelnetStatus\"\n    description = \"Verifies if Telnet is disabled in the default VRF.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management telnet\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyTelnetStatus validation.\n        \"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if command_output[\"serverState\"] == \"disabled\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"Telnet status for Default VRF is enabled\")\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyTelnetStatus.test","title":"<code>test()</code>","text":"<p>Run VerifyTelnetStatus validation.</p> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyTelnetStatus validation.\n    \"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if command_output[\"serverState\"] == \"disabled\":\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"Telnet status for Default VRF is enabled\")\n</code></pre>"},{"location":"api/tests.snmp/","title":"SNMP","text":""},{"location":"api/tests.snmp/#anta-catalog-for-snmp-tests","title":"ANTA catalog for SNMP tests","text":"<p>Test functions related to the EOS various SNMP settings</p>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpIPv4Acl","title":"<code>VerifySnmpIPv4Acl</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if the SNMP agent has the right number IPv4 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if the SNMP agent has the provided number of IPv4 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if the SNMP agent has not the right number of IPv4 ACL(s) in the specified VRF.</li> <li>skipped: The test will be skipped if the number of IPv4 ACL(s) or VRF parameter is not provided.</li> </ul> Source code in <code>anta/tests/snmp.py</code> <pre><code>class VerifySnmpIPv4Acl(AntaTest):\n\"\"\"\n    Verifies if the SNMP agent has the right number IPv4 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if the SNMP agent has the provided number of IPv4 ACL(s) in the specified VRF.\n        * failure: The test will fail if the SNMP agent has not the right number of IPv4 ACL(s) in the specified VRF.\n        * skipped: The test will be skipped if the number of IPv4 ACL(s) or VRF parameter is not provided.\n    \"\"\"\n\n    name = \"VerifySnmpIPv4Acl\"\n    description = \"Verifies if the SNMP agent has IPv4 ACL(s) configured.\"\n    categories = [\"snmp\"]\n    commands = [AntaCommand(command=\"show snmp ipv4 access-list summary\")]\n\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifySnmpIPv4Acl validation.\n\n        Args:\n            number: The number of expected IPv4 ACL(s).\n            vrf: The name of the VRF in which to check for the SNMP agent. Defaults to 'default'.\n        \"\"\"\n        if not number or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        ipv4_acl_list = command_output[\"ipAclList\"][\"aclList\"]\n        ipv4_acl_number = len(ipv4_acl_list)\n        not_configured_acl_list = []\n\n        if ipv4_acl_number != number:\n            self.result.is_failure(f\"Expected {number} SNMP IPv4 ACL(s) in vrf {vrf} but got {ipv4_acl_number}\")\n            return\n\n        for ipv4_acl in ipv4_acl_list:\n            if vrf not in ipv4_acl[\"configuredVrfs\"] or vrf not in ipv4_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv4_acl[\"name\"])\n\n        if not_configured_acl_list:\n            self.result.is_failure(f\"SNMP IPv4 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpIPv4Acl.test","title":"<code>test(number=None, vrf='default')</code>","text":"<p>Run VerifySnmpIPv4Acl validation.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The number of expected IPv4 ACL(s).</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF in which to check for the SNMP agent. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/snmp.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifySnmpIPv4Acl validation.\n\n    Args:\n        number: The number of expected IPv4 ACL(s).\n        vrf: The name of the VRF in which to check for the SNMP agent. Defaults to 'default'.\n    \"\"\"\n    if not number or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    ipv4_acl_list = command_output[\"ipAclList\"][\"aclList\"]\n    ipv4_acl_number = len(ipv4_acl_list)\n    not_configured_acl_list = []\n\n    if ipv4_acl_number != number:\n        self.result.is_failure(f\"Expected {number} SNMP IPv4 ACL(s) in vrf {vrf} but got {ipv4_acl_number}\")\n        return\n\n    for ipv4_acl in ipv4_acl_list:\n        if vrf not in ipv4_acl[\"configuredVrfs\"] or vrf not in ipv4_acl[\"activeVrfs\"]:\n            not_configured_acl_list.append(ipv4_acl[\"name\"])\n\n    if not_configured_acl_list:\n        self.result.is_failure(f\"SNMP IPv4 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpIPv6Acl","title":"<code>VerifySnmpIPv6Acl</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if the SNMP agent has the right number IPv6 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if the SNMP agent has the provided number of IPv6 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if the SNMP agent has not the right number of IPv6 ACL(s) in the specified VRF.</li> <li>skipped: The test will be skipped if the number of IPv6 ACL(s) or VRF parameter is not provided.</li> </ul> Source code in <code>anta/tests/snmp.py</code> <pre><code>class VerifySnmpIPv6Acl(AntaTest):\n\"\"\"\n    Verifies if the SNMP agent has the right number IPv6 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if the SNMP agent has the provided number of IPv6 ACL(s) in the specified VRF.\n        * failure: The test will fail if the SNMP agent has not the right number of IPv6 ACL(s) in the specified VRF.\n        * skipped: The test will be skipped if the number of IPv6 ACL(s) or VRF parameter is not provided.\n    \"\"\"\n\n    name = \"VerifySnmpIPv6Acl\"\n    description = \"Verifies if the SNMP agent has IPv6 ACL(s) configured.\"\n    categories = [\"snmp\"]\n    commands = [AntaCommand(command=\"show snmp ipv6 access-list summary\")]\n\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifySnmpIPv6Acl validation.\n\n        Args:\n            number: The number of expected IPv6 ACL(s).\n            vrf: The name of the VRF in which to check for the SNMP agent. Defaults to 'default'.\n        \"\"\"\n        if not number or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        ipv6_acl_list = command_output[\"ipv6AclList\"][\"aclList\"]\n        ipv6_acl_number = len(ipv6_acl_list)\n        not_configured_acl_list = []\n\n        if ipv6_acl_number != number:\n            self.result.is_failure(f\"Expected {number} SNMP IPv6 ACL(s) in vrf {vrf} but got {ipv6_acl_number}\")\n            return\n\n        for ipv6_acl in ipv6_acl_list:\n            if vrf not in ipv6_acl[\"configuredVrfs\"] or vrf not in ipv6_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv6_acl[\"name\"])\n\n        if not_configured_acl_list:\n            self.result.is_failure(f\"SNMP IPv6 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpIPv6Acl.test","title":"<code>test(number=None, vrf='default')</code>","text":"<p>Run VerifySnmpIPv6Acl validation.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The number of expected IPv6 ACL(s).</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF in which to check for the SNMP agent. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/snmp.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifySnmpIPv6Acl validation.\n\n    Args:\n        number: The number of expected IPv6 ACL(s).\n        vrf: The name of the VRF in which to check for the SNMP agent. Defaults to 'default'.\n    \"\"\"\n    if not number or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    ipv6_acl_list = command_output[\"ipv6AclList\"][\"aclList\"]\n    ipv6_acl_number = len(ipv6_acl_list)\n    not_configured_acl_list = []\n\n    if ipv6_acl_number != number:\n        self.result.is_failure(f\"Expected {number} SNMP IPv6 ACL(s) in vrf {vrf} but got {ipv6_acl_number}\")\n        return\n\n    for ipv6_acl in ipv6_acl_list:\n        if vrf not in ipv6_acl[\"configuredVrfs\"] or vrf not in ipv6_acl[\"activeVrfs\"]:\n            not_configured_acl_list.append(ipv6_acl[\"name\"])\n\n    if not_configured_acl_list:\n        self.result.is_failure(f\"SNMP IPv6 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpStatus","title":"<code>VerifySnmpStatus</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies whether the SNMP agent is enabled in a specified VRF.</p> Expected Results <ul> <li>success: The test will pass if the SNMP agent is enabled in the specified VRF.</li> <li>failure: The test will fail if the SNMP agent is disabled in the specified VRF.</li> <li>skipped: The test will be skipped if the VRF parameter is not provided.</li> </ul> Source code in <code>anta/tests/snmp.py</code> <pre><code>class VerifySnmpStatus(AntaTest):\n\"\"\"\n    Verifies whether the SNMP agent is enabled in a specified VRF.\n\n    Expected Results:\n        * success: The test will pass if the SNMP agent is enabled in the specified VRF.\n        * failure: The test will fail if the SNMP agent is disabled in the specified VRF.\n        * skipped: The test will be skipped if the VRF parameter is not provided.\n    \"\"\"\n\n    name = \"VerifySnmpStatus\"\n    description = \"Verifies if the SNMP agent is enabled.\"\n    categories = [\"snmp\"]\n    commands = [AntaCommand(command=\"show snmp\")]\n\n    @AntaTest.anta_test\n    def test(self, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifySnmpStatus validation.\n\n        Args:\n            vrf: The name of the VRF in which to check for the SNMP agent. Defaults to 'default'.\n        \"\"\"\n        if not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because vrf was not supplied\")\n        else:\n            command_output = self.instance_commands[0].json_output\n\n            if command_output[\"enabled\"] and vrf in command_output[\"vrfs\"][\"snmpVrfs\"]:\n                self.result.is_success()\n            else:\n                self.result.is_failure(f\"SNMP agent disabled in vrf {vrf}\")\n</code></pre>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpStatus.test","title":"<code>test(vrf='default')</code>","text":"<p>Run VerifySnmpStatus validation.</p> <p>Parameters:</p> Name Type Description Default <code>vrf</code> <code>str</code> <p>The name of the VRF in which to check for the SNMP agent. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/snmp.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifySnmpStatus validation.\n\n    Args:\n        vrf: The name of the VRF in which to check for the SNMP agent. Defaults to 'default'.\n    \"\"\"\n    if not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because vrf was not supplied\")\n    else:\n        command_output = self.instance_commands[0].json_output\n\n        if command_output[\"enabled\"] and vrf in command_output[\"vrfs\"][\"snmpVrfs\"]:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"SNMP agent disabled in vrf {vrf}\")\n</code></pre>"},{"location":"api/tests.software/","title":"Software","text":""},{"location":"api/tests.software/#anta-catalog-for-software-tests","title":"ANTA catalog for software tests","text":"<p>Test functions related to the EOS software</p>"},{"location":"api/tests.software/#anta.tests.software.VerifyEOSExtensions","title":"<code>VerifyEOSExtensions</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies all EOS extensions installed on the device are enabled for boot persistence.</p> Source code in <code>anta/tests/software.py</code> <pre><code>class VerifyEOSExtensions(AntaTest):\n\"\"\"\n    Verifies all EOS extensions installed on the device are enabled for boot persistence.\n    \"\"\"\n\n    name = \"VerifyEOSExtensions\"\n    description = \"Verifies all EOS extensions installed on the device are enabled for boot persistence.\"\n    categories = [\"software\"]\n    commands = [AntaCommand(command=\"show extensions\"), AntaCommand(command=\"show boot-extensions\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyEOSExtensions validation\"\"\"\n\n        boot_extensions = []\n\n        show_extensions_command_output = self.instance_commands[0].json_output\n        show_boot_extensions_command_output = self.instance_commands[1].json_output\n\n        installed_extensions = [\n            extension for extension, extension_data in show_extensions_command_output[\"extensions\"].items() if extension_data[\"status\"] == \"installed\"\n        ]\n\n        for extension in show_boot_extensions_command_output[\"extensions\"]:\n            extension = extension.strip(\"\\n\")\n            if extension != \"\":\n                boot_extensions.append(extension)\n\n        installed_extensions.sort()\n        boot_extensions.sort()\n        if installed_extensions == boot_extensions:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Missing EOS extensions: installed {installed_extensions} / configured: {boot_extensions}\")\n</code></pre>"},{"location":"api/tests.software/#anta.tests.software.VerifyEOSExtensions.test","title":"<code>test()</code>","text":"<p>Run VerifyEOSExtensions validation</p> Source code in <code>anta/tests/software.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyEOSExtensions validation\"\"\"\n\n    boot_extensions = []\n\n    show_extensions_command_output = self.instance_commands[0].json_output\n    show_boot_extensions_command_output = self.instance_commands[1].json_output\n\n    installed_extensions = [\n        extension for extension, extension_data in show_extensions_command_output[\"extensions\"].items() if extension_data[\"status\"] == \"installed\"\n    ]\n\n    for extension in show_boot_extensions_command_output[\"extensions\"]:\n        extension = extension.strip(\"\\n\")\n        if extension != \"\":\n            boot_extensions.append(extension)\n\n    installed_extensions.sort()\n    boot_extensions.sort()\n    if installed_extensions == boot_extensions:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Missing EOS extensions: installed {installed_extensions} / configured: {boot_extensions}\")\n</code></pre>"},{"location":"api/tests.software/#anta.tests.software.VerifyEOSVersion","title":"<code>VerifyEOSVersion</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the device is running one of the allowed EOS version.</p> Source code in <code>anta/tests/software.py</code> <pre><code>class VerifyEOSVersion(AntaTest):\n\"\"\"\n    Verifies the device is running one of the allowed EOS version.\n    \"\"\"\n\n    name = \"VerifyEOSVersion\"\n    description = \"Verifies the device is running one of the allowed EOS version.\"\n    categories = [\"software\"]\n    commands = [AntaCommand(command=\"show version\")]\n\n    @AntaTest.anta_test\n    def test(self, versions: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyEOSVersion validation\n\n        Args:\n            versions: List of allowed EOS versions.\n        \"\"\"\n        if not versions:\n            self.result.is_skipped(\"VerifyEOSVersion was not run as no versions were given\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        if command_output[\"version\"] in versions:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f'device is running version {command_output[\"version\"]} not in expected versions: {versions}')\n</code></pre>"},{"location":"api/tests.software/#anta.tests.software.VerifyEOSVersion.test","title":"<code>test(versions=None)</code>","text":"<p>Run VerifyEOSVersion validation</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Optional[List[str]]</code> <p>List of allowed EOS versions.</p> <code>None</code> Source code in <code>anta/tests/software.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, versions: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyEOSVersion validation\n\n    Args:\n        versions: List of allowed EOS versions.\n    \"\"\"\n    if not versions:\n        self.result.is_skipped(\"VerifyEOSVersion was not run as no versions were given\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    if command_output[\"version\"] in versions:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f'device is running version {command_output[\"version\"]} not in expected versions: {versions}')\n</code></pre>"},{"location":"api/tests.software/#anta.tests.software.VerifyTerminAttrVersion","title":"<code>VerifyTerminAttrVersion</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the device is running one of the allowed TerminAttr version.</p> Source code in <code>anta/tests/software.py</code> <pre><code>class VerifyTerminAttrVersion(AntaTest):\n\"\"\"\n    Verifies the device is running one of the allowed TerminAttr version.\n    \"\"\"\n\n    name = \"VerifyTerminAttrVersion\"\n    description = \"Verifies the device is running one of the allowed TerminAttr version.\"\n    categories = [\"software\"]\n    commands = [AntaCommand(command=\"show version detail\")]\n\n    @AntaTest.anta_test\n    def test(self, versions: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyTerminAttrVersion validation\n\n        Args:\n            versions: List of allowed TerminAttr versions.\n        \"\"\"\n\n        if not versions:\n            self.result.is_skipped(\"VerifyTerminAttrVersion was not run as no versions were given\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        command_output_data = command_output[\"details\"][\"packages\"][\"TerminAttr-core\"][\"version\"]\n        if command_output_data in versions:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"device is running TerminAttr version {command_output_data} and is not in the allowed list: {versions}\")\n</code></pre>"},{"location":"api/tests.software/#anta.tests.software.VerifyTerminAttrVersion.test","title":"<code>test(versions=None)</code>","text":"<p>Run VerifyTerminAttrVersion validation</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Optional[List[str]]</code> <p>List of allowed TerminAttr versions.</p> <code>None</code> Source code in <code>anta/tests/software.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, versions: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyTerminAttrVersion validation\n\n    Args:\n        versions: List of allowed TerminAttr versions.\n    \"\"\"\n\n    if not versions:\n        self.result.is_skipped(\"VerifyTerminAttrVersion was not run as no versions were given\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    command_output_data = command_output[\"details\"][\"packages\"][\"TerminAttr-core\"][\"version\"]\n    if command_output_data in versions:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"device is running TerminAttr version {command_output_data} and is not in the allowed list: {versions}\")\n</code></pre>"},{"location":"api/tests.stp/","title":"STP","text":""},{"location":"api/tests.stp/#anta-catalog-for-stp-tests","title":"ANTA catalog for STP tests","text":"<p>Test functions related to various Spanning Tree Protocol (STP) settings</p>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPBlockedPorts","title":"<code>VerifySTPBlockedPorts</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies there is no STP blocked ports.</p> Expected Results <ul> <li>success: The test will pass if there are NO ports blocked by STP.</li> <li>failure: The test will fail if there are ports blocked by STP.</li> </ul> Source code in <code>anta/tests/stp.py</code> <pre><code>class VerifySTPBlockedPorts(AntaTest):\n\"\"\"\n    Verifies there is no STP blocked ports.\n\n    Expected Results:\n        * success: The test will pass if there are NO ports blocked by STP.\n        * failure: The test will fail if there are ports blocked by STP.\n    \"\"\"\n\n    name = \"VerifySTPBlockedPorts\"\n    description = \"Verifies there is no STP blocked ports.\"\n    categories = [\"stp\"]\n    commands = [AntaCommand(command=\"show spanning-tree blockedports\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifySTPBlockedPorts validation\n        \"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if not (stp_instances := command_output[\"spanningTreeInstances\"]):\n            self.result.is_success()\n        else:\n            for key, value in stp_instances.items():\n                stp_instances[key] = value.pop(\"spanningTreeBlockedPorts\")\n            self.result.is_failure(f\"The following ports are blocked by STP: {stp_instances}\")\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPBlockedPorts.test","title":"<code>test()</code>","text":"<p>Run VerifySTPBlockedPorts validation</p> Source code in <code>anta/tests/stp.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifySTPBlockedPorts validation\n    \"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if not (stp_instances := command_output[\"spanningTreeInstances\"]):\n        self.result.is_success()\n    else:\n        for key, value in stp_instances.items():\n            stp_instances[key] = value.pop(\"spanningTreeBlockedPorts\")\n        self.result.is_failure(f\"The following ports are blocked by STP: {stp_instances}\")\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPCounters","title":"<code>VerifySTPCounters</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies there is no errors in STP BPDU packets.</p> Expected Results <ul> <li>success: The test will pass if there are NO STP BPDU packet errors under all interfaces participating in STP.</li> <li>failure: The test will fail if there are STP BPDU packet errors on one or many interface(s).</li> </ul> Source code in <code>anta/tests/stp.py</code> <pre><code>class VerifySTPCounters(AntaTest):\n\"\"\"\n    Verifies there is no errors in STP BPDU packets.\n\n    Expected Results:\n        * success: The test will pass if there are NO STP BPDU packet errors under all interfaces participating in STP.\n        * failure: The test will fail if there are STP BPDU packet errors on one or many interface(s).\n    \"\"\"\n\n    name = \"VerifySTPCounters\"\n    description = \"Verifies there is no errors in STP BPDU packets.\"\n    categories = [\"stp\"]\n    commands = [AntaCommand(command=\"show spanning-tree counters\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifySTPBlockedPorts validation\n        \"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        interfaces_with_errors = [\n            interface for interface, counters in command_output[\"interfaces\"].items() if counters[\"bpduTaggedError\"] or counters[\"bpduOtherError\"] != 0\n        ]\n\n        if interfaces_with_errors:\n            self.result.is_failure(f\"The following interfaces have STP BPDU packet errors: {interfaces_with_errors}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPCounters.test","title":"<code>test()</code>","text":"<p>Run VerifySTPBlockedPorts validation</p> Source code in <code>anta/tests/stp.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifySTPBlockedPorts validation\n    \"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    interfaces_with_errors = [\n        interface for interface, counters in command_output[\"interfaces\"].items() if counters[\"bpduTaggedError\"] or counters[\"bpduOtherError\"] != 0\n    ]\n\n    if interfaces_with_errors:\n        self.result.is_failure(f\"The following interfaces have STP BPDU packet errors: {interfaces_with_errors}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPForwardingPorts","title":"<code>VerifySTPForwardingPorts</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies that all interfaces are in a forwarding state for a provided list of VLAN(s).</p> Expected Results <ul> <li>success: The test will pass if all interfaces are in a forwarding state for the specified VLAN(s).</li> <li>failure: The test will fail if one or many interfaces are NOT in a forwarding state in the specified VLAN(s).</li> <li>error: The test will give an error if a list of VLAN(s) is not provided as template_params.</li> </ul> Source code in <code>anta/tests/stp.py</code> <pre><code>class VerifySTPForwardingPorts(AntaTest):\n\"\"\"\n    Verifies that all interfaces are in a forwarding state for a provided list of VLAN(s).\n\n    Expected Results:\n        * success: The test will pass if all interfaces are in a forwarding state for the specified VLAN(s).\n        * failure: The test will fail if one or many interfaces are NOT in a forwarding state in the specified VLAN(s).\n        * error: The test will give an error if a list of VLAN(s) is not provided as template_params.\n    \"\"\"\n\n    name = \"VerifySTPForwardingPorts\"\n    description = \"Verifies that all interfaces are forwarding for a provided list of VLAN(s).\"\n    categories = [\"stp\"]\n    template = AntaTemplate(template=\"show spanning-tree topology vlan {vlan} status\")\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifySTPForwardingPorts validation.\n        \"\"\"\n\n        self.result.is_success()\n\n        for command in self.instance_commands:\n            if command.params and \"vlan\" in command.params:\n                vlan_id = command.params[\"vlan\"]\n\n            if not (topologies := get_value(command.json_output, \"topologies\")):\n                self.result.is_failure(f\"STP instance for VLAN {vlan_id} is not configured\")\n\n            else:\n                for value in topologies.values():\n                    if int(vlan_id) in value[\"vlans\"]:\n                        interfaces_not_forwarding = [interface for interface, state in value[\"interfaces\"].items() if state[\"state\"] != \"forwarding\"]\n\n                if interfaces_not_forwarding:\n                    self.result.is_failure(f\"The following interface(s) are not in a forwarding state for VLAN {vlan_id}: {interfaces_not_forwarding}\")\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPForwardingPorts.test","title":"<code>test()</code>","text":"<p>Run VerifySTPForwardingPorts validation.</p> Source code in <code>anta/tests/stp.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifySTPForwardingPorts validation.\n    \"\"\"\n\n    self.result.is_success()\n\n    for command in self.instance_commands:\n        if command.params and \"vlan\" in command.params:\n            vlan_id = command.params[\"vlan\"]\n\n        if not (topologies := get_value(command.json_output, \"topologies\")):\n            self.result.is_failure(f\"STP instance for VLAN {vlan_id} is not configured\")\n\n        else:\n            for value in topologies.values():\n                if int(vlan_id) in value[\"vlans\"]:\n                    interfaces_not_forwarding = [interface for interface, state in value[\"interfaces\"].items() if state[\"state\"] != \"forwarding\"]\n\n            if interfaces_not_forwarding:\n                self.result.is_failure(f\"The following interface(s) are not in a forwarding state for VLAN {vlan_id}: {interfaces_not_forwarding}\")\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPMode","title":"<code>VerifySTPMode</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the configured STP mode for a provided list of VLAN(s).</p> Expected Results <ul> <li>success: The test will pass if the STP mode is configured properly in the specified VLAN(s).</li> <li>failure: The test will fail if the STP mode is NOT configured properly for one or more specified VLAN(s).</li> <li>skipped: The test will be skipped if the STP mode is not provided.</li> <li>error: The test will give an error if a list of VLAN(s) is not provided as template_params.</li> </ul> Source code in <code>anta/tests/stp.py</code> <pre><code>class VerifySTPMode(AntaTest):\n\"\"\"\n    Verifies the configured STP mode for a provided list of VLAN(s).\n\n    Expected Results:\n        * success: The test will pass if the STP mode is configured properly in the specified VLAN(s).\n        * failure: The test will fail if the STP mode is NOT configured properly for one or more specified VLAN(s).\n        * skipped: The test will be skipped if the STP mode is not provided.\n        * error: The test will give an error if a list of VLAN(s) is not provided as template_params.\n    \"\"\"\n\n    name = \"VerifySTPMode\"\n    description = \"Verifies the configured STP mode for a provided list of VLAN(s).\"\n    categories = [\"stp\"]\n    template = AntaTemplate(template=\"show spanning-tree vlan {vlan}\")\n\n    @staticmethod\n    def _check_stp_mode(mode: str) -&gt; None:\n\"\"\"\n        Verifies if the provided STP mode is compatible with Arista EOS devices.\n\n        Args:\n            mode: The STP mode to verify.\n        \"\"\"\n        stp_modes = [\"mstp\", \"rstp\", \"rapidPvst\"]\n\n        if mode not in stp_modes:\n            raise ValueError(f\"Wrong STP mode provided. Valid modes are: {stp_modes}\")\n\n    @AntaTest.anta_test\n    def test(self, mode: str = \"mstp\") -&gt; None:\n\"\"\"\n        Run VerifySTPVersion validation.\n\n        Args:\n            mode: STP mode to verify. Defaults to 'mstp'.\n        \"\"\"\n        if not mode:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because mode was not supplied\")\n            return\n\n        self._check_stp_mode(mode)\n\n        self.result.is_success()\n\n        for command in self.instance_commands:\n            if command.params and \"vlan\" in command.params:\n                vlan_id = command.params[\"vlan\"]\n            if not (stp_mode := get_value(command.json_output, f\"spanningTreeVlanInstances.{vlan_id}.spanningTreeVlanInstance.protocol\")):\n                self.result.is_failure(f\"STP mode '{mode}' not configured for VLAN {vlan_id}\")\n\n            elif stp_mode != mode:\n                self.result.is_failure(f\"Wrong STP mode configured for VLAN {vlan_id}\")\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPMode.test","title":"<code>test(mode='mstp')</code>","text":"<p>Run VerifySTPVersion validation.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>STP mode to verify. Defaults to \u2018mstp\u2019.</p> <code>'mstp'</code> Source code in <code>anta/tests/stp.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, mode: str = \"mstp\") -&gt; None:\n\"\"\"\n    Run VerifySTPVersion validation.\n\n    Args:\n        mode: STP mode to verify. Defaults to 'mstp'.\n    \"\"\"\n    if not mode:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because mode was not supplied\")\n        return\n\n    self._check_stp_mode(mode)\n\n    self.result.is_success()\n\n    for command in self.instance_commands:\n        if command.params and \"vlan\" in command.params:\n            vlan_id = command.params[\"vlan\"]\n        if not (stp_mode := get_value(command.json_output, f\"spanningTreeVlanInstances.{vlan_id}.spanningTreeVlanInstance.protocol\")):\n            self.result.is_failure(f\"STP mode '{mode}' not configured for VLAN {vlan_id}\")\n\n        elif stp_mode != mode:\n            self.result.is_failure(f\"Wrong STP mode configured for VLAN {vlan_id}\")\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPRootPriority","title":"<code>VerifySTPRootPriority</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the STP root priority for a provided list of VLAN or MST instance ID(s).</p> Expected Results <ul> <li>success: The test will pass if the STP root priority is configured properly for the specified VLAN or MST instance ID(s).</li> <li>failure: The test will fail if the STP root priority is NOT configured properly for the specified VLAN or MST instance ID(s).</li> <li>skipped: The test will be skipped if the STP root priority is not provided.</li> </ul> Source code in <code>anta/tests/stp.py</code> <pre><code>class VerifySTPRootPriority(AntaTest):\n\"\"\"\n    Verifies the STP root priority for a provided list of VLAN or MST instance ID(s).\n\n    Expected Results:\n        * success: The test will pass if the STP root priority is configured properly for the specified VLAN or MST instance ID(s).\n        * failure: The test will fail if the STP root priority is NOT configured properly for the specified VLAN or MST instance ID(s).\n        * skipped: The test will be skipped if the STP root priority is not provided.\n    \"\"\"\n\n    name = \"VerifySTPRootPriority\"\n    description = \"Verifies the STP root priority for a provided list of VLAN or MST instance ID(s).\"\n    categories = [\"stp\"]\n    commands = [AntaCommand(command=\"show spanning-tree root detail\")]\n\n    @AntaTest.anta_test\n    def test(self, priority: Optional[int] = None, instances: Optional[List[int]] = None) -&gt; None:\n\"\"\"\n        Run VerifySTPRootPriority validation.\n\n        Args:\n            priority: STP root priority to verify.\n            instances: List of VLAN or MST instance ID(s). By default, ALL VLAN or MST instance ID(s) will be verified.\n        \"\"\"\n        if not priority:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because priority was not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        if not (stp_instances := command_output[\"instances\"]):\n            self.result.is_failure(\"No STP instances configured\")\n            return\n\n        for instance in stp_instances:\n            if instance.startswith(\"MST\"):\n                prefix = \"MST\"\n                break\n            if instance.startswith(\"VL\"):\n                prefix = \"VL\"\n                break\n\n        check_instances = [f\"{prefix}{instance_id}\" for instance_id in instances] if instances else command_output[\"instances\"].keys()\n\n        wrong_priority_instances = [instance for instance in check_instances if get_value(command_output, f\"instances.{instance}.rootBridge.priority\") != priority]\n\n        if wrong_priority_instances:\n            self.result.is_failure(f\"The following instance(s) have the wrong STP root priority configured: {wrong_priority_instances}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPRootPriority.test","title":"<code>test(priority=None, instances=None)</code>","text":"<p>Run VerifySTPRootPriority validation.</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>Optional[int]</code> <p>STP root priority to verify.</p> <code>None</code> <code>instances</code> <code>Optional[List[int]]</code> <p>List of VLAN or MST instance ID(s). By default, ALL VLAN or MST instance ID(s) will be verified.</p> <code>None</code> Source code in <code>anta/tests/stp.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, priority: Optional[int] = None, instances: Optional[List[int]] = None) -&gt; None:\n\"\"\"\n    Run VerifySTPRootPriority validation.\n\n    Args:\n        priority: STP root priority to verify.\n        instances: List of VLAN or MST instance ID(s). By default, ALL VLAN or MST instance ID(s) will be verified.\n    \"\"\"\n    if not priority:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because priority was not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    if not (stp_instances := command_output[\"instances\"]):\n        self.result.is_failure(\"No STP instances configured\")\n        return\n\n    for instance in stp_instances:\n        if instance.startswith(\"MST\"):\n            prefix = \"MST\"\n            break\n        if instance.startswith(\"VL\"):\n            prefix = \"VL\"\n            break\n\n    check_instances = [f\"{prefix}{instance_id}\" for instance_id in instances] if instances else command_output[\"instances\"].keys()\n\n    wrong_priority_instances = [instance for instance in check_instances if get_value(command_output, f\"instances.{instance}.rootBridge.priority\") != priority]\n\n    if wrong_priority_instances:\n        self.result.is_failure(f\"The following instance(s) have the wrong STP root priority configured: {wrong_priority_instances}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.system/","title":"System","text":""},{"location":"api/tests.system/#anta-catalog-for-system-tests","title":"ANTA catalog for system tests","text":"<p>Test functions related to system-level features and protocols</p>"},{"location":"api/tests.system/#anta.tests.system.VerifyAgentLogs","title":"<code>VerifyAgentLogs</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies there is no agent crash reported on the device.</p> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyAgentLogs(AntaTest):\n\"\"\"\n    Verifies there is no agent crash reported on the device.\n    \"\"\"\n\n    name = \"VerifyAgentLogs\"\n    description = \"Verifies there is no agent crash reported on the device.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"show agent logs crash\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyAgentLogs validation\n        \"\"\"\n        command_output = self.instance_commands[0].text_output\n\n        if len(command_output) == 0:\n            self.result.is_success()\n        else:\n            pattern = re.compile(r\"^===&gt; (.*?) &lt;===$\", re.MULTILINE)\n            agents = \"\\n * \".join(pattern.findall(command_output))\n            self.result.is_failure(f\"device reported some agent logs:\\n * {agents}\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyAgentLogs.test","title":"<code>test()</code>","text":"<p>Run VerifyAgentLogs validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyAgentLogs validation\n    \"\"\"\n    command_output = self.instance_commands[0].text_output\n\n    if len(command_output) == 0:\n        self.result.is_success()\n    else:\n        pattern = re.compile(r\"^===&gt; (.*?) &lt;===$\", re.MULTILINE)\n        agents = \"\\n * \".join(pattern.findall(command_output))\n        self.result.is_failure(f\"device reported some agent logs:\\n * {agents}\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyCPUUtilization","title":"<code>VerifyCPUUtilization</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the CPU utilization is less than 75%.</p> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyCPUUtilization(AntaTest):\n\"\"\"\n    Verifies the CPU utilization is less than 75%.\n    \"\"\"\n\n    name = \"VerifyCPUUtilization\"\n    description = \"Verifies the CPU utilization is less than 75%.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"show processes top once\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyCPUUtilization validation\n        \"\"\"\n        command_output = self.instance_commands[0].json_output\n        command_output_data = command_output[\"cpuInfo\"][\"%Cpu(s)\"][\"idle\"]\n\n        if command_output_data &gt; 25:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"device reported a high CPU utilization ({100 - command_output_data}%)\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyCPUUtilization.test","title":"<code>test()</code>","text":"<p>Run VerifyCPUUtilization validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyCPUUtilization validation\n    \"\"\"\n    command_output = self.instance_commands[0].json_output\n    command_output_data = command_output[\"cpuInfo\"][\"%Cpu(s)\"][\"idle\"]\n\n    if command_output_data &gt; 25:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"device reported a high CPU utilization ({100 - command_output_data}%)\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyCoredump","title":"<code>VerifyCoredump</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies there is no core file.</p> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyCoredump(AntaTest):\n\"\"\"\n    Verifies there is no core file.\n    \"\"\"\n\n    name = \"VerifyCoredump\"\n    description = \"Verifies there is no core file.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"bash timeout 10 ls /var/core\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyCoredump validation\n        \"\"\"\n        command_output = self.instance_commands[0].text_output\n\n        if len(command_output) == 0:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Core-dump(s) have been found: {command_output}\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyCoredump.test","title":"<code>test()</code>","text":"<p>Run VerifyCoredump validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyCoredump validation\n    \"\"\"\n    command_output = self.instance_commands[0].text_output\n\n    if len(command_output) == 0:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Core-dump(s) have been found: {command_output}\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyFileSystemUtilization","title":"<code>VerifyFileSystemUtilization</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies each partition on the disk is used less than 75%.</p> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyFileSystemUtilization(AntaTest):\n\"\"\"\n    Verifies each partition on the disk is used less than 75%.\n    \"\"\"\n\n    name = \"VerifyFileSystemUtilization\"\n    description = \"Verifies each partition on the disk is used less than 75%.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"bash timeout 10 df -h\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyFileSystemUtilization validation\n        \"\"\"\n        command_output = self.instance_commands[0].text_output\n\n        self.result.is_success()\n\n        for line in command_output.split(\"\\n\")[1:]:\n            if \"loop\" not in line and len(line) &gt; 0 and (percentage := int(line.split()[4].replace(\"%\", \"\"))) &gt; 75:\n                self.result.is_failure(f\"mount point {line} is higher than 75% (reported {percentage})\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyFileSystemUtilization.test","title":"<code>test()</code>","text":"<p>Run VerifyFileSystemUtilization validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyFileSystemUtilization validation\n    \"\"\"\n    command_output = self.instance_commands[0].text_output\n\n    self.result.is_success()\n\n    for line in command_output.split(\"\\n\")[1:]:\n        if \"loop\" not in line and len(line) &gt; 0 and (percentage := int(line.split()[4].replace(\"%\", \"\"))) &gt; 75:\n            self.result.is_failure(f\"mount point {line} is higher than 75% (reported {percentage})\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyMemoryUtilization","title":"<code>VerifyMemoryUtilization</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the Memory utilization is less than 75%.</p> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyMemoryUtilization(AntaTest):\n\"\"\"\n    Verifies the Memory utilization is less than 75%.\n    \"\"\"\n\n    name = \"VerifyMemoryUtilization\"\n    description = \"Verifies the Memory utilization is less than 75%.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"show version\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyMemoryUtilization validation\n        \"\"\"\n        command_output = self.instance_commands[0].json_output\n\n        memory_usage = command_output[\"memFree\"] / command_output[\"memTotal\"]\n        if memory_usage &gt; 0.25:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"device report a high memory usage: {(1 - memory_usage)*100:.2f}%\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyMemoryUtilization.test","title":"<code>test()</code>","text":"<p>Run VerifyMemoryUtilization validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyMemoryUtilization validation\n    \"\"\"\n    command_output = self.instance_commands[0].json_output\n\n    memory_usage = command_output[\"memFree\"] / command_output[\"memTotal\"]\n    if memory_usage &gt; 0.25:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"device report a high memory usage: {(1 - memory_usage)*100:.2f}%\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyNTP","title":"<code>VerifyNTP</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies NTP is synchronised.</p> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyNTP(AntaTest):\n\"\"\"\n    Verifies NTP is synchronised.\n    \"\"\"\n\n    name = \"VerifyNTP\"\n    description = \"Verifies NTP is synchronised.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"show ntp status\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyNTP validation\n        \"\"\"\n        command_output = self.instance_commands[0].text_output\n\n        if command_output.split(\"\\n\")[0].split(\" \")[0] == \"synchronised\":\n            self.result.is_success()\n        else:\n            data = command_output.split(\"\\n\")[0]\n            self.result.is_failure(f\"not sync with NTP server ({data})\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyNTP.test","title":"<code>test()</code>","text":"<p>Run VerifyNTP validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyNTP validation\n    \"\"\"\n    command_output = self.instance_commands[0].text_output\n\n    if command_output.split(\"\\n\")[0].split(\" \")[0] == \"synchronised\":\n        self.result.is_success()\n    else:\n        data = command_output.split(\"\\n\")[0]\n        self.result.is_failure(f\"not sync with NTP server ({data})\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyReloadCause","title":"<code>VerifyReloadCause</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the last reload of the device was requested by a user.</p> <p>Test considers the following messages as normal and will return success. Failure is for other messages * Reload requested by the user. * Reload requested after FPGA upgrade</p> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyReloadCause(AntaTest):\n\"\"\"\n    Verifies the last reload of the device was requested by a user.\n\n    Test considers the following messages as normal and will return success. Failure is for other messages\n    * Reload requested by the user.\n    * Reload requested after FPGA upgrade\n    \"\"\"\n\n    name = \"VerifyReloadCause\"\n    description = \"Verifies the device uptime is higher than a value.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"show reload cause\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyReloadCause validation\n        \"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if \"resetCauses\" not in command_output.keys():\n            self.result.is_error(\"no reload cause available\")\n            return\n\n        if len(command_output[\"resetCauses\"]) == 0:\n            # No reload causes\n            self.result.is_success()\n            return\n\n        reset_causes = command_output[\"resetCauses\"]\n        command_output_data = reset_causes[0].get(\"description\")\n        if command_output_data in [\n            \"Reload requested by the user.\",\n            \"Reload requested after FPGA upgrade\",\n        ]:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Reload cause is {command_output_data}\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyReloadCause.test","title":"<code>test()</code>","text":"<p>Run VerifyReloadCause validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyReloadCause validation\n    \"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if \"resetCauses\" not in command_output.keys():\n        self.result.is_error(\"no reload cause available\")\n        return\n\n    if len(command_output[\"resetCauses\"]) == 0:\n        # No reload causes\n        self.result.is_success()\n        return\n\n    reset_causes = command_output[\"resetCauses\"]\n    command_output_data = reset_causes[0].get(\"description\")\n    if command_output_data in [\n        \"Reload requested by the user.\",\n        \"Reload requested after FPGA upgrade\",\n    ]:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Reload cause is {command_output_data}\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifySyslog","title":"<code>VerifySyslog</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the device had no syslog message with a severity of warning (or a more severe message) during the last 7 days.</p> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifySyslog(AntaTest):\n\"\"\"\n    Verifies the device had no syslog message with a severity of warning (or a more severe message) during the last 7 days.\n    \"\"\"\n\n    name = \"VerifySyslog\"\n    description = \"Verifies the device had no syslog message with a severity of warning (or a more severe message) during the last 7 days.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"show logging last 7 days threshold warnings\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifySyslog validation\n        \"\"\"\n        command_output = self.instance_commands[0].text_output\n\n        if len(command_output) == 0:\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"Device has some log messages with a severity WARNING or higher\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifySyslog.test","title":"<code>test()</code>","text":"<p>Run VerifySyslog validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifySyslog validation\n    \"\"\"\n    command_output = self.instance_commands[0].text_output\n\n    if len(command_output) == 0:\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"Device has some log messages with a severity WARNING or higher\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyUptime","title":"<code>VerifyUptime</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the device uptime is higher than a value.</p> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyUptime(AntaTest):\n\"\"\"\n    Verifies the device uptime is higher than a value.\n    \"\"\"\n\n    name = \"VerifyUptime\"\n    description = \"Verifies the device uptime is higher than a value.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"show uptime\")]\n\n    @AntaTest.anta_test\n    def test(self, minimum: Optional[int] = None) -&gt; None:\n\"\"\"\n        Run VerifyUptime validation\n\n        Args:\n            minimum: Minimum uptime in seconds.\n        \"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if not (isinstance(minimum, (int, float))) or minimum &lt; 0:\n            self.result.is_skipped(\"VerifyUptime was not run as incorrect minimum uptime was given\")\n            return\n\n        if command_output[\"upTime\"] &gt; minimum:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Uptime is {command_output['upTime']}\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyUptime.test","title":"<code>test(minimum=None)</code>","text":"<p>Run VerifyUptime validation</p> <p>Parameters:</p> Name Type Description Default <code>minimum</code> <code>Optional[int]</code> <p>Minimum uptime in seconds.</p> <code>None</code> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, minimum: Optional[int] = None) -&gt; None:\n\"\"\"\n    Run VerifyUptime validation\n\n    Args:\n        minimum: Minimum uptime in seconds.\n    \"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if not (isinstance(minimum, (int, float))) or minimum &lt; 0:\n        self.result.is_skipped(\"VerifyUptime was not run as incorrect minimum uptime was given\")\n        return\n\n    if command_output[\"upTime\"] &gt; minimum:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Uptime is {command_output['upTime']}\")\n</code></pre>"},{"location":"api/tests.vxlan/","title":"VxLAN","text":""},{"location":"api/tests.vxlan/#anta-catalog-for-vxlan-tests","title":"ANTA catalog for VxLAN tests","text":"<p>Test functions related to VXLAN</p>"},{"location":"api/tests.vxlan/#anta.tests.vxlan.VerifyVxlan","title":"<code>VerifyVxlan</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if Vxlan1 interface is configured, and is up/up</p> Source code in <code>anta/tests/vxlan.py</code> <pre><code>class VerifyVxlan(AntaTest):\n\"\"\"\n    Verifies if Vxlan1 interface is configured, and is up/up\n    \"\"\"\n\n    name = \"VerifyVxlan\"\n    description = \"Verifies Vxlan1 status\"\n    categories = [\"vxlan\"]\n    commands = [AntaCommand(command=\"show interfaces description\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyVxlan validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if \"Vxlan1\" not in command_output[\"interfaceDescriptions\"]:\n            self.result.is_skipped(\"Vxlan1 interface is not configured\")\n        elif (\n            command_output[\"interfaceDescriptions\"][\"Vxlan1\"][\"lineProtocolStatus\"] == \"up\"\n            and command_output[\"interfaceDescriptions\"][\"Vxlan1\"][\"interfaceStatus\"] == \"up\"\n        ):\n            self.result.is_success()\n        else:\n            self.result.is_failure(\n                f\"Vxlan1 interface is {command_output['interfaceDescriptions']['Vxlan1']['lineProtocolStatus']}\"\n                f\"/{command_output['interfaceDescriptions']['Vxlan1']['interfaceStatus']}\"\n            )\n</code></pre>"},{"location":"api/tests.vxlan/#anta.tests.vxlan.VerifyVxlan.test","title":"<code>test()</code>","text":"<p>Run VerifyVxlan validation</p> Source code in <code>anta/tests/vxlan.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyVxlan validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if \"Vxlan1\" not in command_output[\"interfaceDescriptions\"]:\n        self.result.is_skipped(\"Vxlan1 interface is not configured\")\n    elif (\n        command_output[\"interfaceDescriptions\"][\"Vxlan1\"][\"lineProtocolStatus\"] == \"up\"\n        and command_output[\"interfaceDescriptions\"][\"Vxlan1\"][\"interfaceStatus\"] == \"up\"\n    ):\n        self.result.is_success()\n    else:\n        self.result.is_failure(\n            f\"Vxlan1 interface is {command_output['interfaceDescriptions']['Vxlan1']['lineProtocolStatus']}\"\n            f\"/{command_output['interfaceDescriptions']['Vxlan1']['interfaceStatus']}\"\n        )\n</code></pre>"},{"location":"api/tests.vxlan/#anta.tests.vxlan.VerifyVxlanConfigSanity","title":"<code>VerifyVxlanConfigSanity</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies that there are no VXLAN config-sanity issues flagged</p> Source code in <code>anta/tests/vxlan.py</code> <pre><code>class VerifyVxlanConfigSanity(AntaTest):\n\"\"\"\n    Verifies that there are no VXLAN config-sanity issues flagged\n    \"\"\"\n\n    name = \"VerifyVxlanConfigSanity\"\n    description = \"Verifies VXLAN config-sanity\"\n    categories = [\"vxlan\"]\n    commands = [AntaCommand(command=\"show vxlan config-sanity\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyVxlanConfigSanity validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if \"categories\" not in command_output or len(command_output[\"categories\"]) == 0:\n            self.result.is_skipped(\"VXLAN is not configured on this device\")\n            return\n\n        failed_categories = {\n            category: content\n            for category, content in command_output[\"categories\"].items()\n            if category in [\"localVtep\", \"mlag\", \"pd\"] and content[\"allCheckPass\"] is not True\n        }\n\n        if len(failed_categories) &gt; 0:\n            self.result.is_failure(f\"Vxlan config sanity check is not passing: {failed_categories}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.vxlan/#anta.tests.vxlan.VerifyVxlanConfigSanity.test","title":"<code>test()</code>","text":"<p>Run VerifyVxlanConfigSanity validation</p> Source code in <code>anta/tests/vxlan.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyVxlanConfigSanity validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if \"categories\" not in command_output or len(command_output[\"categories\"]) == 0:\n        self.result.is_skipped(\"VXLAN is not configured on this device\")\n        return\n\n    failed_categories = {\n        category: content\n        for category, content in command_output[\"categories\"].items()\n        if category in [\"localVtep\", \"mlag\", \"pd\"] and content[\"allCheckPass\"] is not True\n    }\n\n    if len(failed_categories) &gt; 0:\n        self.result.is_failure(f\"Vxlan config sanity check is not passing: {failed_categories}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"cli/debug/","title":"Helpers","text":""},{"location":"cli/debug/#anta-debug-commands","title":"ANTA debug commands","text":"<p>ANTA CLI also provides a set of entrypoints to help building ANTA content. We call it debug and it provides different options:</p> <ul> <li>Run a command on a device from your inventory and expose a result from AntaCommand</li> <li>Run a templated command and expose the result</li> </ul> <p>Both are extremly useful to build your test since you have a visual access to the output you have to test. It also helps to extract content to use for unit test as descirbed in our contribution guide.</p> <p>Use your inventory</p> <p>Because it is based on ANTA cli, all your commands use an ANTA inventory and require to get a valid one.</p>"},{"location":"cli/debug/#get-result-of-an-eos-command","title":"Get result of an EOS command","text":"<p>To run a command, you can leverage <code>run-cmd</code> entrypoint with following options:</p> <pre><code>$ anta debug run-cmd --help\nUsage: anta debug run-cmd [OPTIONS]\n\nRun arbitrary command to an EOS device and get result using eAPI\n\nOptions:\n  -c, --command TEXT             Command to run on EOS using eAPI  [required]\n--ofmt [text|json]             eAPI format to use. can be text or json\n  --api-version, --version TEXT  Version of the command through eAPI\n  -d, --device TEXT              Device from inventory to use  [required]\n--log-level, --log TEXT        Logging level of the command\n--help                         Show this message and exit.\n</code></pre> <p>In practice, this command is very simple to use. Here is an example using <code>show interfaces description</code> with a <code>JSON</code> format:</p> <pre><code>anta debug run-cmd -c \"show interfaces description\" --device ptt015\nrun command show interfaces description on ptt015\n{\n'interfaceDescriptions': {\n'Ethernet8': {'interfaceStatus': 'adminDown', 'description': '', 'lineProtocolStatus': 'down'},\n        'Ethernet9': {'interfaceStatus': 'adminDown', 'description': '', 'lineProtocolStatus': 'down'},\n        'Ethernet12': {'interfaceStatus': 'adminDown', 'description': '', 'lineProtocolStatus': 'down'},\n    ...\n}\n</code></pre>"},{"location":"cli/debug/#get-result-of-an-eos-command-using-templates","title":"Get result of an EOS command using templates","text":"<p>This command allows user to provide an <code>f-string</code> and a list of dictionary to run a command dynamically. Idea is to help building output for test using such approach.</p> <pre><code>$ anta debug run-template --help\nUsage: anta debug run-template [OPTIONS]\n\nRun arbitrary command to an EOS device and get result using eAPI\n\nOptions:\n  -t, --template TEXT            Command template to run on EOS using eAPI\n  -p, --params TEXT              Command parameters to use with template. Must\n                                 be a JSON string for a list of dict\n                                 [required]\n--ofmt [text|json]             eAPI format to use. can be text or json\n  --api-version, --version TEXT  Version of the command through eAPI\n  -d, --device TEXT              Device from inventory to use  [required]\n--log-level, --log TEXT        Logging level of the command\n--help                         Show this message and exit.\n</code></pre> <p>In practice, this command is very simple to use. Here is an example using <code>show lldp neighbors</code> with a <code>JSON</code> format for only 2 interfaces: Ethernet1 and Ethernet2</p> <pre><code>anta debug run-template \\\n--params \"[{\"ifd\": \"Ethernet1\"}, {\"ifd\":\"Ethernet2\"}]\" \\\n--template \"show lldp neighbors {ifd}\" \\\n--device ptt015\n\nrun dynmic command show lldp neighbors {ifd} with [{\"ifd\": \"Ethernet1\"}, {\"ifd\":\"Ethernet2\"}] on ptt015\nrun_command = show lldp neighbors Ethernet1 ptt015\n{\n\"tablesLastChangeTime\": 1682498936.0082116,\n  \"tablesAgeOuts\": 0,\n  \"tablesInserts\": 1,\n  \"lldpNeighbors\": [],\n  \"tablesDeletes\": 0,\n  \"tablesDrops\": 0\n}\nrun_command = show lldp neighbors Ethernet2 ptt015\n{\n\"tablesLastChangeTime\": 1682498936.008321,\n  \"tablesAgeOuts\": 0,\n  \"tablesInserts\": 1,\n  \"lldpNeighbors\": [],\n  \"tablesDeletes\": 0,\n  \"tablesDrops\": 0\n}\n</code></pre>"},{"location":"cli/exec/","title":"Execute commands","text":""},{"location":"cli/exec/#execute-commands-on-devices","title":"Execute commands on devices","text":"<p>ANTA CLI also provides a set of entrypoints to execute commands remotely on EOS devices.</p>"},{"location":"cli/exec/#clear-interfaces-counters","title":"Clear interfaces counters","text":"<p>This command clear interfaces counters on EOS devices defined in your inventory</p> <pre><code>$ anta exec clear-counters --help\nUsage: anta exec clear-counters [OPTIONS]\n\nClear counter statistics on EOS devices\n\nOptions:\n  -t, --tags TEXT                 List of tags using comma as separator:\n                                  tag1,tag2,tag3\n  --log-level, --log [debug|info|warning|critical]\nLogging level of the command\n--help                          Show this message and exit.\n</code></pre>"},{"location":"cli/exec/#collect-a-set-of-commands","title":"Collect a set of commands","text":"<p>This command collects all commands you defined in a catalog. It can be either <code>json</code> or <code>text</code>.</p> <pre><code>$ anta exec snapshot --help\nUsage: anta exec snapshot [OPTIONS]\n\nCollect commands output from devices in inventory\n\nOptions:\n  -t, --tags TEXT                 List of tags using comma as separator:\n                                  tag1,tag2,tag3\n  -c, --commands-list PATH        File with list of commands to grab  [env\n                                  var: ANTA_EXEC_SNAPSHOT_COMMANDS_LIST]\n-outut, -o, --output-directory PATH\n                                  Path where to save commands output  [env\n                                  var: ANTA_EXEC_SNAPSHOT_OUTPUT_DIRECTORY]\n--log-level, --log [debug|info|warning|critical]\nLogging level of the command\n--help                          Show this message and exit.\n</code></pre> <p>And structure of your catalog file should be:</p> <pre><code>json_format:\n- show version\ntext_format:\n- show agent logs crash\n- show bfd peers\n- show bgp evpn\n</code></pre>"},{"location":"cli/exec/#get-scheduled-tech-support","title":"Get Scheduled tech-support","text":"<p>EOS comes with a feature that generates tech-support archive every 1 hour by default and save this archive under <code>/mnt/flash/schedule/tech-support</code></p> <pre><code>leaf1#show schedule summary\nMaximum concurrent jobs  1\nPrepend host name to logfile: Yes\nName                 At Time       Last        Interval       Timeout        Max        Max     Logfile Location                  Status\n                                   Time         (mins)        (mins)         Log        Logs\n                                                                            Files       Size\n----------------- ------------- ----------- -------------- ------------- ----------- ---------- --------------------------------- ------\ntech-support           now         08:37          60            30           100         -      flash:schedule/tech-support/      Success\n\n\nleaf1#bash ls /mnt/flash/schedule/tech-support\nleaf1_tech-support_2023-03-09.1337.log.gz  leaf1_tech-support_2023-03-10.0837.log.gz  leaf1_tech-support_2023-03-11.0337.log.gz  ...\n</code></pre> <p>As it can be useful for an NRFU to save a very complete state report before a go live, ANTA has implemented a CLI that retrieves these files very easily:</p> <pre><code>\u276f anta exec collect-tech-support --help\n\nUsage: anta exec collect-tech-support [OPTIONS]\n\nCollect scheduled tech-support from eos devices.\n\nOptions:\n  -o, --output PATH               Path for tests catalog  [default: ./tech-\n                                  support]\n-ssh, --ssh-port INTEGER        SSH port to use for connection  [default:\n                                  22]\n--insecure / --secure           Disable SSH Host Key validation  [default:\n                                  secure]\n--latest INTEGER                Number of scheduled show-tech to retrieve\n  --configure / --not-configure   Ensure device has 'aaa authorization exec\n                                  default local' configured (required for SCP)\n[default: not-configure]\n-t, --tags TEXT                 List of tags using coma as separator:\n                                  tag1,tag2,tag3\n  --log-level, --log [debug|info|warning|critical]\nLogging level of the command  [default:\n                                  info]\n--help                          Show this message and exit.\n</code></pre> <p>When you run this command, it will retrieve tech-support files and download it locally in a folder and a subfolder per device. You can change the default output folder with the <code>--output</code> option. ANTA download files from the devices using SCP, all SSH Host Key devices must be trusted prior to run the command, otherwise use the <code>--insecure</code> option. In order to use SCP with EOS, the configuration <code>aaa authorization exec default local</code> must be present on the devices. By default, ANTA will not configure this automatically, unless <code>--configure</code> is specified. It is possible to retrieve only the latest tech-support files using the <code>--latest</code> option.</p> <pre><code>\u276f anta exec collect-tech-support --insecure\n[15:27:19] INFO     Connecting to devices...\nINFO     Copying '/mnt/flash/schedule/tech-support/spine1_tech-support_2023-06-09.1315.log.gz' from device spine1 to 'tech-support/spine1' locally\nINFO     Copying '/mnt/flash/schedule/tech-support/leaf3_tech-support_2023-06-09.1315.log.gz' from device leaf3 to 'tech-support/leaf3' locally\nINFO     Copying '/mnt/flash/schedule/tech-support/leaf1_tech-support_2023-06-09.1315.log.gz' from device leaf1 to 'tech-support/leaf1' locally\nINFO     Copying '/mnt/flash/schedule/tech-support/leaf2_tech-support_2023-06-09.1315.log.gz' from device leaf2 to 'tech-support/leaf2' locally\nINFO     Copying '/mnt/flash/schedule/tech-support/spine2_tech-support_2023-06-09.1315.log.gz' from device spine2 to 'tech-support/spine2' locally\nINFO     Copying '/mnt/flash/schedule/tech-support/leaf4_tech-support_2023-06-09.1315.log.gz' from device leaf4 to 'tech-support/leaf4' locally\nINFO     Collected 1 scheduled tech-support from leaf2\nINFO     Collected 1 scheduled tech-support from spine2\nINFO     Collected 1 scheduled tech-support from leaf3\nINFO     Collected 1 scheduled tech-support from spine1\nINFO     Collected 1 scheduled tech-support from leaf1\nINFO     Collected 1 scheduled tech-support from leaf4\n</code></pre> <p>The output folder will look like this:</p> <pre><code>\u276f tree tech-support/\ntech-support/\n\u251c\u2500\u2500 leaf1\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 leaf1_tech-support_2023-06-09.1315.log.gz\n\u251c\u2500\u2500 leaf2\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 leaf2_tech-support_2023-06-09.1315.log.gz\n\u251c\u2500\u2500 leaf3\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 leaf3_tech-support_2023-06-09.1315.log.gz\n\u251c\u2500\u2500 leaf4\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 leaf4_tech-support_2023-06-09.1315.log.gz\n\u251c\u2500\u2500 spine1\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 spine1_tech-support_2023-06-09.1315.log.gz\n\u2514\u2500\u2500 spine2\n    \u2514\u2500\u2500 spine2_tech-support_2023-06-09.1315.log.gz\n\n6 directories, 6 files\n</code></pre>"},{"location":"cli/get-inventory-information/","title":"Get Inventory Information","text":""},{"location":"cli/get-inventory-information/#get-inventory-information","title":"Get Inventory Information","text":"<p>ANTA CLI provides a set of entrypoints to get data from your local inventory.</p>"},{"location":"cli/get-inventory-information/#get-all-configured-tags","title":"Get all configured tags","text":"<p>Since most commands in anta support tags filtering, this command helps you list all available tags configured in your inventory.</p>"},{"location":"cli/get-inventory-information/#command-overview","title":"Command overview","text":"<pre><code>anta get tags --help\nUsage: anta get tags [OPTIONS]\n\nGet list of configured tags in user inventory.\n\nOptions:\n  --log-level, --log [debug|info|warning|critical]\nLogging level of the command\n--help                          Show this message and exit.\n</code></pre>"},{"location":"cli/get-inventory-information/#example","title":"Example","text":"<p>Let\u2019s consider the following inventory:</p> <pre><code>anta_inventory:\nhosts:\n- host: 192.168.0.10\nname: spine01\ntags: ['fabric', 'spine']\n- host: 192.168.0.11\nname: spine02\ntags: ['fabric', 'spine']\n- host: 192.168.0.12\nname: leaf01\ntags: ['fabric', 'leaf']\n- host: 192.168.0.13\nname: leaf02\ntags: ['fabric', 'leaf']\n- host: 192.168.0.14\nname: leaf03\ntags: ['fabric', 'leaf']\n- host: 192.168.0.15\nname: leaf04\ntags: ['fabric', 'leaf']\n</code></pre> <p>To get the list of all configured tags in your CLI, run the following command:</p> <pre><code>$ anta get tags\nTags found:\n[\n\"all\",\n  \"fabric\",\n  \"leaf\",\n  \"spine\"\n]\nNone\n\n* note that tag all has been added by anta\n</code></pre> <p>Tip</p> <p>As you can see, the tag <code>all</code> has been added even if not explicitely configued in your inventory. This tag is the default tag added to all your devices to run commands against your inventory when you do not provide any specific tag.</p>"},{"location":"cli/get-inventory-information/#list-devices-in-inventory","title":"List devices in inventory","text":""},{"location":"cli/get-inventory-information/#command-overview_1","title":"Command overview","text":"<p>To get a list of all devices available in your inventory with ANTA, use the following command</p> <pre><code>anta get inventory --help\nUsage: anta get inventory [OPTIONS]\n\nShow inventory loaded in ANTA.\n\nOptions:\n  -t, --tags TEXT                 List of tags using comma as separator:\n                                  tag1,tag2,tag3\n  --log-level, --log [debug|info|warning|critical]\nLogging level of the command\n--connected / --not-connected   Display inventory after connection has been\n                                  created\n  --help                          Show this message and exit.\n</code></pre> <p>It will give you all information loaded in ANTA inventory from your inventory file.</p> <p>Tip</p> <p>By default only information not based on device connection is available. If you want to get information based on connection such as hardware model, you should use the <code>--connected</code> option.</p>"},{"location":"cli/get-inventory-information/#example_1","title":"Example","text":"<p>Considering the following inventory file:</p> <pre><code>anta_inventory:\nhosts:\n- host: 192.168.0.10\nname: spine01\ntags: ['fabric', 'spine']\n- host: 192.168.0.11\nname: spine02\ntags: ['fabric', 'spine']\n- host: 192.168.0.12\nname: leaf01\ntags: ['fabric', 'leaf']\n- host: 192.168.0.13\nname: leaf02\ntags: ['fabric', 'leaf']\n- host: 192.168.0.14\nname: leaf03\ntags: ['fabric', 'leaf']\n- host: 192.168.0.15\nname: leaf04\ntags: ['fabric', 'leaf']\n</code></pre> <p>You can get ANTA inventory with the command:</p> <pre><code>$ anta --username ansible --password ansible get inventory --tags spine\nCurrent inventory content is:\n[\n{\n\"name\": \"spine01\",\n    \"host\": \"192.168.0.10\",\n    \"username\": \"ansible\",\n    \"password\": \"ansible\",\n    \"port\": \"443\",\n    \"enable_password\": \"None\",\n    \"session\": \"&lt;aioeapi.device.Device object at 0x7fa98d0a2d30&gt;\",\n    \"hw_model\": \"unset\",\n    \"tags\": \"['fabric', 'spine', 'all']\",\n    \"timeout\": \"10.0\",\n    \"established\": \"False\",\n    \"is_online\": \"False\"\n},\n  {\n\"name\": \"spine02\",\n    \"host\": \"192.168.0.11\",\n    \"username\": \"ansible\",\n    \"password\": \"ansible\",\n    \"port\": \"443\",\n    \"enable_password\": \"None\",\n    \"session\": \"&lt;aioeapi.device.Device object at 0x7fa98d0a2ac0&gt;\",\n    \"hw_model\": \"unset\",\n    \"tags\": \"['fabric', 'spine', 'all']\",\n    \"timeout\": \"10.0\",\n    \"established\": \"False\",\n    \"is_online\": \"False\"\n}\n]\nNone\n</code></pre>"},{"location":"cli/inv-from-cvp/","title":"Inventory from CVP","text":""},{"location":"cli/inv-from-cvp/#create-inventory-from-cloudvision","title":"Create inventory from CloudVision","text":"<p>In a large setup, it can be useful to create your inventory based on CloudVision inventory.</p> <pre><code>$ anta get from-cvp\nUsage: anta get from-cvp [OPTIONS]\n\nBuild ANTA inventory from Cloudvision\n\nOptions:\n  -ip, --cvp-ip TEXT              CVP IP Address\n  -u, --cvp-username TEXT         CVP Username\n  -p, --cvp-password TEXT         CVP Password / token\n  -c, --cvp-container TEXT        Container where devices are configured\n  -d, --inventory-directory PATH  Path to save inventory file\n  --log-level, --log [debug|info|warning|critical]\nLogging level of the command\n--help                          Show this message and exit.\n</code></pre> <p>Output is an inventory with the name of the container added as a tag for the host:</p> <pre><code>anta_inventory:\nhosts:\n- host: 192.168.0.13\nname: leaf2\ntags:\n- pod1\n- host: 192.168.0.15\nname: leaf4\ntags:\n- pod2\n</code></pre> <p>Warning</p> <p>Current implementation only takes devices directly attached to a specific container when using cli with <code>--cvp-container</code> option.</p> <p>If you want to build an inventory based on multiple containers, you can use a bash command as shown below and then manually concatenate files to create a single inventory file.</p> <pre><code>$ for container in pod01 pod02 spines; do anta get from-cvp -ip &lt;cvp-ip&gt; -u cvpadmin -p cvpadmin -c $container -d test-inventory; done\n\n[12:25:35] INFO     Getting auth token from cvp.as73.inetsix.net for user tom\n[12:25:36] INFO     Creating inventory folder /home/tom/Projects/arista/network-test-automation/test-inventory\n           WARNING  Using the new api_token parameter. This will override usage of the cvaas_token parameter if both are provided. This is because api_token and cvaas_token parameters\n                    are for the same use case and api_token is more generic\n           INFO     Connected to CVP cvp.as73.inetsix.net\n\n\n[12:25:37] INFO     Getting auth token from cvp.as73.inetsix.net for user tom\n[12:25:38] WARNING  Using the new api_token parameter. This will override usage of the cvaas_token parameter if both are provided. This is because api_token and cvaas_token parameters\n                    are for the same use case and api_token is more generic\n           INFO     Connected to CVP cvp.as73.inetsix.net\n\n\n[12:25:38] INFO     Getting auth token from cvp.as73.inetsix.net for user tom\n[12:25:39] WARNING  Using the new api_token parameter. This will override usage of the cvaas_token parameter if both are provided. This is because api_token and cvaas_token parameters\n                    are for the same use case and api_token is more generic\n           INFO     Connected to CVP cvp.as73.inetsix.net\n\n           INFO     Inventory file has been created in /home/tom/Projects/arista/network-test-automation/test-inventory/inventory-spines.yml\n</code></pre>"},{"location":"cli/nrfu/","title":"NRFU","text":""},{"location":"cli/nrfu/#execute-nrfu-testing","title":"Execute NRFU testing","text":"<p>All the NRFU testing commands are placed under <code>anta nrfu</code> and provide different rendering options:</p> <ul> <li>Table view</li> <li>JSON view</li> <li>Text view</li> <li>Custom template view</li> </ul> <pre><code>anta nrfu\nUsage: anta nrfu [OPTIONS] COMMAND [ARGS]...\n\n  Run NRFU against inventory devices\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  json        ANTA command to check network state with JSON result\n  table       ANTA command to check network states with table result\n  text        ANTA command to check network states with text result\n  tpl-report  ANTA command to check network state with templated report\n</code></pre> <p>All of these commands require the following input:</p> <ul> <li>A path to a catalog of tests to execute (<code>--catalog</code>)</li> <li>A list of tags if they are part of your inventory (<code>--tags</code>). List is comma separated</li> </ul>"},{"location":"cli/nrfu/#nrfu-with-text-rendering","title":"NRFU with text rendering","text":"<p>This rendering is a pure text report for every test run on all devices. It comes with some options:</p> <ul> <li>Search (<code>--search</code>) for a regexp pattern in hostname and test name</li> <li>Option to skip (<code>--skip-error</code>) tests in error (not failure) because of a connectivity issue or unsupported command</li> </ul> <p>Example output</p> <pre><code>$ anta nrfu text --tags pod1 --catalog nrfu/leaf.yml\nleaf2 :: VerifyMlagStatus :: SUCCESS\nleaf2 :: VerifyMlagInterface :: SUCCESS\nleaf2 :: VerifyMlagConfigSanity :: SUCCESS\nleaf2 :: VerifyInterfaceUtilization :: SUCCESS\nleaf2 :: VerifyInterfaceErrors :: SUCCESS\nleaf2 :: VerifyInterfaceDiscards :: SUCCESS\nleaf2 :: VerifyInterfaceErrDisabled :: SUCCESS\nleaf2 :: VerifyInterfaceStatus :: SUCCESS\nleaf2 :: VerifyStormControlDrop :: SKIPPED (VerifyStormControlDrop test is not supported on cEOSLab.)\nleaf2 :: VerifyPortChannel :: SUCCESS\nleaf2 :: VerifyIllegalLacp :: SUCCESS\nleaf2 :: VerifyLoopbackCount :: FAILURE (Found 3 Loopbacks when expecting 2)\nleaf2 :: VerifySvi :: SUCCESS\n[...]\n</code></pre>"},{"location":"cli/nrfu/#nrfu-with-table-report","title":"NRFU with table report","text":"<p>This rendering prints results in a nice table supporting grep filtering. It comes with its own set of options:</p> <ul> <li>Search (<code>--search</code>) for a pattern in hostname and test name.</li> <li>Option to group (<code>--group-by</code>) and summarize results. You can group by <code>host</code> or <code>test</code>.</li> </ul> <pre><code>$ anta check table -t pod1 -c nrfu/cudi.yml\n</code></pre> <p></p> <p>You can also group per host or per test to get a summary view in case of large setup</p> <p></p>"},{"location":"cli/nrfu/#nrfu-with-json-output","title":"NRFU with JSON output","text":"<p>This command is helpful to generate a JSON and then pass it to another tool for reporting for instance. Only one option is available to save output to a file (<code>--output</code>)</p> <pre><code>$ anta check json -t pod1 -c nrfu/leaf.yml\n[\n{\n\"name\": \"leaf01\",\n    \"test\": \"VerifyZeroTouch\",\n    \"test_category\": [\n\"configuration\"\n],\n    \"test_description\": \"Verifies ZeroTouch is disabled.\",\n    \"result\": \"success\",\n    \"messages\": []\n},\n  {\n\"name\": \"leaf01\",\n    \"test\": \"VerifyRunningConfigDiffs\",\n    \"test_category\": [\n\"configuration\"\n],\n    \"test_description\": \"\",\n    \"result\": \"success\",\n    \"messages\": []\n},\n]\n</code></pre>"},{"location":"cli/nrfu/#nrfu-with-your-own-report","title":"NRFU with your own report","text":"<p>Because you may want to have a specific report format, ANTA provides a CLI option to build report based on Jinja2 template.</p> <pre><code>$ anta nrfu tpl-report -c .personal/catalog-class.yml -tpl .personal/test_template.j2\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Settings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Running check-devices with:                                \u2502\n\u2502               - Inventory: .personal/inventory_atd.yml     \u2502\n\u2502               - Tests catalog: .personal/catalog-class.yml \u2502\n\u2502               - Template: .personal/test_template.j2       \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n* VerifyZeroTouch is SUCCESS for spine01\n* VerifyRunningConfigDiffs is SUCCESS for spine01\n* VerifyInterfaceUtilization is SUCCESS for spine01\n</code></pre> <p>And the template <code>.personal/test_template.j2</code> is a pure Jinja2 template:</p> <pre><code>$ cat .personal/test_template.j2\n{% for d in data %}\n* {{ d.test }} is [green]{{ d.result | upper}}[/green] for {{ d.name }}\n{% endfor %}\n</code></pre> <p>In this context, Jinja2 template can access to all <code>TestResult</code> elements with their values as described in this documentation.</p> <p>An option is available to save the generated report into a text file:</p> <pre><code># Run ANTA\n$ anta nrfu tpl-report -c .personal/catalog-class.yml -tpl .personal/test_template.j2 -o .personal/demo.txt\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Settings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Running check-devices with:                                \u2502\n\u2502               - Inventory: .personal/inventory_atd.yml     \u2502\n\u2502               - Tests catalog: .personal/catalog-class.yml \u2502\n\u2502               - Template: .personal/test_template.j2       \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n* VerifyZeroTouch is SUCCESS for spine01\n* VerifyRunningConfigDiffs is SUCCESS for spine01\n* VerifyInterfaceUtilization is SUCCESS for spine01\n\n# Display saved report\n$ cat .personal/demo.txt\n* VerifyZeroTouch is [green]SUCCESS[/green] for spine01\n* VerifyRunningConfigDiffs is [green]SUCCESS[/green] for spine01\n* VerifyInterfaceUtilization is [green]SUCCESS[/green] for spine01\n</code></pre>"},{"location":"cli/overview/","title":"Overview","text":""},{"location":"cli/overview/#cli-overview","title":"CLI overview","text":"<p>ANTA comes with a CLI to execute all the supported actions. If you want to build your own tool, you should visit this page where we describe how to use ANTA as a python library</p> <p>To invoke anta, open a shell window and then enter <code>anta</code></p> <pre><code>Usage: anta [OPTIONS] COMMAND [ARGS]...\n\n  Arista Network Test CLI\n\nOptions:\n  --version                       Show the version and exit.\n  --username TEXT                 Username to connect to EOS  [env var:\n                                  ANTA_USERNAME; required]\n--password TEXT                 Password to connect to EOS  [env var:\n                                  ANTA_PASSWORD; required]\n--timeout INTEGER               Global connection timeout  [env var:\n                                  ANTA_TIMEOUT; default: 5]\n--insecure / --secure           Disable SSH Host Key validation  [env var:\n                                  ANTA_INSECURE; default: secure]\n--enable-password TEXT          Enable password if required to connect  [env\n                                  var: ANTA_ENABLE_PASSWORD]\n-i, --inventory FILE            Path to the inventory YAML file  [env var:\n                                  ANTA_INVENTORY; required]\n--log-level, --log [CRITICAL|ERROR|WARNING|INFO|DEBUG]\nANTA logging level  [env var:\n                                  ANTA_LOG_LEVEL; default: INFO]\n--ignore-status                 Always exit with success  [env var:\n                                  ANTA_IGNORE_STATUS]\n--ignore-error                  Only report failures and not errors  [env\n                                  var: ANTA_IGNORE_ERROR]\n--help                          Show this message and exit.\n\nCommands:\n  debug  Debug commands for building ANTA\n  exec   Execute commands to inventory devices\n  get    Get data from/to ANTA\n  nrfu   Run NRFU against inventory devices\n</code></pre>"},{"location":"cli/overview/#anta-parameters","title":"ANTA parameters","text":"<p>Some parameters are globally required and can be passed to anta via cli or via ENV VAR:</p> <pre><code>$ anta --username tom --password arista123 --inventory inventory.yml &lt;anta cli&gt;\n</code></pre> <p>Or if you prefer to set ENV VAR:</p> <pre><code># Save information for anta cli\n$ export ANTA_USERNAME=tom\n$ export ANTA_PASSWORD=arista123\n$ export ANTA_INVENTORY=inventory.yml\n\n# Run cli\n$ anta &lt;anta cli&gt;\n</code></pre>"},{"location":"cli/overview/#anta-exitcodes","title":"ANTA ExitCodes","text":"<p>For all subcommands except nrfu, <code>anta</code> wil return with the exit code 0.</p> <p>For the nrfu commands, <code>anta</code> is using the following exit codes:</p> <ul> <li>Exit code 0 - All tests passed successfully.</li> <li>Exit code 1 - Tests were run but at least one test returned a failure.</li> <li>Exit code 2 - Tests were run but at least one test returned an error.</li> <li>Exit code 3 - Internal error happened while executing tests (not used today).</li> </ul> <p>It is possible to ignore the status when running the nrfu command by using <code>anta --ignore-status nrfu</code> and in that case the exit code will always be 0.</p> <p>It is possible to ignore errors when running the nrfu command by using <code>anta --ignore-error nrfu</code> and in that case the exit code will either be 0 if all tests succeeded or 1 if any test failed.</p>"},{"location":"cli/overview/#shell-completion","title":"Shell Completion","text":"<p>You can enable shell completion for the anta cli:</p> ZSHBASH <p>If you use ZSH shell, add the following line in your <code>~/.zshrc</code>:</p> <pre><code>eval \"$(_ANTA_COMPLETE=zsh_source anta)\" &gt; /dev/null\n</code></pre> <p>With bash, add the following line in your <code>~/.bashrc</code>:</p> <pre><code>eval \"$(_ANTA_COMPLETE=bash_source anta)\" &gt; /dev/null\n</code></pre>"}]}